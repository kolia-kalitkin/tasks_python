
# ████─████─████
# █──█─█──█─█──█
# █──█─█──█─█──█    ## Все решенные задачи написаны в одном файле (одна за другой)
# █──█─█──█─█──█    # проекты буду создавать в отдельных папках в будущем
# ████─████─█──█


# Класс Circle
#  977
# Реализуйте класс Circle, описывающий круг. При создании экземпляра класс должен принимать один аргумент:
#     radius — радиус круга
# Экземпляр класса Circle должен иметь три атрибута:
#     radius — радиус круга
#     diameter — диаметр круга
#     area — площадь круга
# Примечание 1. Площадь круга вычисляется по формуле πr2πr2, где rr — радиус круга, ππ — константа, которая выражает отношение длины окружности к ее диаметру.
# Примечание 2. Импортировать константу ππ можно из модуля math:
# from math import pi
# ---------------------------------------------------------------

# import math


from dateutil.relativedelta import relativedelta
from datetime import date, timedelta
from functools import singledispatchmethod
import re
import string
from typing import Self
import math
import copy


class Circle:
    def __init__(self, radius) -> None:
        self.radius = radius
        self.diameter = 2 * radius
        self.area = math.pi * radius**2


circle = Circle(5)

print(circle.radius)
print(circle.diameter)
print(circle.area)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


#  Класс Bee
#
# Реализуйте класс Bee, описывающий пчелку, которая перемещается по координатной плоскости в четырех направлениях: вверх, вниз, влево и вправо. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата пчелки по оси xx, по умолчанию имеет значение 0
#     y — координата пчелки по оси yy, по умолчанию имеет значение 0
# Экземпляр класса Bee должен иметь два атрибута:
#     x — координата пчелки по оси xx
#     y — координата пчелки по оси yy
# Класс Bee должен иметь четыре метода экземпляра:
#     move_up() — метод, принимающий в качестве аргумента целое число n и увеличивающий координату пчелки по оси yy на n
#     move_down() — метод, принимающий в качестве аргумента целое число n и уменьшающий координату пчелки по оси yy на n
#     move_right() — метод, принимающий в качестве аргумента целое число n и увеличивающий координату пчелки по оси xx на n
#     move_left() — метод, принимающий в качестве аргумента целое число n и уменьшающий координату пчелки по оси xx на n
# ---------------------------------------------------------------
class Bee:
    def __init__(self, x=0, y=0) -> None:
        self.x = x
        self.y = y

    def move_up(self, n):
        self.y += n

    def move_down(self, n):
        self.y -= n

    def move_right(self, n):
        self.x += n

    def move_left(self, n):
        self.x -= n


bee = Bee()

bee.move_right(2)
bee.move_right(2)
bee.move_up(3)
bee.move_left(1)
bee.move_down(1)

print(bee.x, bee.y)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Gun
# 979
# Реализуйте класс Gun, описывающий ружье. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Gun должен иметь один метод экземпляра:
#     shoot() — метод, при первом вызове которого выводится строка pif, при втором — paf, при третьем — pif, при четвертом — paf, и так далее
# ---------------------------------------------------------------
class Gun:
    def __init__(self) -> None:
        self.pif = 'pif'
        self.paf = 'paf'
        self.cnt = 0

    def shoot(self):
        if self.cnt % 2 == 0:
            print(self.pif)
        else:
            print(self.paf)
        self.cnt += 1


gun = Gun()

gun.shoot()
gun.shoot()
gun.shoot()
gun.shoot()

# ---------------------------------------------------------------


class Gun:
    def __init__(self):
        self.shoots = 0

    def shoot(self):
        self.shoots += 1
        print(('paf', 'pif')[self.shoots % 2])
# ---------------------------------------------------------------

# from itertools import cycle


# class Gun:
#     def __init__(self):
#         self.sounds = cycle(('pif', 'paf'))

#     def shoot(self):
#         print(next(self.sounds))


# Класс Gun2
# 973
# Реализуйте класс Gun, описывающий ружье. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Gun должен иметь три метода экземпляра:
#     shoot() — метод, при первом вызове которого выводится строка pif, при втором — paf, при третьем — pif, при четвертом — paf, и так далее
#     shots_count() — метод, возвращающий актуальное количество вызовов метода shoot()
#     shots_reset() — метод, сбрасывающий количество вызовов метода shoot() до нуля
# ---------------------------------------------------------------
class Gun:
    def __init__(self) -> None:
        self.cnt_call_method_shoot = 0

    def shoot(self):
        self.cnt_call_method_shoot += 1
        # print(('paf', 'pif')[self.cnt_call_method_shoot % 2])
        print('pif' if self.cnt_call_method_shoot % 2 else 'paf')

    def shots_count(self):
        return self.cnt_call_method_shoot

    def shots_reset(self):
        self.cnt_call_method_shoot = 0
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Scales
# 970
# Реализуйте класс Scales, описывающий весы с двумя чашами. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Scales должен иметь три метода экземпляра:
#     add_right() — метод, принимающий в качестве аргумента массу груза в килограммах и добавляющий на правую чашу весов этот груз
#     add_left() — метод, принимающий в качестве аргумента массу груза в килограммах и добавляющий на левую чашу весов этот груз
#     get_result() — метод, возвращающий строку Весы в равновесии, если массы грузов на чашах совпадают, Правая чаша тяжелее — если правая чаша тяжелее, Левая чаша тяжелее — если левая чаша тяжелее
# Примечание 1. Пустые весы всегда находятся в равновесии.
# ---------------------------------------------------------------
class Scales:
    def __init__(self) -> None:
        self.cap_right = 0
        self.cap_left = 0

    def add_right(self, cargo_mass_right):
        self.cap_right += cargo_mass_right

    def add_left(self, cargo_mass_left):
        self.cap_left += cargo_mass_left

    def get_result(self):
        if self.cap_left == self.cap_right:
            message = 'Весы в равновесии'
        elif self.cap_left < self.cap_right:
            message = 'Правая чаша тяжелее'
        elif self.cap_left > self.cap_right:
            message = 'Левая чаша тяжелее'

        return message
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Vector
# 964
# Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата вектора по оси xx, по умолчанию имеет значение 0
#     y — координата вектора по оси yy, по умолчанию имеет значение 0
# Экземпляр класса Vector должен иметь два атрибута:
#     x — координата вектора по оси xx
#     y — координата вектора по оси yy
# Класс Vector должен иметь один метод экземпляра:
#     abs() — метод, возвращающий модуль вектора
# Примечание 1. Модуль вектора с координатами (x,y)(x,y) вычисляется по формуле x2+y2x2+y2
# ---------------------------------------------------------------
class Vector:
    def __init__(self, x=0, y=0) -> None:
        self.x = x
        self.y = y

    def abs(self):
        return (self.x**2 + self.y**2)**0.5
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# Класс Numbers
# 963
# Реализуйте класс Numbers, описывающий изначально пустой расширяемый набор целых чисел. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Numbers должен иметь три метода экземпляра:
#     add_number() — метод, принимающий в качестве аргумента целое число и добавляющий его в набор
#     get_even() — метод, возвращающий список всех четных чисел из набора
#     get_odd() — метод, возвращающий список всех нечетных чисел из набора
# Примечание 1. Числа в списках, возвращаемых методами get_even() и get_odd(), должны располагаться в том порядке, в котором они были добавлены в набор.
# ---------------------------------------------------------------


class Numbers:
    def __init__(self) -> None:
        self.lst = []

    def add_number(self, num):
        self.lst.append(num)

    def get_even(self):
        return list(filter(lambda x: x % 2, self.lst))

    def get_odd(self):
        return list(filter(lambda x: not x % 2, self.lst))


numbers = Numbers()

numbers.add_number(1)
numbers.add_number(3)
numbers.add_number(1)

print(numbers.get_even())
print(numbers.get_odd())
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс TextHandler
# 944
# Будем называть словом любую последовательность из одной или более букв. Текстом будем считать набор слов, разделенных пробельными символами.
# Реализуйте класс TextHandler, описывающий изначально пустой расширяемый набор слов. При создании экземпляра класс не должен принимать никаких аргументов.
# Экземпляр класса TextHandler должен иметь три метода:
#     add_words() — метод, принимающий в качестве аргумента текст и добавляющий слова из данного текста в набор
#     get_shortest_words() — метод, возвращающий актуальный список самых коротких слов в наборе
#     get_longest_words() — метод, возвращающий актуальный список самых длинных слов в наборе
# Примечание 1. Слова в списках, возвращаемых методами get_shortest_words() и get_longest_words(), должны располагаться в том порядке, в котором они были добавлены в набор.
# ---------------------------------------------------------------
class TextHandler:
    def __init__(self) -> None:
        self.words = []

    def add_words(self, text):
        for word in text.split():
            self.words.append(word)

    def get_shortest_words(self):
        short = min(self.words, key=len, default=None)

        if short:
            return list(filter(lambda x: len(x) == len(short), self.words))
        return []

    def get_longest_words(self):
        long = max(self.words, key=len, default=None)

        if long:
            return list(filter(lambda x: len(x) == len(long), self.words))
        return []
# -------------------ПРЕПОД--------------------------------------


class TextHandler:
    def __init__(self):
        self.words = []
        self.shortest = 0
        self.longest = 0

    def add_words(self, words):
        words = words.split()
        self.words.extend(words)
        self.shortest = min(map(len, self.words))
        self.longest = max(map(len, self.words))

    def get_shortest_words(self):
        return [w for w in self.words if len(w) == self.shortest]

    def get_longest_words(self):
        return [w for w in self.words if len(w) == self.longest]
# ---------------------------------------------------------------


# Класс Todo
# 941
# Реализуйте класс Todo, описывающий список дел. При создании экземпляра класс не должен принимать никаких аргументов.
# Экземпляр класса Todo должен иметь один атрибут:
#     things — изначально пустой список дел, которые нужно выполнить
# Класс Todo должен иметь четыре метода экземпляра:
#     add() — метод, принимающий название дела и его приоритет (целое число) и добавляющий данное дело в список дел в виде кортежа:
#     (<название дела>, <приоритет>)
#     get_by_priority() — метод, принимающий в качестве аргумента целое число n и возвращающий список названий дел, имеющих приоритет n
#     get_low_priority() — метод, возвращающий список названий дел, имеющих самый низкий приоритет
#     get_high_priority() — метод, возвращающий список названий дел, имеющих самый высокий приоритет
# Примечание 1. Названия дел в списках, возвращаемых методами get_by_priority(), get_low_priority() и get_high_priority(), должны располагаться в том порядке, в котором они были добавлены в список.
# ---------------------------------------------------------------
class Todo:
    def __init__(self) -> None:
        self.things = []
        self.priority_lst = []

    def add(self, case_name, priority):
        self.things.append((case_name, priority))
        self.priority_lst.append(priority)

    def get_by_priority(self, n):
        self.priority_lst.append(n)
        return [w[0] for w in self.things if w[1] == n]

    def get_low_priority(self):
        low_low_priority = min(self.priority_lst, default=None)
        l1 = filter(lambda x: x[1] == low_low_priority, self.things)
        l1 = map(lambda x: x[0], l1)
        return list(l1)

    def get_high_priority(self):
        high_priority = max(self.priority_lst, default=None)
        l1 = filter(lambda x: x[1] == high_priority, self.things)
        l1 = map(lambda x: x[0], l1)
        return list(l1)


todo = Todo()

todo.add('Ответить на вопросы', 5)
todo.add('Сделать картинки', 1)
todo.add('Доделать задачи', 4)
todo.add('Дописать конспект', 5)

print(todo.get_low_priority())
print(todo.get_high_priority())
print(todo.get_by_priority(3))
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Postman
# 910
# Реализуйте класс Postman, описывающий почтальона. При создании экземпляра класс не должен принимать никаких аргументов.
# Экземпляр класса Postman должен иметь один атрибут:
#     delivery_data — изначально пустой список адресов, по которым следует доставить письма
# Экземпляр класса Postman должен иметь три метода экземпляра:
#     add_delivery() — метод, принимающий в качестве аргументов улицу, дом и квартиру, и добавляющий в список адресов эти данные в виде кортежа:
#     (<улица>, <дом>, <квартира>)
#     get_houses_for_street() — метод, принимающий в качестве аргумента улицу и возвращающий список всех домов на этой улице, в которые требуется доставить письма
#     get_flats_for_house() — метод, принимающий в качестве аргументов улицу и дом и возвращающий список всех квартир в этом доме, в которые требуется доставить письма
# Примечание 1. Дома и квартиры в списках, возвращаемых методами get_houses_for_street() и get_flats_for_house(), должны располагаться в том порядке, в котором они были добавлены.
# ---------------------------------------------------------------

class Postman:
    def __init__(self) -> None:
        # """изначально пустой список адресов, по которым следует доставить письма"""
        self.delivery_data = []

    def add_delivery(self, street, house, flat):
        """метод, принимающий в качестве аргументов улицу, дом и квартиру, и добавляющий в список адресов эти данные в виде кортежа:  """
        self.delivery_data.append((street, house, flat))

    def get_houses_for_street(self, street):
        """метод, принимающий в качестве аргумента улицу и возвращающий список всех домов на этой улице, в которые требуется доставить письма"""
        gen1 = (i[1] for i in self.delivery_data if i[0] == street)
        # удаляет дубликат списка
        l1 = []
        for i in gen1:
            if i not in l1:
                l1.append(i)
        # sorted(set(x), key=lambda d: x.index(d))
        # функцию drop_duplicates из пандаса
        # збавиться от дубликатов, сохранив порядок можно через словарь
        return l1

    def get_flats_for_house(self, street, house):
        """метод, принимающий в качестве аргументов улицу и дом и возвращающий список всех квартир в этом доме, в которые требуется доставить письма"""
        gen1 = (i[2] for i in self.delivery_data if i[0]
                == street and i[1] == house)
        l1 = []
        for i in gen1:
            if i not in l1:
                l1.append(i)

        return l1
# ---------------------препод--через словарь---------------------------------


class Postman:
    def __init__(self):
        self.delivery_data = []

    def add_delivery(self, street, house, apartment):
        self.delivery_data.append((street, house, apartment))

    def get_houses_for_street(self, street):
        return list({h: None for s, h, _ in self.delivery_data if s == street})

    def get_flats_for_house(self, street, house):
        return list({a: None for s, h, a in self.delivery_data if s == street and h == house})
# ---------------------------------------------------------------


#  Класс Wordplay
# 850
# Будем называть словом любую последовательность из одной или более латинских букв.
# Реализуйте класс Wordplay, описывающий расширяемый набор слов. При создании экземпляра класс должен принимать один аргумент:
#     words — список, определяющий начальный набор слов. Если не передан, начальный набор слов считается пустым
# Экземпляр класса Wordplay должен иметь один атрибут:
#     words — список, содержащий набор слов
# Класс Wordplay должен иметь четыре метода экземпляра:
#     add_word() — метод, принимающий в качестве аргумента слово и добавляющий его в набор. Если слово уже есть в наборе, метод ничего не должен делать
#     words_with_length() — метод, принимающий в качестве аргумента натуральное число n и возвращающий список слов из набора, длина которых равна n
#     only() — метод, принимающий произвольное количество аргументов — букв, и возвращающий все слова из набора, которые включают в себя только переданные буквы
#     avoid() — метод, принимающий произвольное количество аргументов — букв, и возвращающий все слова из списка words, которые не содержат ни одну из этих букв
# Примечание 1. Слова в списках, возвращаемых методами words_with_length(), only() и avoid(), должны располагаться в том порядке, в котором они были добавлены.
# Примечание 2. Экземпляр класса Wordplay не должен зависеть от списка, на основе которого он был создан. Другими словами, если исходный список изменится, то экземпляр класса Wordplay измениться не должен.
# ---------------------------------------------------------------


class Wordplay:
    def __init__(self, words=None) -> None:
        if words is None:
            words = []
        words2 = copy.copy(words)
        self.words = words2

    def add_word(self, new_word):
        if new_word not in self.words:
            self.words.append(new_word)

    def words_with_length(self, n):
        return [word for word in self.words if len(word) == n]

    def only(self, *args):
        return [word for word in self.words if set(args) >= set(word)]

    def avoid(self, *args):
        return [word for word in self.words if set(args).isdisjoint(set(word))]


words = ['Лейбниц', 'Бэббидж', 'Нейман', 'Джобс', 'да_Винчи', 'Касперский']
wordplay = Wordplay(words)

words.extend(['Гуев', 'Харисов', 'Светкин'])
print(words)
print(wordplay.words)

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Knight ♞
#
# Реализуйте класс Knight, описывающий шахматного коня. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     horizontal — координата коня по горизонтальной оси, представленная латинской буквой от a до h
#     vertical — координата коня по вертикальной оси, представленная целым числом от 1 до 8 включительно
#     color — цвет коня (black или white)
# Экземпляр класса Knight должен иметь три атрибута:
#     horizontal — координата коня на шахматной доске по горизонтальной оси
#     vertical — координата коня на шахматной доске по вертикальной оси
#     color — цвет коня
# Класс Knight должен иметь четыре метода экземпляра:
#     get_char() — метод, возвращающий символ N
#     can_move() — метод, принимающий в качестве аргументов координаты клетки по горизонтальной и по вертикальной осям и возвращающий True, если конь может переместиться на клетку с данными координатами, или False в противном случае
#     move_to() — метод, принимающий в качестве аргументов координаты клетки по горизонтальной и по вертикальной осям и заменяющий текущие координаты коня на переданные. Если конь из текущей клетки не может переместиться на клетку с указанными координатами, его координаты должны остаться неизменными
#     draw_board() — метод, печатающий шахматное поле, отмечающий на этом поле коня и клетки, на которые может переместиться конь. Пустые клетки должны быть отображены символом ., конь — символом N, клетки, на которые может переместиться конь, — символом *
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Circle
#
# Реализуйте класс Circle, описывающий круг. При создании экземпляра класс должен принимать один аргумент:

#     radius — радиус круга

# Экземпляр класса Circle должен иметь три атрибута:

#     _radius — радиус круга
#     _diameter — диаметр круга
#     _area — площадь круга

# Класс Circle должен иметь три метода экземпляра:

#     get_radius() — метод, возвращающий радиус круга
#     get_diameter() — метод, возвращающий диаметр круга
#     get_area() — метод, возвращающий площадь круга

# Примечание 1. Площадь круга вычисляется по формуле πr2πr2, где rr — радиус круга, ππ — константа, которая выражает отношение длины окружности к ее диаметру.

# Примечание 2. Импортировать константу ππ можно из модуля math:

# ---------------------------------------------------------------


class Circle:
    def __init__(self, radius: int) -> None:
        self._radius = radius
        self._diameter = 2 * radius
        self._area = math.pi * radius**2

    def get_radius(self) -> int:
        """метод, возвращающий радиус круга"""
        return self._radius

    def get_diameter(self) -> int:
        """метод, возвращающий диаметр круга"""
        return self._diameter

    def get_area(self) -> int:
        """метод, возвращающий площадь круга"""
        return self._area
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс BankAccount
# 949
# Реализуйте класс BankAccount, описывающий банковский счет. При создании экземпляра класс должен принимать один аргумент:
#     balance — баланс счета, по умолчанию имеет значение 0
# Экземпляр класса BankAccount должен иметь один атрибут:
#     _balance — баланс счета
# Класс BankAccount должен иметь четыре метода экземпляра:
#     get_balance() — метод, возвращающий актуальный баланс счета
#     deposit() — метод, принимающий в качестве аргумента число amount и увеличивающий баланс счета на amount
#     withdraw() — метод, принимающий в качестве аргумента число amount и уменьшающий баланс счета на amount. Если amount превышает количество средств на балансе счета, должно быть возбуждено исключение ValueError с сообщением:
#     На счете недостаточно средств
#     transfer() — метод, принимающий в качестве аргументов банковский счет account и число amount. Метод должен уменьшать баланс текущего счета на amount и увеличивать баланс счета account на amount. Если amount превышает количество средств на балансе текущего счета, должно быть возбуждено исключение ValueError с сообщением:
#     На счете недостаточно средств
# Примечание 1. Числами будем считать экземпляры классов int и float.
# Примечание 2. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------

# from typing import Self

# class BankAccount:
#     def __init__(self, balance=0: int | float) -> None:
#         self._balance = balance

#     def get_balance(self) -> int | float:
#         """метод, возвращающий актуальный баланс счета"""
#         return self._balance

#     def deposit(self, amount: int | float):
#         """метод, принимающий в качестве аргумента число amount и увеличивающий баланс счета на amount"""
#         self._balance += amount

#     def withdraw(self, amount: int | float):
#         """метод, принимающий в качестве аргумента число amount и уменьшающий баланс счета на amount. Если amount превышает количество средств на балансе счета, должно быть возбуждено исключение ValueError с сообщением: На счете недостаточно средств"""
#         if self._balance > amount:
#             self._balance -= amount
#         else:
#             print('На счете недостаточно средств')
#             raise ValueError

#     # def transfer(self: Self, account: Self, amount: int) -> None:
#     def transfer(self: 'BankAccount', account: 'BankAccount', amount: int) -> None:
#         """метод, принимающий в качестве аргументов банковский счет account и число amount. Метод должен уменьшать баланс текущего счета на amount и увеличивать баланс счета account на amount. Если amount превышает количество средств на балансе текущего счета, должно быть возбуждено исключение ValueError с сообщением: """
#         self.withdraw(amount)
#         self.account = account
#         self.account.deposit(amount)


# account1 = BankAccount(100)
# account2 = BankAccount(200)

# account1.transfer(account2, 50)
# print(account1.get_balance())
# print(account2.get_balance())
# ---------------------------------------------------------------
    # def transfer(self: 'BankAccount', account: 'BankAccount', amount: int) -> None:
    #     """метод, принимающий в качестве аргументов банковский счет account и число amount. Метод должен уменьшать баланс текущего счета на amount и увеличивать баланс счета account на amount. Если amount превышает количество средств на балансе текущего счета, должно быть возбуждено исключение ValueError с сообщением: """
    #     self.withdraw(amount)
    #     self.account = account
    #     self.account.deposit(amount)
# ---------------------------------------------------------------


# Класс User
# 937
# Реализуйте класс User, описывающий интернет-пользователя. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     name — имя пользователя. Если name не является непустой строкой, состоящей только из букв, должно быть возбуждено исключение ValueError с текстом:
#     Некорректное имя
#     age — возраст пользователя. Если age не является целым числом, принадлежащим отрезку [0; 110], должно быть возбуждено исключение ValueError с текстом:
#     Некорректный возраст
# Экземпляр класса User должен иметь два атрибута:
#     _name — имя пользователя
#     _age — возраст пользователя
# Класс User должен иметь четыре метода экземпляра:
#     get_name() — метод, возвращающий имя пользователя
#     set_name() — метод, принимающий в качестве аргумента значение new_name и изменяющий имя пользователя на new_name. Если new_name не является непустой строкой, состоящей только из букв, должно быть возбуждено исключение ValueError с текстом:
#     Некорректное имя
#     get_age() — метод, возвращающий возраст пользователя
#     set_age() — метод, принимающий в качестве аргумента значение new_age и изменяющий возраст пользователя на new_age. Если new_age не является целым числом, принадлежащим отрезку [0; 110], должно быть возбуждено исключение ValueError с текстом:
#     Некорректный возраст
# Примечание 1. Если при создании экземпляра класса User имя и возраст одновременно являются некорректными, должно быть возбуждено исключение, связанное с именем.
# ---------------------------------------------------------------
class User:
    def __init__(self, name: str, age: int) -> None:

        # класс — это единая сущность, внутри можно обращаться к любому методу, даже тому, который определён позже.
        self.set_name(name)
        self.set_age(age)

        self._name = name
        self._age = age

    def get_name(self):
        """метод, возвращающий имя пользователя"""
        return self._name

    def get_age(self):
        """метод, возвращающий возраст пользователя"""
        return self._age

    # Сеттер1

    def set_name(self, new_name: str):
        """метод, принимающий в качестве аргумента значение new_name и изменяющий имя пользователя на new_name. Если new_name не является непустой строкой, состоящей только из букв, должно быть возбуждено исключение ValueError с текстом: """
        if isinstance(new_name, str) and new_name.isalpha():
            self._name = new_name
        else:
            raise ValueError('Некорректное имя')

    # Сеттер2
    def set_age(self, new_age: int):
        """метод, принимающий в качестве аргумента значение new_age и изменяющий возраст пользователя на new_age. Если new_age не является целым числом, принадлежащим отрезку [0; 110], должно быть возбуждено исключение ValueError с текстом: """
        if isinstance(new_age, int) and 0 <= new_age <= 110:
            self._age = new_age
        else:
            raise ValueError('Некорректный возраст')
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Rectangle
# 949
# Реализуйте класс Rectangle, описывающий прямоугольник. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     length — длина прямоугольника
#     width — ширина прямоугольника
# Экземпляр класса Rectangle должен иметь два атрибута:
#     length — длина прямоугольника
#     width — ширина прямоугольника
# Класс Rectangle должен иметь два свойства:
#     perimeter — свойство, доступное только для чтения, возвращающее периметр прямоугольника
#     area — свойство, доступное только для чтения, возвращающее площадь прямоугольника
# Примечание 1. При изменении сторон прямоугольника должны изменяться его периметр и площадь.
# ---------------------------------------------------------------
class Rectangle:
    def __init__(self, length, width):
        self._length = length
        self._width = width

    # --------------------------------------------------------
    def get_length(self):
        """геттер - возвращает значение длины"""
        return self._length

    def set_length(self, length):
        """сеттер - меняет значение длины"""
        self._length = length

    # --------------------------------------------------------
    def get_width(self):
        """геттер -  возвращает значение ширины"""
        return self._width

    def set_width(self, width):
        """сеттер - меняет значение ширины"""
        self._width = width

    # --------------------------------------------------------
    def get_perimeter(self):
        """геттер - возвращает значение периметра"""
        return 2 * (self._length + self._width)

    # --------------------------------------------------------
    def get_area(self):
        """геттер -  возвращает значение площади"""
        return self._length * self._width
    # --------------------------------------------------------

    length = property(get_length, set_length)
    width = property(get_width, set_width)
    perimeter = property(get_perimeter)
    area = property(get_area)


rectangle = Rectangle(4, 5)

print(rectangle.length)
print(rectangle.width)
print(rectangle.perimeter)
print(rectangle.area)

# ---------------------------------------------------------------


class Rectangle:
    def __init__(self, length, width):
        self.length = length
        self.width = width

    def get_perimeter(self):
        return 2*(self.length + self.width)

    def get_area(self):
        return self.length * self.width

    perimeter = property(get_perimeter)
    area = property(get_area)
# ---------------------------------------------------------------


# Класс HourClock
# 958
# Реализуйте класс HourClock, описывающий часы с одной лишь часовой стрелкой. При создании экземпляра класс должен принимать один аргумент:
#     hours — количество часов. Если hours не является целым числом, принадлежащим диапазону [1; 12], должно быть возбуждено исключение ValueError с текстом:
#     Некорректное время
# Класс HourClock должен иметь одно свойство:
#     hours — свойство, доступное для чтения и записи, возвращающее текущее количество часов. При изменении свойство должно проверять, что новое значение является целым числом, принадлежащим диапазону [1; 12], в противном случае должно быть возбуждено исключение ValueError с текстом:
#     Некорректное время
# Примечание 1. Никаких ограничений касательно реализации класса HourClock нет, она может быть произвольной.
# ---------------------------------------------------------------
class HourClock:
    def __init__(self, hours: int) -> None:

        # класс — это единая сущность, внутри можно обращаться к любому методу, даже тому, который определён позже.
        self.set_hours(hours)

    def get_hours(self) -> int:
        """геттер возвращает текущее количество часов"""

        return self._hours

    def set_hours(self, hours: int) -> None:
        """cеттер изменяет и проверяет на корректность новое количество часов"""

        if not (isinstance(hours, int) and 1 <= hours <= 12):
            raise ValueError('Некорректное время')
        self._hours = hours

    hours = property(get_hours, set_hours)


time = HourClock(7)

print(time.hours)
time.hours = 9
print(time.hours)

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Person
# 962
# Реализуйте класс Person, описывающий человека. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     name — имя человека
#     surname — фамилия человека
# Экземпляр класса Person должен иметь два атрибута:
#     name — имя человека
#     surname — фамилия человека
# Класс Person должен иметь одно свойство:
#     fullname — свойство, доступное для чтения и записи, возвращающее полное имя человека в виде строки:
#     <имя> <фамилия>
# Примечание 1. При изменении имени и/или фамилии человека должно изменяться и его полное имя. Аналогично при изменении полного имени должны изменяться имя и фамилия.
# ---------------------------------------------------------------
class Person:
    def __init__(self, name, surname) -> None:
        self.set_person(name, surname)

    def get_name(self) -> str:
        """геттер возвращает имя"""
        return self._name

    def get_surname(self) -> str:
        """геттер возвращает фамилию"""
        return self._surname

    def set_name(self, name) -> None:
        """сеттер изменяет имя"""
        self._name = name

    def set_surname(self, surname: str) -> None:
        """сеттер изменяет фамилию"""
        self._surname = surname

    def get_person(self) -> str:
        """возвращающее полное имя человека в виде строки"""
        return f"{self.get_name()} {self.get_surname()}"

    def set_person(self, *args: str) -> None:
        if len(args) == 1:
            l1 = args[0].split()
            self._name = l1[0]
            self._surname = l1[1]
        else:
            self._name, self._surname = args

    name = property(get_name, set_name)
    surname = property(get_surname, set_surname)
    fullname = property(get_person, set_person)


person = Person('Джон', 'Маккарти')

person.fullname = 'Алан Тьюринг'
print(person.name)
print(person.surname)

# -----------короче---------------------------------------


class Person:
    def __init__(self, name, surname):
        self.name = name
        self.surname = surname

    def get_fullname(self):
        return self.name + ' ' + self.surname

    def set_fullname(self, fullname):
        self.name, self.surname = fullname.split()

    fullname = property(get_fullname, set_fullname)
# ---------------------------------------------------------------


#  Person
#
# Вам доступен класс Person, описывающий человека. При создании экземпляра класс принимает два аргумента в следующем порядке:
#     name — имя человека
#     surname — фамилия человека
# Экземпляр класса Person имеет два атрибута:
#     name — имя человека
#     surname — фамилия человека
# Класс Person имеет одно свойство:
#     fullname — свойство, доступное для чтения и записи, возвращающее полное имя человека в виде строки:
#     <имя> <фамилия>
# Реализуйте свойство fullname класса Person с помощью декоратора @property.
# Примечание 1. При изменении имени и/или фамилии человека должно изменяться и его полное имя. Аналогично при изменении полного имени должны изменяться имя и фамилия.
# ---------------------------------------------------------------
class Person:
    def __init__(self, name, surname) -> None:
        self._name = name
        self._surname = surname

    @property
    def fullname(self):
        return "{} {}".format(self.name, self.surname)

    @fullname.setter
    def fullname(self, fullname):
        self.name, self.surname = fullname.split()

# БЕЗ ДЕКОРАТОРА


class Person:
    def __init__(self, name, surname):
        self.name = name
        self.surname = surname

    def get_fullname(self):
        return self.name + ' ' + self.surname

    def set_fullname(self, fullname):
        self.name, self.surname = fullname.split()

    fullname = property(get_fullname, set_fullname)


# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Account
# 956
# В целях безопасности в базах данных пароли от аккаунтов пользователей хранятся не в явном виде, а в виде хеш-значений — чисел, вычисленных по специальному алгоритму на основе паролей.
# Вам доступна функция hash_function(), которая принимает в качестве аргумента пароль и возвращает его хеш-значение.
# Реализуйте класс Account, описывающий аккаунт интернет-пользователя на некотором сервисе. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     login — логин пользователя
#     password — пароль пользователя
# Класс Account должен иметь два свойства:
#     login — свойство, доступное только для чтения, возвращающее логин пользователя. При попытке изменения свойства должно быть возбуждено исключение AttributeError с текстом:
#     Изменение логина невозможно
#     password — свойство, доступное для чтения и записи, возвращающее хеш-значение пароля от аккаунта пользователя. При изменении свойство должно вычислять хеш-значение нового пароля и сохранять его, а не сам пароль
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 2. Никаких ограничений касательно реализации класса Account нет, она может быть произвольной.
# ---------------------------------------------------------------


class Account:
    def __init__(self, login, password) -> None:
        self._login = login
        self._password = hash_function(password)

    # ---------------------------------------------------------------

    @property
    def login(self):        # свойство доступно только для чтения (сеттер выдаст ошибку при попытке изменить логин)
        return self._login

    @login.setter
    def login(self, login):
        raise AttributeError('Изменение логина невозможно')
    # ---------------------------------------------------------------

    @property
    def password(self):        # свойство доступно для чтения и записи
        return self._password

    @password.setter
    def password(self, password):
        self._password = hash_function(password)


def hash_function(password):
    """ф-я принимает в качестве аргумента пароль и возвращает его хеш-значение."""
    hash_value = 0
    for char, index in zip(password, range(len(password))):
        hash_value += ord(char) * index
    return hash_value % 10**9


account = Account('timyr-guev', 'lovebeegeek')

print(account.password)
account.password = 'verylovebeegeek'
print(account.password)

# ------------------препод-------------------------------------


def hash_function(password):
    hash_value = 0
    for char, index in zip(password, range(len(password))):
        hash_value += ord(char) * index
    return hash_value % 10 ** 9


class Account:
    def __init__(self, login, password):
        self._login = login
        self.password = password

    @property
    def login(self):
        return self._login

    @login.setter
    def login(self, login):
        raise AttributeError('Изменение логина невозможно')

    @property
    def password(self):
        return self._password

    @password.setter
    def password(self, password):
        self._password = hash_function(password)
# ---------------------------------------------------------------


# Класс QuadraticPolynomial
# 956
# В целях безопасности в базах данных пароли от аккаунтов пользователей хранятся не в явном виде, а в виде хеш-значений — чисел, вычисленных по специальному алгоритму на основе паролей.
# Вам доступна функция hash_function(), которая принимает в качестве аргумента пароль и возвращает его хеш-значение.
# Реализуйте класс Account, описывающий аккаунт интернет-пользователя на некотором сервисе. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     login — логин пользователя
#     password — пароль пользователя
# Класс Account должен иметь два свойства:
#     login — свойство, доступное только для чтения, возвращающее логин пользователя. При попытке изменения свойства должно быть возбуждено исключение AttributeError с текстом:
#     Изменение логина невозможно
#     password — свойство, доступное для чтения и записи, возвращающее хеш-значение пароля от аккаунта пользователя. При изменении свойство должно вычислять хеш-значение нового пароля и сохранять его, а не сам пароль
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------


# from typing import Tuple

class QuadraticPolynomial:
    def __init__(self, a: int | float, b: int | float, c: int | float) -> None:
        self.a = a
        self.b = b
        self.c = c

    @property
    def x1(self) -> float | None:
        """ свойство, доступное только для чтения, возвращающее корень1 квадратного трехчлена,"""
        descriminant = self.b**2 - 4 * self.a * self.c
        if descriminant >= 0:
            return (-self.b - descriminant**0.5) / (2 * self.a)

    @property
    def x2(self) -> float | None:
        """ свойство, доступное только для чтения, возвращающее корень2 квадратного трехчлена"""
        descriminant = self.b**2 - 4 * self.a * self.c
        if descriminant >= 0:
            return (-self.b + descriminant**0.5) / (2 * self.a)

    @property
    def view(self) -> str:
        """ свойство, доступное только для чтения, возвращающее строку вида ax^2 + bx + c"""
        signs = ''
        for i in self.coefficients:
            if i >= 0:
                signs += '+'
            else:
                signs += '-'
        signs = signs[1:]

        res = '{a}x^2 {} {b}x {} {c}'.format(
            *signs, a=self.a, b=abs(self.b), c=abs(self.c))
        return res

    @property
    def coefficients(self) -> Tuple[int | float]:
        """геттер, доступ для чтения, возвращающее кортеж вида: (a, b, c)"""
        return (self.a, self.b, self.c)

    @coefficients.setter
    def coefficients(self, coefficients1) -> Tuple[int | float]:
        """сеттер изменяющий коэффициенты"""
        self.a, self.b, self.c = coefficients1


polynom = QuadraticPolynomial(1, 2, -3)

polynom.coefficients = (1, -5, 6)
print(polynom.x1)
print(polynom.x2)
print(polynom.view)
# -----------------препод---------------------------------------


class QuadraticPolynomial:
    def __init__(self, a, b, c):
        self.a, self.b, self.c = a, b, c

    @property
    def d(self):
        return self.b ** 2 - 4 * self.a * self.c

    @property
    def x1(self):
        # короткая запись if else
        return (-self.b - self.d ** 0.5) / (2 * self.a) if self.d >= 0 else None

    @property
    def x2(self):
        return (-self.b + self.d ** 0.5) / (2 * self.a) if self.d >= 0 else None

    @property
    def view(self):
        b, sign_b = abs(self.b), '-' if self.b < 0 else '+'
        c, sign_c = abs(self.c), '-' if self.c < 0 else '+'
        return f'{self.a}x^2 {sign_b} {b}x {sign_c} {c}'

    @property
    def coefficients(self):
        return self.a, self.b, self.c

    @coefficients.setter
    def coefficients(self, coeff):
        a, b, c = coeff
        self.a, self.b, self.c = a, b, c
# ---------------------------------------------------------------


# Класс Color
# 873
# Для кодирования цвета часто используется шестнадцатеричное значение цвета. Оно записывается в формате #RRGGBB, где RR (красный), GG (зеленый) и BB (синий) являются шестнадцатеричными целыми числами в диапазоне [00; FF] (или [0; 255] в десятичной системе счисления), которые указывают интенсивность соответствующих цветов. Например, #0000FF представляет чистый синий цвет, так как синий компонент имеет наивысшее значение (FF), а остальные — 00.
# Реализуйте класс Color, описывающий цвет. При создании экземпляра класс должен принимать один аргумент:
#     hexcode — шестнадцатеричное значение цвета
# Экземпляр класса Color должен иметь три атрибута:
#     r — интенсивность красного компонента цвета в виде десятичного числа
#     g — интенсивность зеленого компонента цвета в виде десятичного числа
#     b — интенсивность синего компонента цвета в виде десятичного числа
# Класс Color должен иметь одно свойство:
#     hexcode — свойство, доступное для чтения и записи, возвращающее шестнадцатеричное значение цвета
# Примечание 1. При изменении шестнадцатеричного значения цвета значения атрибутов r, g и b также должны изменяться.
# Примечание 2. Гарантируется, что для записи шестнадцатеричных чисел используются только заглавные латинские буквы.
# ---------------------------------------------------------------


class Color:
    def __init__(self, hexcode: str) -> None:
        self._hexcode = hexcode
        self.r = hex_to_ten(self._hexcode[:2])
        self.g = hex_to_ten(self._hexcode[2:4])
        self.b = hex_to_ten(self._hexcode[4:])

    # ---------------------------------------------------------------
    @property
    def hexcode(self) -> str:
        """геттер, возвращает шестнадцатеричное значение цвета"""
        return self._hexcode

    @hexcode.setter
    def hexcode(self, hexcode: str) -> None:
        """сеттер, для изменения цвета"""
        self._hexcode = hexcode
        self.r = hex_to_ten(hexcode[:2])
        self.g = hex_to_ten(hexcode[2:4])
        self.b = hex_to_ten(hexcode[4:])
    # ---------------------------------------------------------------


# оказывается :) функция int переводит число из десятичного в шестнадцатиричное, переводит число из десятичного в двоичное или другое
def hex_to_ten(hex_num: str) -> int:
    """ф-я принимает шестнадцатеричное значение цвета и возвращает цвет в виде десятичного числа"""
    dict_hex = {'0': 0,
                '1': 1,
                '2': 2,
                '3': 3,
                '4': 4,
                '5': 5,
                '6': 6,
                '7': 7,
                '8': 8,
                '9': 9,
                "A": 10,
                "B": 11,
                "C": 12,
                "D": 13,
                "E": 14,
                "F": 15}

    return sum((dict_hex[num_hex]) * 16**pow_index for pow_index, num_hex in enumerate(reversed(hex_num)))


color = Color('0000FF')

color.hexcode = 'A782E3'
print(color.hexcode)
print(color.r)
print(color.g)
print(color.b)
# -----------------препод--------------------------------------


class Color:
    def __init__(self, hexcode):
        self.hexcode = hexcode

    @property
    def hexcode(self):
        return self._hexcode

    @hexcode.setter
    def hexcode(self, hexcode):
        self._hexcode = hexcode

        # функция int переводит число из десятичного в шестнадцатиричное, переводит число из десятичного в двоичное или другое
        self.r = int(hexcode[0:2], 16)
        self.g = int(hexcode[2:4], 16)
        self.b = int(hexcode[4:6], 16)
# ---------------------------------------------------------------


# Класс Circle
# 950
# Реализуйте класс Circle, описывающий круг. При создании экземпляра класс должен принимать один аргумент:
#     radius — радиус круга
# Экземпляр класса Circle должен иметь один атрибут:
#     radius — радиус круга
# Класс Circle должен иметь один метод класса:
#     from_diameter() — метод, принимающий в качестве аргумента диаметр круга и возвращающий экземпляр класса Circle, созданный на основе переданного диаметра
# ---------------------------------------------------------------
class Circle:
    def __init__(self, radius: int | float) -> None:
        self.radius = radius

    @classmethod
    def from_diameter(cls, diametr: int | float) -> int | float:
        """метод класса, принимающий в качестве аргумента диаметр круга и возвращающий экземпляр класса Circle, созданный на основе переданного диаметра"""

        return cls(diametr / 2)


circle = Circle.from_diameter(10)
print(circle.radius)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Rectangle
# 965
# Реализуйте класс Rectangle, описывающий прямоугольник. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     length — длина прямоугольника
#     width — ширина прямоугольника
# Экземпляр класса Rectangle должен иметь два атрибута:
#     length — длина прямоугольника
#     width — ширина прямоугольника
# Класс Rectangle должен иметь один метод класса:
#     square() — метод, принимающий в качестве аргумента число side и возвращающий экземпляр класса Rectangle c длиной и шириной, равными side
# ---------------------------------------------------------------
class Rectangle:
    def __init__(self, length: int | float, width: int | float) -> None:
        self.length = length
        self.width = width

    @classmethod
    def square(cls, side: int | float) -> 'Rectangle':
        """ метод класса, принимающий в качестве аргумента число side и возвращающий экземпляр класса """
        return cls(side, side)


rectangle = Rectangle.square(5)

print(rectangle.length)
print(rectangle.width)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс QuadraticPolynomial
# 916
# вадратный трехчлен — это многочлен вида ax2+bx+cax2+bx+c, где a≠0a=0. Например:
# x2+1x2−5x+6Реализуйте класс QuadraticPolynomial, описывающий квадратный трехчлен. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     a — коэффициент aa квадратного трехчлена
#     b — коэффициент bb квадратного трехчлена
#     c — коэффициент cc квадратного трехчлена
# Экземпляр класса QuadraticPolynomial должен иметь три атрибута:
#     a — коэффициент aa квадратного трехчлена
#     b — коэффициент bb квадратного трехчлена
#     c — коэффициент cc квадратного трехчлена
# Класс QuadraticPolynomial должен иметь два метода класса:
#     from_iterable() — метод, принимающий в качестве аргумента итерируемый объект из трех элементов a, b и c, которые представляют коэффициенты квадратного трехчлена, и возвращающий экземпляр класса QuadraticPolynomial, созданный на основе переданных коэффициентов
#     from_str() — метод, принимающий в качестве аргумента строку, которая содержит коэффициенты a, b и c квадратного трехчлена, записанные через пробел. Метод должен возвращать экземпляр класса QuadraticPolynomial, созданный на основе переданных коэффициентов, предварительно преобразованных в экземпляры класса float
# ---------------------------------------------------------------

# from typing import TypeVar

# TMyClass = TypeVar("TMyClass", bound="MyClass")

class QuadraticPolynomial:
    def __init__(self, a: int | float, b: int | float, c: int | float) -> None:
        self.a = a
        self.b = b
        self.c = c

    @classmethod
    def from_iterable(cls, iterable) -> 'QuadraticPolynomial':
        """метод класса, принимающий в качестве аргумента итерируемый объект из трех элементов a, b и c, которые представляют коэффициенты квадратного трехчлена, и возвращающий экземпляр класса QuadraticPolynomial, созданный на основе переданных коэффициентов"""
        return cls(*iterable)

    @classmethod
    def from_str(cls, string) -> 'QuadraticPolynomial':
        """метод класса, принимающий в качестве аргумента итерируемый объект из трех элементов a, b и c, которые представляют коэффициенты квадратного трехчлена, и возвращающий экземпляр класса QuadraticPolynomial, созданный на основе переданных коэффициентов"""
        iterable = map(float, string.split())
        return cls(iterable)
# ---------------------------------------------------------------


# Класс Pet
# 926
# Реализуйте класс Pet, описывающий домашнее животное. При создании экземпляра класс должен принимать один аргумент:
#     name — имя домашнего животного
# Экземпляр класса Pet должен иметь один атрибут:
#     name — имя домашнего животного
# Класс Pet должен иметь три метода класса:
#     first_pet() — метод, возвращающий самый первый созданный экземпляр класса Pet. Если ни одного экземпляра еще не было создано, метод должен вернуть значение None
#     last_pet() — метод, возвращающий самый последний созданный экземпляр класса Pet. Если ни одного экземпляра еще не было создано, метод должен вернуть значение None
#     num_of_pets() — метод, возвращающий количество созданных экземпляров класса Pet
# ---------------------------------------------------------------
class Pet:

    pets = []

    def __init__(self, name):
        self.name = name
        Pet.pets.append(self)   # передаём весь экземпляр

    @classmethod
    def first_pet(cls):  # в методах класса нужно брать его из списка
        if cls.pets:
            return cls.pets[0]

    @classmethod
    def last_pet(cls):
        if cls.pets:
            return cls.pets[-1]

    @classmethod
    def num_of_pets(cls):
        return len(cls.pets)

# ----------------------------------------


class Pet:
    pets = []

    def __init__(self, name):
        self.name = name
        Pet.pets.append(self)

    @classmethod
    def first_pet(cls):
        return cls.pets[0] if cls.pets else None

    @classmethod
    def last_pet(cls):
        return cls.pets[-1] if cls.pets else None

    @classmethod
    def num_of_pets(cls):
        return len(cls.pets)
# ---------------------------------------------------------------


# Класс StrExtension
#
# Реализуйте класс StrExtension, описывающий набор функций для работы со строками. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс StrExtension должен иметь три статических метода:
#     remove_vowels() — метод, который принимает в качестве аргумента строку, удаляет из нее все гласные латинские буквы без учета регистра и возвращает полученный результат
#     leave_alpha() — метод, который принимает в качестве аргумента строку, удаляет из нее все символы, не являющиеся латинскими буквами, и возвращает полученный результат
#     replace_all() — метод, который принимает три строковых аргумента string, chars и char, заменяет в строке string все символы из chars на char с учетом регистра и возвращает полученный результат.
# Примечание 1. Гарантируется, что все буквенные символы относятся к латинскому алфавиту.
# Примечание 2. Латинские гласные буквы: a, e, i, o, u, y.
# ---------------------------------------------------------------


class StrExtension:

    @staticmethod
    def remove_vowels(string1):
        vowels = ('a', 'e', 'i', 'o', 'u', 'y')
        str_off_vowels = (
            char for char in string1 if char.lower() not in vowels)
        return ''.join(str_off_vowels)

    @staticmethod
    def leave_alpha(string1):
        symbols = (char for char in string1 if char.lower()
                   not in string.ascii_lowercase)
        return ''.join(symbols)

    @staticmethod
    def replace_all(string1: str, chars, char):

        for char_old in chars:
            string1 = string1.replace(char_old, char)

        return string1


# -----------------c регулярками-------------------------------


class StrExtension:
    __VOWELS = re.compile(r'[aeiouy]', flags=re.I)
    __ALPHABET = re.compile(r'[^a-zA-Z]')

    @staticmethod
    def remove_vowels(string):
        return StrExtension.__VOWELS.sub('', string)

    @staticmethod
    def leave_alpha(string):
        return StrExtension.__ALPHABET.sub('', string)

    @staticmethod
    def replace_all(string, chars, char):
        return re.sub(fr'[{chars}]', char, string)
# ---------------------------------------------------------------


# Класс CaseHelper 🌶️
# 783
# Snake Case — стиль написания составных слов, при котором несколько слов разделяются символом нижнего подчеркивания (_) и не имеют пробелов в записи, причём каждое слово пишется с маленькой буквы. Например, bee_geek и hello_world.
# Upper Camel Case — стиль написания составных слов, при котором несколько слов пишутся слитно без пробелов, при этом каждое слово пишется с заглавной буквы. Например, BeeGeek и HelloWorld.
# Реализуйте класс CaseHelper, описывающий набор функций для работы со строками в стилях Snake Case и Upper Camel Case. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс CaseHelper должен иметь четыре статических метода:
#     is_snake() — метод, принимающий в качестве аргумента строку и возвращающий True, если переданная строка записана в стиле Snake Case, или False в противном случае
#     is_upper_camel() — метод, принимающий в качестве аргумента строку и возвращающий True, если переданная строка записана в стиле Upper Camel Case, или False в противном случае
#     to_snake() — метод, который принимает в качестве аргумента строку в стиле Upper Camel Case, записывает ее в стиле Snake Case и возвращает полученный результат
#     to_upper_camel() — метод, который принимает в качестве аргумента строку в стиле Snake Case, записывает ее в стиле Upper Camel Case и возвращает полученный результат
# ---------------------------------------------------------------

# class CaseHelper:


# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Processor
# 937
# Вам доступен класс Processor. При создании экземпляра класс не принимает никаких аргументов.
# Класс Processor имеет один статический метод:
#     process() — метод, который принимает в качестве аргумента произвольный объект, преобразует его в зависимости от его типа и возвращает полученный результат. Если тип переданного объекта не поддерживается методом, возбуждается исключение TypeError с текстом:
#     Аргумент переданного типа не поддерживается
# Перепишите метод process() класса Processor с использованием декоратора @singledispatchmethod, чтобы он выполнял ту же задачу.
# Примечание 1. Примеры преобразования объектов всех поддерживаемых типов показаны в методе process() класса Processor.
# # ---------------------------------------------------------------
# class Processor:
#     @staticmethod
#     def process(data):
#         if isinstance(data, (int, float)):
#             return data * 2
#         elif isinstance(data, str):
#             return data.upper()
#         elif isinstance(data, list):
#             return sorted(data)
#         elif isinstance(data, tuple):
#             return tuple(sorted(data))
#         raise TypeError('Аргумент переданного типа не поддерживается')
# ---------------------------------------------------------------


class Processor:
    @singledispatchmethod
    @staticmethod
    def process(data):
        raise TypeError('Аргумент переданного типа не поддерживается')

    @process.register(tuple)
    @staticmethod
    def _tuple_process(data):
        return tuple(sorted(data))

    @process.register(list)
    @staticmethod
    def _list_process(data):
        return sorted(data)

    @process.register(str)
    @staticmethod
    def _str_process(data):
        return data.upper()

    @process.register(int)
    # @process.register(int | float)    # В Python 3.11 можно так
    @process.register(float)
    @staticmethod
    def _numeric_process(data):
        return data * 2
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Negator
# 953
# Реализуйте класс Negator. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Negator должен иметь один статический метод:
#     neg() — метод, принимающий в качестве аргумента объект и возвращающий его противоположное значение. Если методу передается целое или вещественное число, он должен возвращать это число, взятое с противоположным знаком. Если методу в качестве аргумента передается булево значение, он должен возвращать булево значение, противоположное переданному. Если переданный объект принадлежит какому-либо другому типу, должно быть возбуждено исключение TypeError с текстом:
#     Аргумент переданного типа не поддерживается
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------


class Negator:
    @singledispatchmethod
    @staticmethod
    def neg(object):
        raise TypeError('Аргумент переданного типа не поддерживается')

    @neg.register(int)
    @neg.register(float)
    @staticmethod
    def _str_neg(object):
        return object * (-1)

    @neg.register(bool)
    @staticmethod
    def _str_neg(object):
        return not object
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Formatter
# 917
# Реализуйте класс Formatter. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Formatter должен иметь один статический метод:
#     format() — метод, принимающий в качестве аргумента объект типа int, float, tuple, list или dict и выводящий информацию о переданном объекте в формате, зависящем от его типа. Если переданный объект принадлежит какому-либо другому типу, должно быть возбуждено исключение TypeError с текстом:
#     Аргумент переданного типа не поддерживается
# Примечание 1. Примеры форматирования объектов всех типов показаны в тестовых данных.
# Примечание 2. Обратите внимание, что метод format() должен обрамлять апострофами строковые элементы коллекций.
# ---------------------------------------------------------------


class Formatter:

    @singledispatchmethod
    @staticmethod
    def format(arg):
        raise TypeError('Аргумент переданного типа не поддерживается')

    @format.register(int)
    def _(arg):
        print(f"Целое число: {arg}")

    @format.register(float)
    def _(arg):
        print(f"Вещественное число: {arg}")

    @format.register(tuple)
    def _(arg):
        print("Элементы кортежа: ", end='')
        print(*arg, sep=', ')

    @format.register(list)
    def _(arg):
        # print(f'Элементы списка: {", ".join([str(obj) for obj in data])}')
        print("Элементы списка: ", end='')
        print(*arg, sep=', ')

    @format.register(dict)
    def _(arg):
        # print(f'Пары словаря: {", ".join([str(pair) for pair in data.items()])}')
        print("Пары словаря: ", end='')
        print(*arg.items(), sep=', ')
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс BirthInfo 🌶️
# 782
# Реализуйте класс BirthInfo, описывающий данные о дате рождения. При создании экземпляра класс должен принимать один аргумент:
#     birth_date — дата рождения, представленная в одном из следующих вариантов:
#     экземпляр класса date
#     строка с датой в ISO формате
#     список или кортеж из трех целых чисел: года, месяца и дня
# Если дата рождения является некорректной или представлена в каком-либо другом формате, должно быть возбуждено исключение TypeError с текстом:
# Аргумент переданного типа не поддерживается
# Экземпляр класса BirthInfo должен иметь один атрибут:
#     birth_date — дата рождения в виде экземпляра класса date
# Класс BirthInfo должен иметь одно свойство:
#     age — свойство, доступное только для чтения, возвращающее текущий возраст в годах, то есть количество полных лет, прошедших с даты рождения на сегодняшний день
# Примечание 1. Возраст в годах должен вычисляться так же, как и обычный возраст человека, то есть в день рождения его возраст увеличивается на один год.
# ---------------------------------------------------------------


class BirthInfo:

    @singledispatchmethod
    def __init__(self, birth_date) -> None:
        raise TypeError('Аргумент переданного типа не поддерживается')

    @__init__.register(date)
    def _(self, birth_date):
        self.birth_date = birth_date

    @__init__.register(str)
    def _(self, birth_date):
        # try:
        #     self.birth_date = date.fromisoformat(birth_date)
        # except:
        #     raise TypeError('Аргумент переданного типа не поддерживается')

        if not re.fullmatch(r'\d{4}-\d{2}-\d{2}', birth_date):
            raise TypeError('Аргумент переданного типа не поддерживается')
        self.birth_date = date.fromisoformat(birth_date)

    @__init__.register(list)
    @__init__.register(tuple)
    def _(self, birth_date):
        self.birth_date = date(*birth_date)

    @property
    def age(self):
        age = date.today().year - self.birth_date.year - 1
        age += (date.today().month,
                date.today().day) >= (self.birth_date.month, self.birth_date.day)
        return age
# ---------------------------------------------------------------


relativedelta(date1, date2).years
# ---------------------------------------------------------------


# Класс Config
#
# Реализуйте класс Config, который соответствует шаблону синглтон и описывает конфигурационный объект с фиксированными параметрами. При создании экземпляра класс не должен принимать никаких аргументов.
# При первом вызове класса Config должен создаваться и возвращаться экземпляр этого класса, а при последующих вызовах должен возвращаться экземпляр, созданный при первом вызове.
# Экземпляр класса Config должен иметь четыре атрибута:
#     program_name — атрибут со строковым значением GenerationPy
#     environment — атрибут со строковым значением release
#     loglevel — атрибут со строковым значением verbose
#     version — атрибут со строковым значением 1.0.0
# ---------------------------------------------------------------

class Config:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:                       # при первом вызове создаем объект
            cls._instance = object.__new__(cls)
        return cls._instance

    def __init__(self) -> None:
        self.program_name = 'GenerationPy'
        self.environment = 'release'
        self.loglevel = 'verbose'
        self.version = '1.0.0'


config = Config()

print(config.program_name)
print(config.environment)
print(config.loglevel)
print(config.version)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Book
# 949
# Требовалось реализовать класс Book, описывающий книгу. При создании экземпляра класс должен был принимать три аргумента в следующем порядке:
#     title — название книги
#     author — автор книги
#     year — год выпуска книги
# Предполагалось, что экземпляры класса Book будут иметь следующее формальное строковое представление:
# Book('<название книги>', '<автор книги>', <год выпуска книги>)
# И следующее неформальное строковое представление:
# <название книги> (<автор книги>, <год выпуска книги>)
# Программист торопился и решил задачу неправильно. Исправьте приведенный ниже код и реализуйте класс Book правильно.
# ---------------------------------------------------------------

class Book:
    def __init__(self, title, author, year) -> None:
        self.title = title
        self.author = author
        self.year = year

    def __str__(self):
        return f'{self.title} ({self.author}, {self.year})'

    def __repr__(self) -> str:
        return f"Book('{self.title}', '{self.author}', {self.year})"
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Rectangle
# 972
# Вам доступен класс Rectangle, описывающий прямоугольник. При создании экземпляра класс принимает два аргумента в следующем порядке:
#     length — длина прямоугольника
#     width — ширина прямоугольника
# Реализуйте для экземпляров класса Rectangle следующее формальное и неформальное строковое представление:
# Rectangle(<длина прямоугольника>, <ширина прямоугольника>)
# ---------------------------------------------------------------

class Rectangle:
    def __init__(self, length, width) -> None:
        self.length = length
        self.width = width

    def __repr__(self) -> str:
        return f"Rectangle({self.length}, {self.width})"
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Vector
# 966
# Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата вектора по оси xx
#     y — координата вектора по оси yy
# Экземпляр класса Vector должен иметь следующее формальное строковое представление:
# Vector(<координата x>, <координата y>)
# И следующее неформальное строковое представление:
# Вектор на плоскости с координатами (<координата x>, <координата y>)
# ---------------------------------------------------------------
class Vector:
    def __init__(self, x, y) -> None:
        self.x = x
        self.y = y

    def __repr__(self) -> str:
        return f"Vector({self.x}, {self.y})"

    def __str__(self) -> str:
        return f"Вектор на плоскости с координатами ({self.x}, {self.y})"
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс IPAddress
# 950
# IP-адрес — это уникальный адрес, идентифицирующий устройство в интернете или локальной сети. IP-адреса представляют собой набор из четырех целых чисел, разделенных точками. Например, 192.158.1.38. Каждое число в наборе принадлежит интервалу от 0 до 255. Таким образом, полный диапазон IP-адресации — это адреса от 0.0.0.0 до 255.255.255.255.
# Реализуйте класс IPAddress, описывающий IP-адрес. При создании экземпляра класс должен принимать один аргумент:
#     ipaddress — IP-адрес, представленный в одном из следующих вариантов:
#     строка из четырех целых чисел, разделенных точками
#     список или кортеж из четырех целых чисел
# Экземпляр класса IPAddress должен иметь следующее формальное строковое представление:
# IPAddress('<IP-адрес в виде четырех целых чисел, разделенных точками>')
# И следующее неформальное строковое представление:
# <IP-адрес в виде четырех целых чисел, разделенных точками>
# ---------------------------------------------------------------


class IPAddress:

    @singledispatchmethod
    def __init__(self, ipaddress) -> None:
        self.ipaddress = ipaddress

    @__init__.register(tuple)
    @__init__.register(list)
    def __init__(self, ipaddress) -> None:
        self.ipaddress = ''.join(ipaddress)

    def __repr__(self) -> str:
        return f"IPAddress('{self.ipaddress}')"

    def __str__(self) -> str:
        return f"{self.ipaddress}"

# ----------------if else------------------------------------------


class IPAddress:
    def __init__(self, ipadress):
        if isinstance(ipadress, str):
            self.ipadress = ipadress
        elif isinstance(ipadress, (list, tuple)):
            self.ipadress = '.'.join(map(str, ipadress))

    def __str__(self):
        return self.ipadress

    def __repr__(self):
        return f"{self.__class__.__name__}('{self.ipadress}')"

# -------------------property-------------------------------------


class IPAddress:
    def __init__(self, ipaddress: str | tuple):
        self.ipaddress = ipaddress

    @property
    def ipaddress(self):
        return self._ipaddress

    @ipaddress.setter
    def ipaddress(self, data: str | tuple | list):
        self._ipaddress = data if isinstance(
            data, str) else '.'.join(map(str, data))

    def __str__(self):
        return self._ipaddress

    def __repr__(self):
        return f"{type(self).__name__}('{self._ipaddress}')"


# Класс PhoneNumber
# 932
# ализуйте класс PhoneNumber, описывающий телефонный номер. При создании экземпляра класс должен принимать один аргумент:
#     phone_number — телефонный номер, представляющий строку из десяти цифр в одном из следующих форматов:
#     dddddddddd
#     ddd ddd dddd
# Экземпляр класса PhoneNumber должен иметь следующее формальное строковое представление:
# PhoneNumber('<телефонный номер в формате dddddddddd>')
# И следующее неформальное строковое представление:
# <телефонный номер в формате (ddd) ddd-dddd>
# ---------------------------------------------------------------


class PhoneNumber:
    def __init__(self, phone_number: str) -> None:
        self.tel_number = re.findall(
            '(\d{3})\s*(\d{3})\s*(\d{4})', phone_number)[0]

    def __repr__(self) -> str:
        return f"PhoneNumber('{''.join(self.tel_number)}')"

    def __str__(self) -> str:
        return "({}) {}-{}".format(*self.tel_number)


phone = PhoneNumber('9173963385')

print(str(phone))
print(repr(phone))
# -------------------replace-----------------------------------


class PhoneNumber:
    def __init__(self, phone_number):
        self.phone_number = phone_number.replace(' ', '')

    def __str__(self):
        return f'({self.phone_number[:3]}) {self.phone_number[3:6]}-{self.phone_number[6:]}'

    def __repr__(self):
        return f"PhoneNumber('{self.phone_number}')"


# ---------------------------------------------------------------


# Класс AnyClass
# 867
# Реализуйте класс AnyClass. При создании экземпляра класс должен принимать произвольное количество именованных аргументов и устанавливать их в качестве атрибутов создаваемому экземпляру.
# Экземпляр класса AnyClass должен иметь следующее формальное строковое представление:
# AnyClass(<имя 1-го атрибута>=<значение 1-го атрибута>, <имя 2-го атрибута>=<значение 2-го атрибута>, ...)
# И следующее неформальное строковое представление:
# AnyClass: <имя 1-го атрибута>=<значение 1-го атрибута>, <имя 2-го атрибута>=<значение 2-го атрибута>, ...
# Примечание 1. Обратите внимание, что значения атрибутов, которые принадлежат типу str, должны быть обрамлены апострофами.
# ---------------------------------------------------------------
class AnyClass:
    def __init__(self, **kwargs) -> None:
        self.kwargs = kwargs

        for key, value in self.kwargs.items():
            if isinstance(value, str):

                 '{}={!r}'.format(key, value)

        self.l1 = ((f"{key}='{value}'") for key, value in self.kwargs.items() if isinstance(value, str)))

    def __repr__(self) -> str:
        s=f"AnyClass({('{}, ' * len(self.l1))[:-2]})"
        return s.format(*self.l1)

        return "AnyClass({})".format(*self.l1)

    def __str__(self) -> str:
        s=f"AnyClass: {('{}, ' * len(self.l1))[:-2]}"
        return s.format(*self.l1)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Vector
# 939
# Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата вектора по оси xx
#     y — координата вектора по оси yy
# Экземпляр класса Vector должен иметь следующее формальное строковое представление:
# Vector(<координата x>, <координата y>)
# Также экземпляры класса Vector должны поддерживать операции сравнения с помощью операторов == и!=. Два вектора считаются равными, если их координаты по обеим осям совпадают. Методы, реализующие операции сравнения, должны уметь сравнивать как два вектора между собой, так и вектор с кортежем из двух чисел, представляющих координаты xx и yy.
# Примечание 1. Числами будем считать экземпляры классов int и float.
# Примечание 2. Если объект, с которым выполняется операция сравнения, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------
class Vector:
    def __init__(self, x: int | float, y: int | float) -> None:
        self.x=x
        self.y=y

    def __repr__(self) -> str:
        return f"Vector({self.x}, {self.y})"

    def __eq__(self, __o: object | tuple) -> bool:
        if isinstance(__o, Vector):
            return self.x == __o.x and self.y == __o.y
        elif isinstance(__o, tuple) == __o and len(__o) == 2:
            return (self.x, self.y) == __o
        return NotImplemented
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Word
# 956
# Будем называть словом любую последовательность из одной или более латинских букв.
# Реализуйте класс Word, описывающий слово. При создании экземпляра класс должен принимать один аргумент:
#     word — слово
# Экземпляр класса Word должен иметь следующее формальное строковое представление:
# Word('<слово в исходном виде>')
# И следующее неформальное строковое представление:
# <слово, в котором первая буква заглавная, а все остальные строчные>
# Также экземпляры класса Word должны поддерживать между собой все операции сравнения с помощью операторов ==, !=, >, <, >=, <=. Два слова считаются равными, если их длины совпадают. Слово считается больше другого слова, если его длина больше.
# Примечание 1. Если объект, с которым выполняется операция сравнения, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# Примечание 2. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------

from functools import total_ordering

@ total_ordering
class Word:
    def __init__(self, word: str) -> None:
        self.word=word

    def __repr__(self) -> str:
        return "Word('{}')".format(self.word)

    def __str__(self) -> str:
        return self.word.title()

    def __eq__(self, __o: object) -> bool:
        if isinstance(__o, Word):
            return len(self.word) == len(__o.word)
        return NotImplemented

    def __lt__(self, __o: object) -> bool:
        if isinstance(__o, Word):
            return len(self.word) < len(__o.word)
        return NotImplemented



# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Month
# 938
# Реализуйте класс Month, описывающий месяц. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     year — год
#     month — порядковый номер месяца
# Экземпляр класса Month должен иметь следующее формальное строковое представление:
# Month(<год>, <порядковый номер месяца>)
# И следующее неформальное строковое представление:
# <год>-<порядковый номер месяца>
# Также экземпляры класса Month должны поддерживать все операции сравнения с помощью операторов ==, !=, >, <, >=, <=. Два Month объекта считаются равными, если их годы и порядковые номера месяцев совпадают. Month объект считается больше другого Month объекта, если его год больше. В случае если два Month объекта имеют равные года, большим считается тот, чей месяц больше. Методы, реализующие операции сравнения, должны уметь сравнивать как два Month объекта между собой, так и Month объект с кортежем из двух чисел, представляющих год и месяц.
# Примечание 1. Если объект, с которым выполняется операция сравнения, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------
from functools import total_ordering
from typing import Tuple

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Version
# 886
# Реализуйте класс Version, описывающий версию программного обеспечения. При создании экземпляра класс должен принимать один аргумент:
#     version — строка из трех целых чисел, разделенных точками и описывающих версию ПО. Например, 2.8.1. Если одно из чисел не указано, оно считается равным нулю. Например, версия 2 равнозначна версии 2.0.0, а версия 2.8 равнозначна версии 2.8.0
# Экземпляр класса Version должен иметь следующее формальное строковое представление:
# Version('<версия ПО в виде трех целых чисел, разделенных точками>')
# И следующее неформальное строковое представление:
# <версия ПО в виде трех целых чисел, разделенных точками>
# Также экземпляры класса Version должны поддерживать между собой все операции сравнения с помощью операторов ==, !=, >, <, >=, <=. Два Version объекта считаются равными, если все три числа в их версиях совпадают. Version объект считается больше другогоVersion объекта, если первое число в его версии больше. Или если второе число в его версии больше, если первые числа совпадают. Или если третье число в его версии больше, если первые и вторые числа совпадают.
# Примечание 1. Если объект, с которым выполняется операция сравнения, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------

from functools import total_ordering
from itertools import zip_longest


@ total_ordering
class Version:
    def __init__(self, version: str) -> None:

        nums_version=map(int, version.split('.'))
        index_elem=range(3)

        # заполняю недостающие цифры нулями и добавляю только первые элементы кортежей
        gen1=(i[0] for i in zip_longest(nums_version, index_elem, fillvalue=0))

        self.write_full_version='.'.join(map(str, gen1))
        self.num1, self.num2, self.num3=(
            int(char) for char in self.write_full_version.split('.'))




    def __repr__(self) -> str:
        return f"Version('{self.write_full_version}')"

    def __str__(self) -> str:
        return self.write_full_version

    def __eq__(self, __o: object) -> bool:
        if isinstance(__o, Version):
            return (self.num1, self.num2, self.num3) == (__o.num1, __o.num2, __o.num3)
        return NotImplemented

    def __lt__(self, __o: object) -> bool:
        if isinstance(__o, Version):
            return (self.num1, self.num2, self.num3) < (__o.num1, __o.num2, __o.num3)
        return NotImplemented



versions=[Version('2'), Version('2.1'), Version('1.9.1')]

print(sorted(versions))
print(min(versions))
print(max(versions))


# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс ReversibleString
#
# Реализуйте класс ReversibleString, описывающий строку. При создании экземпляра класс должен принимать один аргумент:
#     string — значение строки
# Экземпляр класса ReversibleString должен иметь следующее неформальное строковое представление:
# <значение строки>
# Также экземпляр класса ReversibleString должен поддерживать унарный оператор -, результатом которого должен являться новый экземпляр класса ReversibleString со значением строки в обратном порядке.
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# --------------------------------------------------------------
class ReversibleString:
    def __init__(self, string: str) -> None:
        self.string=string

    def __str__(self) -> str:
        return f'{self.string}'


    def __neg__(self):
        return ReversibleString(''.join(reversed(self.string)))

string=ReversibleString('python')

print(string)
print(-string)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Money
# 972
# Реализуйте класс Money, описывающий денежную сумму в рублях. При создании экземпляра класс должен принимать один аргумент:
#     amount — количество денег
# Экземпляр класса Money должен иметь следующее неформальное строковое представление:
# <количество денег> руб.
# Также экземпляр класса Money должен поддерживать унарные операторы + и -:
#     результатом унарного + должен являться новый экземпляр класса Money с неотрицательным количеством денег
#     результатом унарного - должен являться новый экземпляр класса Money с отрицательным количеством денег
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------
class Money:
    def __init__(self, amount: int | float) -> None:
        self.amount=amount

    def __str__(self) -> str:
        return f'{self.amount} руб.'

    def __neg__(self):
        return Money(-abs(self.amount))

    def __pos__(self):
        return Money(abs(self.amount))
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Vector
# 959
# Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата вектора по оси xx
#     y — координата вектора по оси yy
# Экземпляр класса Vector должен иметь следующее формальное строковое представление:
# Vector(<координата x>, <координата y>)
# И следующее неформальное строковое представление:
# (<координата вектора по оси x>, <координата вектора по оси y>)
# Также экземпляр класса Vector должен поддерживать унарные операторы + и -:
#     результатом унарного + должен являться новый экземпляр класса Vector с исходными координатами
#     результатом унарного - должен являться новый экземпляр класса Vector с координатами, взятыми с противоположным знаком
# Наконец, при передаче экземпляра класса Vector в функцию abs() должен возвращаться его модуль.
# Примечание 1. Модуль вектора с координатами (x,y)(x,y) вычисляется по формуле x2+y2x2+y2
# ---------------------------------------------------------------
class Vector:
    def __init__(self, x, y) -> None:
        self.x=x
        self.y=y

    def __repr__(self) -> str:
        return f"Vector({self.x}, {self.y})"

    def __str__(self) -> str:
        return f'({self.x}, {self.y})'


    def __pos__(self):
        return Vector(self.x, self.y)

    def __neg__(self):
        return Vector(-self.x, -self.y)


    def __abs__(self):
        return (self.x**2 + self.y**2)**0.5

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс ColoredPoint
# 939
# Реализуйте класс ColoredPoint, описывающий цветную точку на плоскости. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     x — координата точки по оси xx
#     y — координата точки по оси yy
#     color — цвет в формате RGB, представленный кортежем из трех целых чисел в диапазоне [0; 255], по умолчанию имеет значение (0, 0, 0)
# Экземпляр класса ColoredPoint должен иметь три атрибута:
#     x — координата точки по оси xx
#     y — координата точки по оси yy
#     color — цвет в формате RGB, представленный кортежем из трех целых чисел от 0 до 255
# Также экземпляр класса ColoredPoint должен иметь следующее формальное строковое представление:
# ColoredPoint(<координата x>, <координата y>, <цвет точки в виде трехэлементного кортежа>)
# И следующее неформальное строковое представление:
# (<координата x>, <координата y>)
# Наконец, экземпляр класса ColoredPoint должен поддерживать унарные операторы +, - и ~:
#     результатом унарного + должен являться новый экземпляр класса ColoredPoint c исходными координатами и цветом
#     результатом унарного - должен являться новый экземпляр класса ColoredPoint c координатами, умноженными на минус единицу, и исходным цветом
#     результатом унарного ~ должен являться новый экземпляр класса ColoredPoint c координатами, переставленными местами, и инвертированным цветом: значение каждой компоненты цвета отнимается от 255
# ---------------------------------------------------------------
class ColoredPoint:
    def __init__(self, x, y, color = (0, 0, 0)) -> None:
        self.x, self.y, self.color=x, y, color

    def __repr__(self) -> str:
        return f"ColoredPoint({self.x}, {self.y}, {self.color})"

    def __str__(self) -> str:
        return f"({self.x}, {self.y})"

    def __pos__(self):
        return ColoredPoint(self.x, self.y, self.color)

    def __neg__(self):
        return ColoredPoint(-self.x, -self.y, self.color)

    def __invert__(self):
        a, b, c=self.color
        return ColoredPoint(self.y, self.x, (255 - a, 255 - b, 255 - c))
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Matrix 🌶️🌶️
#
# Реализуйте класс Matrix, описывающий двумерную матрицу. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     rows — количество строк в матрице
#     cols — количество столбцов в матрице
#     value — начальное значение для элементов матрицы, по умолчанию имеет значение 0
# Экземпляр класса Matrix должен иметь два атрибута:
#     rows — количество строк в матрице
#     cols — количество столбцов в матрице
# Класс Matrix должен иметь два метода экземпляра:
#     get_value() — метод, принимающий в качестве аргументов строку row и столбец col и возвращающий элемент матрицы со строкой row и столбцом col
#     set_value() — метод, принимающий в качестве аргументов строку row, столбец col и значение value и устанавливающий в качестве значения элемента матрицы со строкой row и столбцом col значение value
# Экземпляр класса Matrix должен иметь следующее формальное строковое представление:
# Matrix(<количество строк в матрице>, <количество столбцов в матрице>)
# Неформальным строковым представлением должна быть строка, в которой перечислены все элементы матрицы. Элементы строки матрицы должны быть разделены пробелом, строки матрицы должны быть разделены символом переноса строки \n. Например, для объекта Matrix(2, 3) неформальным строковым представлением должна быть строка 0 0 0\n0 0 0, которая при выводе будет отображаться следующим образом:
# 0 0 0
# 0 0 0
# Также экземпляр класса Matrix должен поддерживать унарные операторы +, - и ~:
#     результатом унарного + должен являться новый экземпляр класса Matrix c исходным количеством строк и столбцов и с исходными элементами
#     результатом унарного - должен являться новый экземпляр класса Matrix c исходным количеством строк и столбцов и с элементами, взятыми с противоположным знаком
#     результатом унарного ~ должен являться новый экземпляр класса Matrix, представляющий транспонированную матрицу
# Наконец, при передаче экземпляра класса Matrix в функцию round() должен возвращаться новый экземпляр класса Matrix c исходным количеством строк и столбцов и с элементами, округленными с помощью функции round(). Во время передачи в функцию round() должна быть возможность в качестве второго необязательного аргумента указать целое число, определяющее количество знаков после запятой при округлении.
# Примечание 1. Индексация строк и столбцов в матрице начинается с нуля.
# ---------------------------------------------------------------

class Matrix:
    def __init__(self, rows: int, cols: int, value = 0) -> None:
        self.rows=rows
        self.cols=cols

        self.matrix=[[value] * cols for _ in range(rows)]


    def get_value(self, row, col) -> int | float:
        """метод, принимающий в качестве аргументов строку row и столбец col и возвращающий элемент матрицы со строкой row и столбцом col"""
        return self.matrix[row][col]

    def set_value(self, row, col, value) -> None:
        """метод, принимающий в качестве аргументов строку row, столбец col и значение value и устанавливающий в качестве значения элемента матрицы со строкой row и столбцом col значение value"""
        self.matrix[row][col]=value



    def __repr__(self) -> str:
        return f"Matrix({self.rows}, {self.cols})"

    def __str__(self) -> str:
        l1=[' '.join(map(str, rows)) for rows in self.matrix]
        return '\n'.join(l1)



    def __pos__(self) -> "Matrix":
        new_intance=Matrix(self.rows, self.cols)

        for i in range(len(self.matrix)):
            for j in range(len(self.matrix[i])):
                # используем сеттер и геттер
                new_intance.set_value(i, j, self.get_value(i, j))

        return new_intance


    def __neg__(self) -> "Matrix":
        new_intance=Matrix(self.rows, self.cols)

        for i in range(len(self.matrix)):
            for j in range(len(self.matrix[i])):
                # используем сеттер и геттер
                new_intance.set_value(i, j, -self.get_value(i, j))

        return new_intance


    def __invert__(self) -> "Matrix":
        new_intance1=Matrix(self.rows, self.cols)

        for i in range(len(self.matrix)):
            for j in range(len(self.matrix[i])):
                # используем сеттер и геттер
                new_intance1.set_value(i, j, self.get_value(i, j))

        new_intance2=Matrix(new_intance1.cols, new_intance1.rows)

        transponse=zip(*new_intance1.matrix)  # транспонируем new_intance1
        new_intance2.matrix=transponse

        return new_intance2


    def __round__(self, n = None) -> "Matrix":
        new_intance=Matrix(self.rows, self.cols)

        for i in range(len(self.matrix)):
            for j in range(len(self.matrix[i])):
                if n is None:
                    new_intance.set_value(i, j, round(self.get_value(i, j)))
                new_intance.set_value(i, j, round(self.get_value(i, j), n))

        return new_intance


# ------тест---
matrix=Matrix(5, 10)

floats=[[7125.900408, 633.354471, -9237.8575119, 2865.3825158, 5509.2609336, 8712.260779, 8317.523947, 2512.4736075,
           -3087.5496014, 3861.68814],
          [-7852.451832, 376.465911, -8142.7867326, -6921.8371407, 3735.7516227, -3322.8019034, 7115.79968,
           -8949.9313078, -7032.4347679, -5217.8236385],
          [-7817.9657992, -4319.716346, -1038.6294521, -2959.8970273, -9263.5713405, 9358.607686, 1429.6576196,
           -9484.68116, 639.6343972, 3444.9938213],
          [-2844.2405153, -2078.2441427, 6812.1367017, 112.3910618, -1116.8662449, 5042.7026276, -5981.6930342,
           4370.9173164, -8851.7648474, 8990.6896422],
          [90.8102435, 5256.6137481, -9743.8477321, -131.5501688, -5920.5976176, 4963.8336619, -4907.3622526,
           8531.2015615, -244.3630074, 3421.8817151]]

for r in range(5):
    for c in range(10):
        matrix.set_value(r, c, floats[r][c])

print('НАЧАЛЬНАЯ')
print(matrix)
print()
print('+++++')
print(+matrix)
print()
print('-------')
print(-matrix)
print()
print('ТРАНСПОНИРОВАНАЯ')
print(~matrix)
print()
print('ОКРУГЛЕНИЕ')
print(round(matrix, 2))
# ---------------------------------------------------------------

# ---------------------------------------------------------------

   
# Класс FoodInfo
# 943
# Реализуйте класс FoodInfo, описывающий пищевую ценность продуктов. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     proteins — количество белков в граммах
#     fats — количество жиров в граммах
#     carbohydrates — количество углеводов в граммах
# Экземпляр класса FoodInfo должен иметь три атрибута:
#     proteins — количество белков в граммах
#     fats — количество жиров в граммах
#     carbohydrates — количество углеводов в граммах
# И следующее формальное строковое представление:
# FoodInfo(<количество белков>, <количество жиров>, <количество углеводов>)
# Также экземпляры класса FoodInfo должны поддерживать между собой операцию сложения с помощью оператора +, результатом которой должен являться новый экземпляр класса FoodInfo с суммарным количеством белков, жиров и углеводов исходных экземпляров.
# Наконец, экземпляр класса FoodInfo должен поддерживать операции умножения, деления и деления нацело на число n с помощью операторов *, / и // соответственно:
#     результатом умножения должен являться новый экземпляр класса FoodInfo, количество белков, жиров и углеводов которого умножены на n
#     результатом деления должен являться новый экземпляр класса FoodInfo, количество белков, жиров и углеводов которого поделены на n
#     результатом деления нацело должен являться новый экземпляр класса FoodInfo, количество белков, жиров и углеводов которого поделены нацело на n
# Примечание 1. Числами будем считать экземпляры классов int и float. Также будем гарантировать, что экземпляр класса FoodInfo всегда делится на ненулевое число.
# Примечание 2. Если объект, с которым выполняется арифметическая операция, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------

from typing import TypeVar

Self = TypeVar("Self", bound="FoodInfo")



class FoodInfo:
    def __init__(self, proteins: int | float, fats: int | float, carbohydrates: int | float) -> None:
        self.proteins = proteins
        self.fats = fats
        self.carbohydrates = carbohydrates


    def __repr__(self) -> str:
        return f"FoodInfo({self.proteins}, {self.fats}, {self.carbohydrates})"

    
    def __add__(self, other: Self) -> Self:
        if isinstance(other, FoodInfo):
            return FoodInfo(self.proteins + other.proteins, self.fats + other.fats, self.carbohydrates + other.carbohydrates)
        return NotImplemented

    def __mul__(self, other: int) -> Self:
        if isinstance(other, (int, float)):
            return FoodInfo(self.proteins * other, self.fats * other, self.carbohydrates * other)
        return NotImplemented
   
    def __truediv__(self, other: int) -> Self:
        if isinstance(other, (int, float)):
            return FoodInfo(self.proteins / other, self.fats / other, self.carbohydrates / other)
        return NotImplemented

    def __floordiv__(self, other: int) -> Self:
        if isinstance(other, (int, float)):
            return FoodInfo(self.proteins // other, self.fats // other, self.carbohydrates // other)
        return NotImplemented

#--------tests----------
pfc = [(751.26, 778.77, 947.51), (597.41, 508.5, 532.96), (800.55, 617.5, 525.14), (741.99, 785.53, 664.71),
       (525.69, 892.41, 541.41), (888.8, 802.56, 868.78), (609.65, 855.43, 949.44), (705.25, 592.28, 738.72),
       (514.88, 617.22, 557.5), (948.62, 938.7, 817.17), (783.98, 628.32, 686.38), (894.9, 815.81, 715.19),
       (586.79, 826.68, 637.5), (670.53, 683.69, 841.56), (583.9, 607.34, 853.35), (954.67, 950.76, 822.19),
       (718.94, 658.12, 537.2), (556.53, 686.17, 622.61), (699.8, 872.49, 908.3), (622.3, 920.97, 801.17)]

FoodInfo.__round__ = lambda instance: FoodInfo(
    round(instance.proteins, 2),
    round(instance.fats, 2),
    round(instance.carbohydrates, 2)
)

food1 = FoodInfo(1000, 2000, 3000)
for p, f, c in pfc:
    food2 = FoodInfo(p, f, c)
    add_food = food1 + food2
    mul_food = food1 * p
    truediv_food = food1 // c
    print(round(add_food), round(mul_food), round(truediv_food))

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Vector
#
# Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата вектора по оси xx
#     y — координата вектора по оси yy
# Экземпляр класса Vector должен иметь следующее формальное строковое представление:
# Vector(<координата x>, <координата y>)
# Также экземпляры класса Vector должны поддерживать между собой операции сложения и вычитания с помощью операторов + и - соответственно:
#     результатом сложения должен являться новый экземпляр класса Vector, координата по оси xx которого равна сумме координат по оси xx исходных векторов, координата по оси yy — сумме координат по оси yy исходных векторов
#     результатом вычитания должен являться новый экземпляр класса Vector координата по оси xx которого равна разности координат по оси xx исходных векторов с учетом порядка, координата по оси yy — разности координат по оси yy исходных векторов с учетом порядка
# Наконец, экземпляр класса Vector должен поддерживать операции умножения и деления на число n с помощью операторов * и / соответственно:
#     результатом умножения должен являться новый экземпляр класса Vector, координаты которого умножены на n
#     результатом деления должен являться новый экземпляр класса Vector, координаты которого поделены на n
# Операция умножения должна быть выполнима независимо от порядка операндов, то есть должна быть возможность умножить как вектор на число, так и число на вектор.
# Примечание 1. Числами будем считать экземпляры классов int и float. Также будем гарантировать, что экземпляр класса Vector всегда делится на ненулевое число.
# Примечание 2. Если объект, с которым выполняется арифметическая операция, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------
class Vector:
    def __init__(self, x: int, y: int) -> None:
        self.x = x
        self.y = y

    def __repr__(self) -> str:
        return f"Vector({self.x}, {self.y})"

    def __add__(self, other):
        if isinstance(other, Vector):
            return Vector(self.x + other.x, self.y + other.y)
        return NotImplemented

    def __sub__(self, other):
        if isinstance(other, Vector):
            return Vector(self.x - other.x, self.y - other.y)
        return NotImplemented

    
    
    def __truediv__(self, n):
        if isinstance(n, (int, float)):
            return Vector(self.x / n, self.y / n)
        return NotImplemented
    
    def __rtruediv__(self, n):
        if isinstance(n, (int, float)):
            return Vector(n / self.x, n / self.y)
        return NotImplemented


    def __mul__(self, n):
        if isinstance(n, (int, float)):
            return Vector(self.x * n, self.y * n)
        return NotImplemented
    
    def __rmul__(self, n):
        if isinstance(n, (int, float)):
            return Vector(n * self.x, n * self.y)
        return NotImplemented


# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс SuperString
# 893
# Реализуйте класс SuperString, описывающий строку. При создании экземпляра класс должен принимать один аргумент:
#     string — значение строки
# Экземпляр класса SuperString должен иметь следующее неформальное строковое представление:
# <значение строки>
# Помимо этого, экземпляры класса SuperString должны поддерживать между собой операцию сложения с помощью оператора +, результатом которой должен являться новый экземпляр класса SuperString, представляющий конкатенацию исходных.
# Также экземпляр класса SuperString должен поддерживать операции умножения, деления, побитового сдвига влево и побитового сдвига вправо на целое число n с помощью операторов *, /, << и >> соответственно:
#     результатом умножения должен являться новый экземпляр класса SuperString, представляющий исходную строку, умноженную на n
#     результатом деления должен являться новый экземпляр класса SuperString, представляющий строку из первых m символов исходной строки, где m — длина исходной строки, поделенная нацело на n
#     результатом побитового сдвига влево должен являться новый экземпляр класса SuperString, представляющий исходную строку без последних n символов. Если n больше или равно длине исходной строки, результатом должен являться экземпляр класса SuperString, представляющий пустую строку
#     результатом побитового сдвига вправо должен являться новый экземпляр класса SuperString, представляющий исходную строку без первых n символов. Если n больше или равно длине исходной строки, результатом должен являться экземпляр класса SuperString, представляющий пустую строку
# Операция умножения должна быть выполнима независимо от порядка операндов, то есть должна быть возможность умножить как строку на число, так и число на строку.
# Примечание 1. Будем гарантировать, что экземпляр класса SuperString всегда делится на ненулевое число.
# Примечание 2. Если объект, с которым выполняется арифметическая операция, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------
class SuperString:
    def __init__(self, string: str) -> None:
        self.string = string

    def __str__(self) -> str:
        return self.string

    def __add__(self, other):
        if isinstance(other, SuperString):
            return SuperString(self.string + other.string) 
        return NotImplemented

    
    def __mul__(self, n: int | float) -> 'SuperString':
        if isinstance(n, (int, float)):
            return SuperString(self.string * n)
        return NotImplemented

    def __rmul__(self, n: int | float) -> 'SuperString':
        if isinstance(n, (int, float)):
            return SuperString(n * self.string)
        return NotImplemented

    def __truediv__(self, n: int | float) -> 'SuperString':
        if isinstance(n, (int, float)):
            s = len(self.string) // n
            return SuperString(self.string[:s])
        return NotImplemented

    
    
    def __lshift__(self, n: int | float) -> 'SuperString':
        if isinstance(n, (int, float)):
            if n <= len(self.string):
                if n == 0:
                    return SuperString(self.string)
                return SuperString(self.string[:-n])
            else:
                return SuperString('')
        return NotImplemented

    def __rshift__(self, n: int | float) -> 'SuperString':
        if isinstance(n, (int, float)):
            if n <= len(self.string):
                return SuperString(self.string[n:])
            else:
                return SuperString('')
        return NotImplemented

# ---------------------------------------------------------------


# Класс Time
# 880
# Реализуйте класс Time, описывающий время на цифровых часах. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     hours — количество часов; каждые 24 часа должны преобразовываться в 0 часов
#     minutes — количество минут; каждые 60 минут должны преобразовываться в 1 час
# Экземпляр класса Time должен иметь следующее неформальное строковое представление:
# <количество часов в формате HH>:<количество минут в формате MM>
# Также экземпляры класса Time должны поддерживать между собой операцию сложения с помощью операторов + и +=:
#     результатом сложения с помощью оператора + должен являться новый экземпляр класса Time, количество часов которого равно сумме часов исходных экземпляров класса Time, количество минут — сумме минут исходных экземпляров класса Time
#     результатом сложения с помощью оператора += должен являться левый экземпляр класса Time, количество часов которого увеличено на количество часов правого экземпляра класса Time, количество минут — на количество минут правого экземпляра класса Time
# Примечание 1. Если объект, с которым выполняется арифметическая операция, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------

from typing import TypeVar

Self = TypeVar("Self", bound="Time")

class Time:
    def __init__(self, hours: int, minutes: int) -> None:
        # устанавливаем корректное время сеттером
        self.set_correct_hours(hours)
        self.set_correct_minutes(minutes)
        
    
    def get_correct_hours(self):
        """получить кол-во часов"""        
        return self.hours
    
    def set_correct_hours(self, hours):
        """сеттер, устанавливает корректное кол-во часов"""
        self.hours = hours % 24
        


    def get_correct_minutes(self):
        """получить кол-во минут"""
        return self.minutes

    def set_correct_min(self, minutes):
        """сеттер, устанавливает корректное кол-во минут"""     
        time_min = divmod(minutes, 60)        
        self.minutes = time_min[1]
        self.hours += time_min[0]
    
    
    
    def __str__(self) -> str:
        return f"{str(self.hours).zfill(2)}:{str(self.minutes).zfill(2)}"

    
    
    def __add__(self, other: Self) -> Self:
        if isinstance(other, Time):
            return Time(self.hours + other.hours, self.minutes + other.minutes)
        return NotImplemented

    def __radd__(self, other: Self) -> Self:
        if isinstance(other, Time):
            return Time(other.hours + self.hours, other.minutes + self.minutes)
        return NotImplemented

    def __iadd__(self, other: Self) -> Self:
        if isinstance(other, Time):
            self.hours += other.hours
            self.minutes += other.minutes
            
            # устанавливаем корректное время после +=
            self.set_correct_hours(self.get_correct_hours())
            self.set_correct_minutes(self.get_correct_minutes())            
            return self
        
        return NotImplemented


# -----------препод---------------------------------------------
class Time:
    def __init__(self, hours, minutes):
        self.hours, self.minutes = Time.normalize(hours, minutes)
    
    @staticmethod
    def normalize(hours, minutes):
        return (hours + minutes // 60) % 24, minutes % 60
    
    def __str__(self):
        return f'{self.hours}:{self.minutes}'
        
    def __add__(self, other):
        if isinstance(other, Time):
            return Time(*Time.normalize(self.hours + other.hours, self.minutes + other.minutes))
        return NotImplemented
    
    def __iadd__(self, other):
        if isinstance(other, Time):
            self.hours, self.minutes = Time.normalize(self.hours + other.hours, self.minutes + other.minutes)
            return self
        return NotImplemented


# ---------------------------------------------------------------


# Класс Queue 🌶️
# 831
# Очередь — абстрактный тип данных с дисциплиной доступа к элементам "первый пришёл — первый вышел". Добавление элемента возможно лишь в конец очереди, выборка — только из начала очереди, при этом выбранный элемент из очереди удаляется.
# Реализуйте класс Queue, описывающий очередь. При создании экземпляра класс должен принимать произвольное количество позиционных аргументов, каждый из которых является элементом очереди. Порядок следования аргументов образует порядок элементов в очереди, то есть первый аргумент — первый элемент очереди, второй аргумент — второй элемент очереди, и так далее.
# Класс Queue должен иметь два метода экземпляра:
#     add() — метод, принимающий произвольное количество позиционных аргументов и добавляющий их в конец очереди в том порядке, в котором они были переданы
#     pop() — метод, удаляющий из очереди первый элемент и возвращающий его. Если очередь пуста, метод должен вернуть значение None
# Экземпляр класса Queue должен иметь следующее неформальное строковое представление:
# <первый элемент очереди> -> <второй элемент очереди> -> <третий элемент очереди> -> ...
# Помимо этого, экземпляры класса Queue должны поддерживать между собой операции сравнения с помощью операторов == и!=. Две очереди считаются равными, если они имеют равную длину и содержат равные элементы на равных позициях.
# Также экземпляры класса Queue должны поддерживать между собой операцию сложения с помощью операторов + и +=:
#     результатом сложения с помощью оператора + должен являться новый экземпляр класса Queue, представляющий очередь со всеми элементами исходных очередей: сначала все элементы левой очереди, затем все элементы правой очереди
#     результатом сложения с помощью оператора += должен являться левый экземпляр класса Queue, представляющий очередь, к которой добавлены все элементы правой очереди
# Наконец, экземпляр класса Queue должен поддерживать операцию побитового сдвига вправо на целое число n с помощью оператора >>, результатом которой должен являться новый экземпляр класса Queue, представляющий исходную очередь без первых n элементов. Если n больше или равно длине исходной очереди, результатом должен являться экземпляр класса Queue, представляющий пустую очередь.
# Примечание 1. Если объект, с которым выполняется операция сравнения или арифметическая операция, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------

from typing import Self

class Queue:  
        
    def __init__(self, *args) -> None:
        self.l1 = list(args)

    
    def add(self, *args) -> None:
        for arg in args:
            self.l1.append(arg)

    def pop(self):
        if self.l1:
            return self.l1.pop(0)



    def __str__(self) -> str:        
        return ' -> '.join(map(str,self.l1))



    def __eq__(self, __o: object) -> bool:
        if isinstance(__o, Queue):
            return self.l1== __o.l1
        return NotImplemented

    def __ne__(self, __o: object) -> bool:
        if isinstance(__o, Queue):
            return self.l1 != __o.l1
        return NotImplemented


    
    def __add__(self, other: Self) -> Self:
        if isinstance(other, Queue):            
            return Queue(*(self.l1 + other.l1))            
        return NotImplemented

    def __iadd__(self, other: Self) -> Self:
        if isinstance(other, Queue):
            self.l1 += other.l1 
            return self
        return NotImplemented



    def __rshift__(self, n: int | float) -> Self:
        """побитовый сдвиг вправо на целое число n с помощью оператора >>, результатом которого должен являться новый экземпляр класса Queue, представляющий исходную очередь без первых n элементов. Если n больше или равно длине исходной очереди, результатом должен являться экземпляр класса Queue, представляющий пустую очередь."""
        if isinstance(n, (int, float)):
            if n <= len(self.l1):
                return Queue(*self.l1[n:])
            else:
                return Queue()
        return NotImplemented

#     def __rshift__(self, n):
#         if isinstance(n, int):
#             return Queue(*self.queue[n:])
#         return NotImplemented    
# # -------------------:--------------------------------------------

# ---------------------------------------------------------------


# Класс Calculator
# 949
# Реализуйте класс Calculator, экземпляры которого позволяют выполнять различные арифметические операции с двумя числами. При создании экземпляра класс не должен принимать никаких аргументов.

# Экземпляр класса Calculator должен являться вызываемым объектом и принимать три аргумента:
#     a — число
#     b — число
#     operation — один из символов +, -, * и /
# Если operation равняется +, экземпляр класса Calculator должен вернуть сумму a и b, если - — разность a и b, если * — произведение a и b, если / — частное a и b. При попытке выполнить деление на ноль должно быть возбуждено исключение ValueError с текстом:
# Деление на ноль невозможно
# Примечание 1. Числами будем считать экземпляры классов int и float.
# ---------------------------------------------------------------

from typing import Any

class Calculator:
    def __call__(self, a: int, b: int, operation: str) -> Any:
        if operation == '+':
            result = a + b
        elif operation == '-':
            result = a - b
        elif operation == '*':
            result = a * b
        elif operation == '/':
            try:
                result = a / b
            except ZeroDivisionError:
                raise ValueError('Деление на ноль невозможно')
        return result
# -----------------препод1-----------------------------------------
class Calculator:
    def __call__(self, a, b, operation):
        match operation:
            case '+':
                return a + b
            case '-':
                return a - b
            case '*':
                return a * b
            case '/':
                if b == 0:
                    raise ValueError('Деление на ноль невозможно')
                return a / b
# -----------------препод2----------------------------------------------
class Calculator:
    def __call__(self, a, b, operation):
        if operation == '/' and b == 0:
            raise ValueError('Деление на ноль невозможно')
        return eval(f'{a}{operation}{b}')
# ---------------------------------------------------------------



# Класс RaiseTo
# 977
# Реализуйте класс RaiseTo, экземпляры которого позволяют возводить числа в фиксированную степень. При создании экземпляра класс должен принимать один аргумент:
#     degree — показатель степени
# Экземпляр класса RaiseTo должен являться вызываемым объектом и принимать один аргумент:
#     x — число
# Экземпляр класса RaiseTo должен возвращать значение x в степени degree.
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 2. Никаких ограничений касательно реализации класса RaiseTo нет, она может быть произвольной.
# ---------------------------------------------------------------

from typing import Any

class RaiseTo:
    def __init__(self, degree) -> None:
        self.degree = degree

    def __call__(self, x: int) -> Any:
        return x**self.degree    
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Dice
# 981
# Реализуйте класс Dice, описывающий игральный кубик с определенным количеством граней. При создании экземпляра класс должен принимать один аргумент:
#     sides — количество граней игрального кубика
# Экземпляр класса Dice должен являться вызываемым объектом и не принимать никаких аргументов. При вызове он должен возвращать значение случайной грани игрального кубика. Например, если кубик имеет 6 граней, экземпляр класса Dice должен вернуть случайное число из диапазона [1; 6].
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------
import random

class Dice:
    def __init__(self, sides) -> None:
        self.sides = sides

    def __call__(self):
        return random.randint(1, self.sides)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс QuadraticPolynomial
# 971
# Реализуйте класс QuadraticPolynomial, описывающий квадратный трехчлен. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     a — коэффициент aa квадратного трехчлена
#     b — коэффициент bb квадратного трехчлена
#     c — коэффициент cc квадратного трехчлена
# Экземпляр класса QuadraticPolynomial должен являться вызываемым объектом и принимать один аргумент:
#     x — число
# Экземпляр класса QuadraticPolynomial должен возвращать значение выражения ax2+bx+cax2+bx+c, где a,ba,b и cc — коэффициенты квадратного трехчлена.
# Приечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 2. Никаких ограничений касательно реализации класса QuadraticPolynomial нет, она может быть произвольной.
# ---------------------------------------------------------------
from typing import Any

class QuadraticPolynomial:
    def __init__(self, a, b, c) -> None:
        self.a = a
        self.b = b
        self.c = c


    def __call__(self, x) -> Any:
        return self.a * x**2 + self.b * x + self.c
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Strip
# 973
# Реализуйте класс Strip, экземпляры которого позволяют удалять из начала и конца строки определенные символы. При создании экземпляра класс должен принимать один аргумент:
#     chars — строка, в которой перечислены удаляемые символы
# Экземпляр класса Strip должен являться вызываемым объектом и принимать один аргумент:
#     string — строка
# Экземпляр класса Strip должен удалять из начала и конца строки string все символы, перечисленные в chars, и возвращать полученный результат.
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 2. Никаких ограничений касательно реализации класса Strip нет, она может быть произвольной.
# ---------------------------------------------------------------

from typing import Any

class Strip:
    def __init__(self, chars) -> None:
        self.chars = chars

    def __call__(self, string) -> Any:
        return string.strip(self.chars)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Filter
# 966
# Реализуйте класс Filter, описывающий объект для фильтрации элементов итерируемых объектов. При создании экземпляра класс должен принимать один аргумент:
#     predicate — функция-предикат; если имеет значение None, то работает аналогично функции bool()
# Экземпляр класса Filter должен являться вызываемым объектом и принимать один аргумент:
#     iterable — итерируемый объект
# Экземпляр класса Filter должен возвращать список, элементами которого являются элементы итерируемого объекта iterable, для которых функция predicate вернула значение True.
# Примечание 1. Предикат — это функция, которая возвращает True или False в зависимости от переданного в качестве аргумента значения.
# Примечание 2. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 3. Никаких ограничений касательно реализации класса Filter нет, она может быть произвольной.
# ---------------------------------------------------------------
class Filter:
    def __init__(self, predicate) -> None:
        self.predicate = predicate

    def __call__(self, iterable) -> Any:
        return list(filter(self.predicate, iterable))
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс DateFormatter
# 932
# Нередко в разных странах используются разные форматы дат. Рассмотрим часть из них:
# код страны 	формат даты
# ru 	DD.MM.YYYY
# us 	MM-DD-YYYY
# ca 	YYYY-MM-DD
# br 	DD/MM/YYYY
# fr 	DD.MM.YYYY
# pt 	DD-MM-YYYY
# Реализуйте класс DateFormatter, экземпляры которого позволяют преобразовывать даты в формат определенной страны из таблицы выше. При создании экземпляра класс должен принимать один аргумент:
#     country_code — код страны
# Экземпляр класса DateFormatter должен являться вызываемым объектом и принимать один аргумент:
#     d — дата (тип date)
# Экземпляр класса DateFormatter должен возвращать строку с датой d в формате страны с кодом country_code.
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 2. Никаких ограничений касательно реализации класса DateFormatter нет, она может быть произвольной.
# ---------------------------------------------------------------

from datetime import date

class DateFormatter:
    
    pattern_date = {
        "ru": r"%d.%m.%Y",
        "us": r"%m-%d-%Y",
        "ca": r"%Y-%m-%d",
        "br": r"%d/%m/%Y",
        "fr": r"%d.%m.%Y",
        "pt": r"%d-%m-%Y"
    }
    
    def __init__(self, country_code: str) -> None:
        self.country_code = self.pattern_date[country_code]

    def __call__(self, d: date) -> str:
        return d.strftime(self.country_code)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Декоратор @CountCalls
# 953
# # Реализуйте декоратор @CountCalls, который считает количество вызовов декорируемой функции. Счетчик вызовов должен быть доступен по атрибуту calls.
# Примечание 1. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимый декоратор @CountCalls, но не код, вызывающий его.
# ---------------------------------------------------------------

# import functools


# def CountCalls(func):
#     @functools.wraps(func)
#     def wrapper(*args, **kwargs):
#         wrapper.num += 1
#         return func(*args, **kwargs)
#     wrapper.num = 0    
#     return wrapper
# ---------------------------------------------------------------
from typing import Any

class CountCalls:
    def __init__(self, func) -> None:
        self.func = func
        self.calls = 0

    def __call__(self, *args: Any, **kwargs: Any) -> None:
        self.calls += 1
        return self.func(*args, **kwargs)

# ---------------------------------------------------------------


# Декоратор @CachedFunction
# 882
# # Реализуйте декоратор @CachedFunction, который кэширует вычисленные значения декорируемой функции. Кэш должен быть доступен по атрибуту cache и представлять собой словарь, ключом в котором является кортеж с аргументами, а значением — возвращаемое значение декорируемой функции при вызове с этими аргументами.
# Примечание 1. Для однозначного кеширования гарантируется, что декорируемая функция принимает только позиционные аргументы.
# ---------------------------------------------------------------
class CachedFunction:
    def __init__(self, func) -> None:
        self.func = func
        self.cache = {}

    def __call__(self, *args, **kwargs) -> int:
               
        if args in self.cache:
            return self.cache[args]
        else:
            result_func = self.func(*args, **kwargs)
            self.cache[args] = result_func
            return result_func
# ---------------------------------------------------------------
class CachedFunction:
    def __init__(self, func):
        self.func = func
        self.cache = {}

    def __call__(self, *args):
        result = self.cache.get(args) or self.func(*args)
        self.cache.setdefault(args, result)
        return result
# ---------------------------------------------------------------


#  Класс SortKey 🌶️
# 798
# Нередко во время сортировки объектов мы используем дополнительную функцию, которая описывает правило сортировки. Например, если нам нужно отсортировать список экземпляров некоторого класса на основе значений определенного атрибута, мы можем реализовать функцию, которая принимает в качестве аргумента этот экземпляр и возвращает значение необходимого атрибута.
# Приведенный ниже код:
# class User:
#     def __init__(self, name, age):
#         self.name = name
#         self.age = age

#     def __repr__(self):
#         return f'User({self.name}, {self.age})'
# users = [User('Gvido', 67), User('Timur', 30), User('Arthur', 20)]
# print(sorted(users, key=lambda user: user.age))

# выводит:
# [User(Arthur, 20), User(Timur, 30), User(Gvido, 67)]
# Удобно было бы иметь класс SortKey, позволяющий сортировать объекты на основе значений различных атрибутов, лишь перечисляя имена этих атрибутов.
# Чтобы приведенный ниже код:
# class User:
#     def __init__(self, name, age):
#         self.name = name
#         self.age = age

#     def __repr__(self):
#         return f'User({self.name}, {self.age})'
# users = [User('Gvido', 67), User('Timur', 30), User('Arthur', 20)]
# print(sorted(users, key=SortKey('age')))            # сортировка на основе атрибута age
# print(sorted(users, key=SortKey('name', 'age')))    # сортировка на основе атрибута name, а затем age
# выводил:
# [User(Arthur, 20), User(Timur, 30), User(Gvido, 67)]
# [User(Arthur, 20), User(Gvido, 67), User(Timur, 30)]
# Реализуйте класс SortKey, описывающий ключ для сортировки объектов на основе значений их определенных атрибутов. При создании экземпляра класс должен принимать произвольное количество позиционных аргументов, каждый из которых представляет имя атрибута, участвующего в сортировке.
# Примечание 1. Имена атрибутов при создании экземпляра класса SortKey передаются в порядке приоритета, то есть при сортировке сначала должно учитываться значение первого атрибута, затем второго, и так далее.
# ---------------------------------------------------------------
class SortKey:
    def __init__(self, *args) -> None:
        self.attributes = args        

    def __call__(self, object):        
        return [object.__dict__[attributes] for attributes in self.attributes]

#--------тест-----------------
class User:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __repr__(self):
        return f'User({self.name}, {self.age})'

users = [User('Gvido', 67), User('Timur', 30), User('Arthur', 20), User('Timur', 45), User('Gvido', 60)]

print(sorted(users, key=SortKey('name')))
print(sorted(users, key=SortKey('name', 'age')))
print(sorted(users, key=SortKey('age')))
print(sorted(users, key=SortKey('age', 'name')))


# ---------------------------------------------------------------
class SortKey:
    def __init__(self, *attributes):
        self.attributes = attributes

    def __call__(self, instance):
        return [getattr(instance, attribute) for attribute in self.attributes]
# ---------------------------------------------------------------


# Класс Vector
# 943
# Реализуйте класс Vector, описывающий вектор на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата вектора по оси xx
#     y — координата вектора по оси yy
# Экземпляр класса Vector должен иметь следующее неформальное строковое представление:
# (<координата x>, <координата y>)
# Также экземпляр класса Vector должен поддерживать приведение к типам bool, int, float и complex:
#     при приведении к типу bool значением вектора должно являться значение True, если хотя бы одна его координата не равна нулю, или False в противном случае
#     при приведении к типу int значением вектора должен являться его модуль в виде целого числа с отброшенной дробной частью
#     при приведении к типу float значением вектора должен являться его модуль в виде вещественного числа
#     при приведении к типу complex значением вектора должно являться комплексное число, вещественная часть которого равна координате вектора по оси xx, мнимая часть — координате вектора по оси yy
# Примечание 1. Модуль вектора с координатами (x,y)(x,y) вычисляется по формуле x2+y2x2+y2
# ---------------------------------------------------------------
class Vector:
    def __init__(self, x: int | float, y: int | float) -> None:
        self.x = x
        self.y = y

    def __str__(self) -> str:
        return f"({self.x}, {self.y})"

    def __bool__(self):
        return self.x != 0 or self.y != 0

    def __int__(self) -> int:
        return int((self.x**2 + self.y**2)**0.5)

    def __float__(self) -> float:
        return (self.x**2 + self.y**2)**0.5

    def __complex__(self) -> complex:
        return complex(self.x, self.y)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Temperature
# 936
# Реализуйте класс Temperature, описывающий температуру в градусах по шкале Цельсия. При создании экземпляра класс должен принимать один аргумент:
#     temperature — температура в градусах по шкале Цельсия
# Класс Temperature должен иметь один метод экземпляра:
#     to_fahrenheit() — метод, возвращающий температуру по шкале Фаренгейта
# Класс Temperature должен иметь один метод класса:
#     from_fahrenheit() — метод, принимающий в качестве аргумента температуру по шкале Фаренгейта и возвращающий экземпляр класса Temperature, созданный на основе переданной температуры
# Экземпляр класса Temperature должен иметь следующее неформальное строковое представление:
# <температура в градусах по шкале Цельсия с округлением до двух знаков после запятой>°C
# Также экземпляр класса Temperature должен поддерживать приведение к типам bool, int и float:
#     при приведении к типу bool значением экземпляра класса Temperature должно являться значение True, если его температура выше нуля, или False в противном случае
#     при приведении к типу int значением экземпляра класса Temperature должна являться его температура в виде целого числа с отброшенной дробной частью
#     при приведении к типу float значением экземпляра класса Temperature должна являться его температура в виде вещественного числа
# Примечание 1. Перевести температуру из шкалы Фаренгейта в шкалу Цельсия позволяет формула:
# tC=59(tF – 32)
# tC​=95​(tF​–32)где tCtC​ — температура в градусах по шкале Цельсия, tFtF​ — температура в градусах по шкале Фаренгейта.

class Temperature:
    def __init__(self, temperature) -> None:
        self.temperature = temperature
    
    def to_fahrenheit(self):
        """метод, возвращающий температуру по шкале Фаренгейта"""
        return 9/5 * self.temperature + 32

    @classmethod
    def from_fahrenheit(cls, temper_f: int | float) -> 'Temperature':
        """метод, принимающий в качестве аргумента температуру по шкале Фаренгейта и возвращающий экземпляр класса Temperature, созданный на основе переданной температуры """
        return Temperature(5/9 * (temper_f - 32))


    def __str__(self) -> str:
        return f"{round(self.temperature, 2)}°C" # return f'{self.temperature.__round__(2)}°C'
         


    def __bool__(self) -> bool:
        return self.temperature > 0

    def __int__(self) -> int:
        return int(self.temperature)

    def __float__(self) -> float:
        return float(self.temperature)
        
# ---------------------------------------------------------------


# Класс RomanNumeral🌶️🌶️
# 743
# Реализуйте класс RomanNumeral, описывающий число в римской системе счисления. При создании экземпляра класс должен принимать один аргумент:
#     number — число в римской системе счисления. Например, IV
# Экземпляр класса RomanNumeral должен иметь следующее неформальное строковое представление:
# <число в римской системе счисления>
# Помимо этого, экземпляр класса RomanNumeral должен поддерживать приведение к типу int, при приведении к которому его значением должно являться целое число в десятичной системе счисления, которому он соответствует.
# Также экземпляры класса RomanNumeral должны поддерживать между собой все операции сравнения с помощью операторов ==, !=, >, <, >=, <=.
# Наконец, экземпляры класса RomanNumeral должны поддерживать между собой операции сложения и вычитания с помощью операторов + и - соответственно:
#     результатом сложения должен являться новый экземпляр класса RomanNumeral, представляющий сумму исходных
#     результатом вычитания должен являться новый экземпляр класса RomanNumeral, представляющий разность исходных
# Примечание 1. Гарантируется, что из римского числа всегда вычитается строго меньшее римское число.
# Примечание 2. Подробнее про римскую систему счисления можно почитать по ссылке.
# Примечание 3. Не забывайте, что именно константу NotImplemented рекомендуется возвращать в методах, реализующих арифметические операции или операции сравнения, если эти операции для объектов каких-либо типов не определены.
# ---------------------------------------------------------------

from functools import total_ordering

@total_ordering
class RomanNumeral:
    def __init__(self, number: str) -> None:
        self.number = number    
    
    
    #=======================================================================
    # формируем словарь из всех римских чисел и новых комбинаций
    all_roman = [(1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'), (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'), (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')]
    
    @staticmethod
    def rim_to_dec(rom: str) -> int:
        """функция перевода римского числа в десятичную систему счисления"""
        
        # на старте десятичное число равно нулю
        dec = 0
        # перебираем все пары из словаря
        for i, r in RomanNumeral.all_roman:
            # пока римское число начинается буквы из словаря
            while rom.startswith(r):
                # увеличиваем десятичное число на соответствующее значение из словаря
                dec += i
                # убираем найденную букву из римского числа
                rom = rom[len(r):]
        # как все циклы закончились — возвращаем десятичное число
        return dec
    #=======================================================================
    
    @staticmethod    
    def dec_to_roman(num: int) -> str:
        """функция перевода чисел в римскую систему счисления"""
        # на старте в римском числе ничего нет
        roman = ''
        # пока наше число больше нуля
        while num > 0:
            # перебираем все пары из словаря
            for i, r in RomanNumeral.all_roman:
                # пока наше число больше или равно числу из словаря
                while num >= i:
                    # добавляем соответствующую букву в римское число
                    roman += r
                    # вычитаем словарное число из нашего числа
                    num -= i
        # как все циклы закончились — возвращаем римское число
        return roman
    #=======================================================================
    
    
    def __str__(self) -> str:
        return f"{self.number}"

    def __int__(self) -> int:
        return RomanNumeral.rim_to_dec(self.number)


    
    def __eq__(self, other) -> bool:
        if isinstance(other, RomanNumeral):
            return self.rim_to_dec(self.number) == self.rim_to_dec(other.number)
        return NotImplemented

    def __lt__(self, other) -> bool:
        if isinstance(other, RomanNumeral):
            return self.rim_to_dec(self.number) < self.rim_to_dec(other.number)
        return NotImplemented



    def __add__(self, other):
        if isinstance(other, RomanNumeral):
            a = self.rim_to_dec(self.number)
            b = self.rim_to_dec(other.number)
            return RomanNumeral(RomanNumeral.dec_to_roman(a + b)) 
        return NotImplemented

    def __sub__(self, other):
        if isinstance(other, RomanNumeral):
            return RomanNumeral((self.rim_to_dec(self.number) - self.rim_to_dec(other.number))) 
        return NotImplemented



# -------тест-----
number = RomanNumeral('X') - RomanNumeral('VI')

print(number)
print(int(number))

# ----------------препод-----------------------------------------
from functools import total_ordering

@total_ordering
class RomanNumeral:
    def __init__(self, number):
        self.number = number
        
    def __str__(self):
        return self.number
    
    def __int__(self):
        return RomanNumeral.roman_to_int(self.number)
    
    def __add__(self, other):
        if isinstance(other, RomanNumeral):
            num1 = int(self)
            num2 = int(other)
            return RomanNumeral(RomanNumeral.int_to_roman(num1 + num2))
        else:
            return NotImplemented
    
    def __sub__(self, other):
        if isinstance(other, RomanNumeral):
            num1 = int(self)
            num2 = int(other)
            return RomanNumeral(RomanNumeral.int_to_roman(num1 - num2))
        else:
            return NotImplemented
    
    def __eq__(self, other):
        if isinstance(other, RomanNumeral):
            return self.number == other.number
        else:
            return NotImplemented
        
    def __gt__(self, other):
        if isinstance(other, RomanNumeral):
            return RomanNumeral.roman_to_int(self.number) > RomanNumeral.roman_to_int(other.number)
        else:
            return NotImplemented
    
    @staticmethod
    def int_to_roman(number):
        int_roman = {1: 'I', 4: 'IV', 5: 'V', 9: 'IX', 
                     10: 'X', 40: 'XL', 50: 'L', 90: 'XC', 
                     100: 'C', 400: 'CD',  500: 'D', 900: 'CM', 1000: 'M'}
        result = ''
        for n in (1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1):
            while n <= number:
                result += int_roman[n]
                number -= n
        return result
     
    @staticmethod
    def roman_to_int(number):
        roman_int = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
        summ = 0
        for i in range(len(number) - 1, -1, -1):
            num = roman_int[number[i]]
            if 3*num < summ: 
                summ -= num
            else: 
                summ += num
        return summ
# ---------------------------------------------------------------


# Класс Item
# 950
# Требовалось реализовать класс Item, описывающий предмет. При создании экземпляра класс должен был принимать три аргумента в следующем порядке:
#     name — название предмета
#     price — цена предмета в рублях
#     quantity — количество предметов
# Предполагалось, что при обращении к атрибуту name экземпляра класса Item будет возвращаться его название с заглавной буквы, а при обращении к атрибуту total — произведение цены предмета на его количество.
# Программист торопился и решил задачу неправильно. Дополните приведенный ниже код и реализуйте правильный класс Item.
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------
class Item:
    def __init__(self, name, price, quantity):
        self.name = name.title()
        self.price = price
        self.quantity = quantity

    def __getattr__(self, attr):
        if attr == 'total': 
            return self.price * self.quantity
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Logger
# 971
# Требовалось реализовать класс Logger. При создании экземпляра класс не должен был принимать никаких аргументов.
# Предполагалось, что при установке или изменении значения атрибута экземпляра класса Logger будет выводиться текст:
# Изменение значения атрибута <имя атрибута> на <новое значение атрибута>
# Также планировалось, что при удалении атрибута будет выводиться текст:
# Удаление атрибута <имя атрибута>
# Программист торопился и решил задачу неправильно. Дополните приведенный ниже код и реализуйте правильный класс Logger.
# Примечание. Никаких ограничений касательно реализации класса Logger нет, она может быть произвольной.
# ---------------------------------------------------------------
class Logger:
    
    def __getattribute__(self, name):       
        return object.__getattribute__(self, name)      # получение значения атрибута attr объекта self

    def __setattr__(self, name, value):
        print(f'Изменение значения атрибута {name} на {value}')
        self.__dict__[name] = value

    def __delattr__(self, name):
        print(f'Удаление атрибута {name}')
        del self.__dict__[name]
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Ord
# Реализуйте класс Ord. При создании экземпляра класс не должен принимать никаких аргументов.
# Экземпляр класса Ord должен выступать в качестве альтернативы функции ord(). При обращении к атрибуту экземпляра, именем которого является одиночный символ, должна возвращаться его позиция в таблице символов Unicode.
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 2. Никаких ограничений касательно реализации класса Ord нет, она может быть произвольной.
# Примечание 3. Тестовые данные доступны по ссылкам:
# ---------------------------------------------------------------
class Ord:    
    def __getattr__(self, attr):
        return ord(attr)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс DefaultObject
# 964
# # Реализуйте класс DefaultObject. При создании экземпляра класс должен принимать один именованный аргумент default, имеющий значение по умолчанию None, а после произвольное количество именованных аргументов. Аргументы, передаваемые после default, должны устанавливаться создаваемому экземпляру в качестве атрибутов.
# При обращении к несуществующему атрибуту экземпляра класса DefaultObject должно возвращаться значение default.
# ---------------------------------------------------------------
class DefaultObject:
    def __init__(self, default=None, **kwargs) -> None:
        self.default = default
                
        for attribut_name, attribut_value in kwargs.items():
            object.__setattr__(self, attribut_name, attribut_value)
    
    def __getattribute__(self, attr):   # мы обращаемся к методу __getattribute__() класса object и передаем ему в качестве аргумента объект и имя атрибута, значение по которому хотим получить. Метод __getattribute__() класса object возвращает значение атрибута по указанному имени или возбуждает исключение AttributeError, если атрибут с указанными именем не был найден.      
        return object.__getattribute__(self, attr) 
    
    def __getattr__(self, attr):      # возврат значения по умолчанию при обращении к несуществующему атрибуту      
        if attr in self.kwargs:
            return self.__dict__[attr]
        return self.default
    
    
    def __setattr__(self, attr, value):   # установка атрибута или изменение его значения внутри метода __setattr__() происходит напрямую через словарь атрибутов __dict__    
        self.__dict__[attr] = value
        # object.__setattr__(self, attr, value)     #  Вместо обращения к словарю атрибутов __dict__, метод __setattr__() может использовать свою базовую реализацию из класса object
# ----------------препод---------------------------------------
class DefaultObject:
    def __init__(self, default=None, **kwargs):
        self.default = default
        self.__dict__.update(kwargs)
        
    def __getattr__(self, name):
        return self.default
# ---------------------------------------------------------------


# Класс NonNegativeObject
# 964
# Реализуйте класс NonNegativeObject. При создании экземпляра класс должен принимать произвольное количество именованных аргументов. Все передаваемые аргументы должны устанавливаться создаваемому экземпляру в качестве атрибутов, причем если значением атрибута является отрицательное число, оно должно быть взято с противоположным знаком.
# Примечание 1. Числами будем считать экземпляры классов int и float.
# ---------------------------------------------------------------
class NonNegativeObject:
    def __init__(self, **kwargs) -> None:
                
        for key, value in kwargs.items():
            if isinstance(value, (int, float)):
                self.__dict__.update({key: abs(value)})
            self.__dict__.update({key: value})

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс AttrsNumberObject
# 940
# Реализуйте класс AttrsNumberObject. При создании экземпляра класс должен принимать произвольное количество именованных аргументов. Все передаваемые аргументы должны устанавливаться создаваемому экземпляру в качестве атрибутов.
# Экземпляр класса AttrsNumberObject должен иметь один атрибут:
#     attrs_num — количество атрибутов, которыми обладает экземпляр класса AttrsNumberObject на данный момент, включая сам атрибут attrs_num

# -------------имитация атрибута  attrs_num----------------------------------------
class AttrsNumberObject:
    def __init__(self, **kwargs) -> None:          
          
        self.__dict__.update(kwargs) # Все передаваемые аргументы должны устанавливаться создаваемому экземпляру в качестве атрибутов
        # self.__dict__ |= kwargs
 
    def __getattr__(self, name): 
        if name == 'attrs_num':
            return len(self.__dict__) + 1


music_group = AttrsNumberObject(name='Woodkid', genre='pop')

print(music_group.attrs_num)
music_group.country = 'France' # создать атрибут экземпляра
print(music_group.attrs_num)

# ----------------наличие атрибута-  attrs_num----------------------------------
class AttrsNumberObject:
    def __init__(self, attrs_num=0, **kwargs) -> None:
        self.__dict__.update(kwargs) # Все передаваемые аргументы должны устанавливаться создаваемому экземпляру в качестве атрибутов
        self.attrs_num = attrs_num

    def __setattr__(self, attr, value):
        self.__dict__[attr] = value
        self.__dict__['attrs_num'] = len(self.__dict__)

    def __delattr__(self, attr):
        del self.__dict__[attr]
        self.__dict__['attrs_num'] = len(self.__dict__)

music_group = AttrsNumberObject(name='Woodkid', genre='pop')

print(music_group.attrs_num)
music_group.country = 'France'   # создать атрибут экземпляра

print(music_group.attrs_num)
# ---------------------------------------------------------------

# Класс Const
# 949
# Реализуйте класс Const. При создании экземпляра класс должен принимать произвольное количество именованных аргументов. Все передаваемые аргументы должны устанавливаться создаваемому экземпляру в качестве атрибутов.
# Класс Const должен разрешать устанавливать атрибуты своим экземплярам и получать их значения, но не разрешать изменять значения этих атрибутов, а также удалять их. При попытке изменить значение атрибута должно возбуждаться исключение AttributeError с текстом:
# Изменение значения атрибута невозможно
# При попытке удалить атрибут должно возбуждаться исключение AttributeError с текстом:
# Удаление атрибута невозможно
# ---------------------------------------------------------------
class Const:
    def __init__(self, **kwargs) -> None:
        self.__dict__.update(kwargs) 
    
    def __getattr__(self, attr):
        return self.__dict__[attr]
    
    def __setattr__(self, attr, value):
        if attr in self.__dict__:
            raise AttributeError('Изменение значения атрибута невозможно')
        else:
            self.__dict__[attr] = value
                    
    def __delattr__(self, attr):        
        raise AttributeError ('Удаление атрибута невозможно')   
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс ProtectedObject
# 874
# Будем считать атрибут защищенным, если его имя начинается с символа нижнего подчеркивания (_). Например, _password, __email и __dict__.
# Реализуйте класс ProtectedObject. При создании экземпляра класс должен принимать произвольное количество именованных аргументов. Все передаваемые аргументы должны устанавливаться создаваемому экземпляру в качестве атрибутов.
# Класс ProtectedObject должен запрещать получать и изменять значения защищенных атрибутов своих экземпляров, а также удалять эти атрибуты. При попытке получить или изменить значение защищенного атрибута, а также попытке удалить атрибут, должно возбуждаться исключение AttributeError с текстом:
# Доступ к защищенному атрибуту невозможен
# ---------------------------------------------------------------
class ProtectedObject:
    def __init__(self, **kwargs) -> None:
        for attr, value in kwargs.items():     
             object.__setattr__(self, attr, value)
        # или вместо цикла
        # object.__getattribute__(self, '__dict__').update(kwargs)     
        
    def __getattribute__(self, attr):
        if attr[0] == '_':  #  if name.startswith('_'):
            raise AttributeError('Доступ к защищенному атрибуту невозможен')        
        else:
            return object.__getattribute__(self, attr)    
    
    # Метод __getattr__() реализовывать необязательно
            
    def __setattr__(self, attr, value):     
        if attr[0] == '_': #  if name.startswith('_'):
            raise AttributeError('Доступ к защищенному атрибуту невозможен')               
        else: 
            object.__setattr__(self, attr, value)             
        
    
    def __delattr__(self, attr):
        if attr[0] == '_': #  if name.startswith('_'):
            raise AttributeError('Доступ к защищенному атрибуту невозможен')
        else:
            object.__delattr__(self, attr)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Функция hash_function()
# 837
# Реализуйте функцию hash_function(), которая принимает один аргумент:
#     obj — произвольный объект
# Функция должна вычислять хеш-значение объекта obj согласно следующему алгоритму:
#     вычисление значения выражения:
#     ord(obj[0]) * ord(obj[-1]) + ord(obj[1]) * ord(obj[-2]) + ord(obj[2]) * ord(obj[-3]) + ...
#     где obj — объект, преобразованный в строку с помощью функции str(). Обратите внимание, что суммироваться должны произведения первого и последнего элементов, второго и предпоследнего, и так далее до середины. Если obj имеет нечетное количество символов, то серединный элемент должен прибавляться без перемножения
#     вычисление значения выражения:
#     ord(obj[0]) * 1 - ord(obj[1]) * 2 + ord(obj[2]) * 3 - ord(obj[3]) * 4 + ...
#     где obj — объект, преобразованный в строку с помощью функции str()
#     вычисление значения выражения:
#     (temp1 * temp2) % 123456791
#     где temp1 — значение, полученное в первом шаге, temp2 — значение, полученное во втором шаге
# и возвращать значение, полученное в третьем шаге.
# ---------------------------------------------------------------
def hash_function(obj):
    
    if not isinstance(obj, str):
        obj = str(obj)
    
    # шаг 1
    if len(obj) % 2:
        # нечет
        l1 = obj[:len(obj)//2]
        middle_el = obj[len(obj)//2]
        l2 = reversed(obj[len(obj)//2 + 1:])
      
        res = [ord(i) * ord(j) for i, j in zip(l1, l2)]
        res.append(ord(middle_el))        
    else:
        # чет
        l1 = obj[:len(obj)//2]
        l2 = reversed(obj[len(obj)//2:])
           
        res = [ord(i) * ord(j) for i, j in zip(l1, l2)]    

    temp1 = sum(res) 

    #---------------------------------------------
    # шаг 2
    l3 = [(ord(elem) * index) * (-1)**(index + 1) for index, elem in enumerate(obj , 1)]        
    
    temp2 = sum(l3)    
       
    
    return (temp1 * temp2) % 123456791 

    
# ---------------------------------------------------------------

# ---------------------------------------------------------------


    
    
# Функция limited_hash() 🌶️
# Реализуйте функцию limited_hash(), которая принимает три аргумента в следующем порядке:
#     left — целое число
#     right — целое число
#     hash_function — хеш-функция, по умолчанию равняется встроенной функции hash()
# Функция должна возвращать новую функцию, которая принимает в качестве аргумента произвольный объект, вычисляет его хеш-значение с помощью функции hash_function(), преобразует его в число, принадлежащее диапазону [left; right], и возвращает полученный результат.
# Если вычисленное хеш-значение уже принадлежит диапазону [left; right], то функция должна возвращать его без преобразования. Если вычисленное хеш-значение равняется right + 1, то функция перед возвратом должна преобразовать его в left, если right + 2 — в left + 1, если right + 3 — в left + 2, и так далее. Аналогичные преобразования, но в другую сторону, должны выполняться для хеш-значений, которые меньше left. Преобразования должны выполняться циклично при очередном выходе из диапазона.
# Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую функцию limited_hash(), но не код, вызывающий ее.
# 722
# ---------------------------------------------------------------

def limited_hash(left, right, hash_function=hash):
    def wrapper(*args, **kwargs):
        
        return hash_function(*args, **kwargs)    
    
    return wrapper


hash_function = limited_hash(10, 15)

print(hash_function(9))
print(hash_function(8))
print(hash_function(4))
print(hash_function(3))
print(hash_function(2))
# ---------------------------------------------------------------

# ---------------------------------------------------------------


#
#
#
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс Point
#
# Реализуйте класс Point, описывающий точку в пространстве. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     x — координата точки по оси xx
#     y — координата точки по оси yy
#     z — координата точки по оси zz
# Экземпляр класса Point должен иметь следующее формальное строковое представление:
# Point(<координата x>, <координата y>, <координата z>)
# Также экземпляр класса Point должен быть итерируемым объектом, элементами которого являются его координаты по осям xx, yy и zz.
# ---------------------------------------------------------------

class Point:
    def __init__(self, x, y, z) -> None:
        self.x = x
        self.y = y
        self.z = z

    def __repr__(self) -> str:
        return f"Point({self.x}, {self.y}, {self.z})"

    def __iter__(self):
        yield from (self.x, self.y, self.z)





# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс DevelopmentTeam
# 962
# Реализуйте класс DevelopmentTeam, описывающий команду разработчиков двух уровней: junior (младший) и senior (старший). При создании экземпляра класс не должен принимать никаких аргументов.
# Класс DevelopmentTeam должен иметь два метода экземпляра:
#     add_junior() — метод, принимающий произвольное количество позиционных аргументов, каждый из которых является именем разработчика, и добавляющий их в число junior-разработчиков
#     add_senior() — метод, принимающий произвольное количество позиционных аргументов, каждый из которых является именем разработчика, и добавляющий их в число senior-разработчиков
# Экземпляр класса DevelopmentTeam должен быть итерируемым объектом, элементами которого сперва являются все его junior-разработчики, а затем — все senior-разработчики. Junior-разработчики должны быть представлены в виде кортежей:
# (<имя разработчика>, 'junior')
# в то время как senior-разработчики — в виде кортежей:
# (<имя разработчика>, 'senior')
# ---------------------------------------------------------------
class DevelopmentTeam:
    count_junior = []
    count_senior = []

    def add_junior(self, *args):                
        self.count_junior.extend([(arg, 'junior') for arg in args])
    
    def add_senior(self, *args):        
        self.count_senior.extend([(arg, 'senior') for arg in args])

    def __iter__(cls):
        yield from cls.count_junior
        yield from cls.count_senior


beegeek = DevelopmentTeam()

beegeek.add_junior('Timur')
beegeek.add_junior('Arthur', 'Valery')
beegeek.add_senior('Gvido')
print(*beegeek, sep='\n')
# ---------------------------------------------------------------
class DevelopmentTeam:
    def __init__(self):
        self._seniors = []
        self._juniors = []
        
    def add_junior(self, *juniors):
        self._juniors.extend(juniors)
        
    def add_senior(self, *seniors):
        self._seniors.extend(seniors)
        
    def __iter__(self):
        for junior in self._juniors:
            yield (junior, 'junior')
        for senior in self._seniors:
            yield (senior, 'senior')
# ---------------------------------------------------------------


# Класс AttrsIterator
#
# Реализуйте класс AttrsIterator. При создании экземпляра класс должен принимать один аргумент:
#     obj — произвольный объект
# Экземпляр класса AttrsIterator должен являться итератором, который генерирует все атрибуты объекта obj в виде кортежей из двух элементов, первый из которых представляет имя атрибута, второй — значение атрибута.
# Примечание 1. Порядок атрибутов при генерации должен совпадать с их порядком в словаре атрибутов __dict__.
# Примечание 2. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 3. Класс AttrsIterator должен удовлетворять протоколу итератора, то есть иметь методы __iter__() и __next__(). Реализация же протокола может быть произвольной.
# ---------------------------------------------------------------
# ---------------------------------------------------------------
class AttrsIterator:
    def __init__(self, obj):        
        self.iterator = iter(obj.__dict__.items())
        
    def __iter__(self): return self
    def __next__(self): return next(self.iterator)
# ---------------------------------------------------------------


# Класс SkipIterator
# 923
# Реализуйте класс SkipIterator. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     iterable — итерируемый объект
#     n — целое неотрицательное число
# Экземпляр класса SkipIterator должен являться итератором, который генерирует элементы итерируемого объекта iterable, пропуская по n элементов, а затем возбуждает исключение StopIteration.
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 2. Класс SkipIterator должен удовлетворять протоколу итератора, то есть иметь методы __iter__() и __next__(). Реализация же протокола может быть произвольной.
# ---------------------------------------------------------------
class SkipIterator:
    def __init__(self,iterable, n) -> None:
        self.iterable = iterable        
        self.cnt = 0
        
        def func_generator():                           
            for index, element in enumerate(self.iterable):
                 if index == self.cnt:
                    self.cnt += (n + 1)
                    yield element
        
        self.func_generator = func_generator()          



    def __iter__(self): return self    
    def __next__(self): return next(self.func_generator)
               
# -------тест----------------------              
skipiterator = SkipIterator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 1)   # пропускаем по одному элементу
print(*skipiterator)



# ---------------------------------
class SkipIterator:
    def __init__(self, iterable, n):
        self.obj = iter(iterable[::n + 1])
    
    def __iter__(self): return self
    def __next__(self): return next(self.obj)         
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс RandomLooper
# 931
# Реализуйте класс RandomLooper. При создании экземпляра класс должен принимать произвольное количество позиционных аргументов, каждый из которых является итерируемым объектом.
# Экземпляр класса RandomLooper должен являться итератором, который генерирует в случайном порядке все элементы всех итерируемых объектов, переданных в конструктор, а затем возбуждает исключение StopIteration.
# Примечание 1. Порядок элементов в возвращаемом итераторе необязательно должен совпадать с их порядком в тестовых данных.
# Примечание 2. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 3. Класс RandomLooper должен удовлетворять протоколу итератора, то есть иметь методы __iter__() и __next__(). Реализация же протокола может быть произвольной.
# ---------------------------------------------------------------
from random import shuffle

class RandomLooper:
    def __init__(self, *args) -> None:
        
        self.l1 = []
        for i in args:
            self.l1.extend(i)
        
        shuffle(self.l1)
        self.index = -1 

    def __iter__(self): return self

    def __next__(self):
        try:
            self.index += 1
            return self.l1[self.index]
        except IndexError:
            raise StopIteration   
# ---------------------------------------------------------------
from random import shuffle

class RandomLooper:
    def __init__(self, *args):
        self.data = [el for obj in args for el in obj]
        shuffle(self.data)
        self.iterable = iter(self.data)

    def __iter__(self): return self
    def __next__(self): return next(self.iterable)
# ---------------------------------------------------------------


# Класс Peekable 🌶️
# 856
# Реализуйте класс Peekable. При создании экземпляра класс должен принимать один аргумент:
#     iterable — итерируемый объект
# Экземпляр класса Peekable должен являться итератором, который генерирует элементы итерируемого объекта iterable в исходном порядке, а затем возбуждает исключение StopIteration.
# Класс Peekable должен иметь один метод экземпляра:
#     peek() — метод, возвращающий следующий элемент итератора аналогично функции next(), но при этом не сдвигающий итератор. Если итератор пуст, должно быть возбуждено исключение StopIteration. Также метод должен уметь принимать один необязательный аргумент default — объект, который будет возвращен вместо возбуждения исключения StopIteration, если итератор пуст
# ---------------------------------------------------------------
class Peekable:
    def __init__(self, iterable):
        self.iterator = iter(iterable)
        self.peeked = None

    def peek(self, default='дефаулт'):  # default='дефаулт', потому что если в метод peek() передать None то не пройдет проверку 4-й тест
        if self.peeked is None:
            try:
                self.peeked = next(self.iterator)
            except StopIteration:
                if default != 'дефаулт':
                    return default
                raise StopIteration
        return self.peeked

    def __iter__(self):
        return self

    def __next__(self):
        if self.peeked is not None:
            result = self.peeked
            self.peeked = None
        else:
            result = next(self.iterator)
        return result
# --------------решение через Ellipsis-----------------------------------------
from copy import copy


class Peekable:
    def __init__(self, iterable):
        self.iterable = iter(iterable)

    def peek(self, default=Ellipsis):
        iterable = copy(self.iterable)
        item = next(iterable, Ellipsis)
        if item is Ellipsis and default is Ellipsis:
            raise StopIteration
        if item is Ellipsis:
            return default
        return item

    def __iter__(self):
        return self

    def __next__(self):
        item = next(self.iterable, Ellipsis)
        if item is Ellipsis:
            raise StopIteration
        return item
# ---------------------------------------------------------------
class Peekable:
    def __init__(self, iterable):
        self.lst = list(iterable)
        self.iterator = iter(self.lst)
        self.index = 0
    
    def __iter__(self):
        return self
    
    def __next__(self):
        self.index += 1
        return next(self.iterator)
    
    def peek(self, default=StopIteration):
        if self.index < len(self.lst):
            return self.lst[self.index]
        else:
            if default == StopIteration:
                raise default
            else:
                return default
# ---------------------------------------------------------------
from typing import Iterable


class Empty:
    """Класс-заглушка. Описывает пустой кэш."""

    ...


class NoDefault:
    """Класс-заглушка. Описывает отсутствие значения по умолчанию"""

    ...


class Peekable:
    """Peekable"""

    def __init__(self, iterable: Iterable) -> None:
        self.__iter = iter(iterable)
        self.__cache = Empty()

    def __iter__(self):
        return self

    def __next__(self):
        """Возвращает следующее значение из итератора.
        Если есть значение в кэше, то возвращает его и обнуляет кэш"""

        # Если кэш не пустой...
        if not isinstance(self.__cache, Empty):
            # то взять из него значение и обнулить кэш,..
            _elem, self.__cache = self.__cache, Empty()
            # затем вернуть значение
            return _elem

        # Если кэш пуст, то вернуть следующее значение напрямую из итератора
        return next(self.__iter)

    def peek(self, default: object | None = NoDefault()):
        """Возвращает значение из итератора, не сдвигая его.
        Если итератор пуст, то возвращает значение по умолчанию, если задано"""

        # Если кэш пуст...
        if isinstance(self.__cache, Empty):
            # Пытаемся взять следующее значение,
            # положить его в кэш и вернуть
            try:
                self.__cache = next(self.__iter)
                return self.__cache

            # Если не получилось, то итератор пуст
            # И мы смотрим на значение по умолчанию
            except StopIteration as e:
                # Если заглушка, то значение не задано, райзим ошибку
                if isinstance(default, NoDefault):
                    raise StopIteration from e

                # Если не заглушка, то возвращаем значение по умолчанию
                return default

        # Если условия не срабатали, то кэш не пуст, берем оттуда
        return self.__cache
# ---------------------------------------------------------------
# ---------------------------------------------------------------
# ---------------------------------------------------------------

# Класс LoopTracker🌶️
# 
# Реализуйте класс LoopTracker. При создании экземпляра класс должен принимать один аргумент:
#     iterable — итерируемый объект
# Экземпляр класса LoopTracker должен являться итератором, который генерирует элементы итерируемого объекта iterable в исходном порядке, а затем возбуждает исключение StopIteration.
# Класс LoopTracker должен иметь четыре свойства:
#     accesses — свойство, доступное только для чтения, возвращающее количество элементов, сгенерированных итератором на данный момент
#     empty_accesses — свойство, доступное только для чтения, возвращающее количество попыток получить следующий элемент опустевшего итератора
#     first — свойство, доступное только для чтения, возвращающее первый элемент итератора и не сдвигающее его. Если итератор не имеет первого элемента, то есть создан на основе пустого итерируемого объекта, то должно быть возбуждено исключение AttributeError с текстом:
#     Исходный итерируемый объект пуст
#     last — свойство, доступное только для чтения, возвращающее последний элемент, сгенерированный итератором на данный момент. Если итератор еще не сгенерировал ни одного элемента, то должно быть возбуждено исключение AttributeError с текстом:
#     Последнего элемента нет
# Класс LoopTracker должен иметь один метод экземпляра:
#     is_empty() — метод, возвращающий True, если итератор опустошен, или False в противном случае
# ---------------------------------------------------------------
class LoopTracker:
    def __init__(self, iterable) -> None:
        self.iter1 = iter(iterable)
        self.iter2 = iter(iterable)
        
        self._accesses = 0            # количество элементов, сгенерированных итератором
        self._empty_accesses = 0      # количество попыток получить следующий элемент опустевшего итератора
        
        
        if iterable:                         # если не пустой iterable
            self._first = next(self.iter2)   # запоминаем первый элемент итератора                   
        else:
            self._first = AttributeError('Исходный итерируемый объект пуст')
        
        
        self._last = AttributeError('Последнего элемента нет')   # последнего элемента пока нет
        self.flag_empty = False                                  # флаг опустошения
        
    
    def __iter__(self): return self
    def __next__(self):
        try:
            next_elem = next(self.iter1)             
                        
            if next(self.iter2, "IteratorEmpty") == "IteratorEmpty":
                self.flag_empty = True                   
                
            
            self._accesses += 1          # количество элементов, сгенерированных итератором
            self._last = next_elem       # запоминаем текущий элемент итератора
            
            return next_elem 
        
        except StopIteration:           
            self._empty_accesses += 1    # количество попыток сгенерировать элементы у пустого итератора             
            
            
            raise StopIteration

    def is_empty(self) -> bool:
        """
        метод, возвращающий True, если итератор опустошен, или False в противном случае
        """

        return self.flag_empty


    @property
    def accesses(self):
        """
        свойство, доступное только для чтения, возвращающее количество элементов, сгенерированных итератором на данный момент
        """
        return self._accesses    
    
    
    @property    
    def empty_accesses(self):
        """
        свойство, доступное только для чтения, возвращающее количество попыток получить следующий элемент опустевшего итератора
        """
        return self._empty_accesses
    
    @property    
    def first(self):
        """
        свойство, доступное только для чтения, возвращающее первый элемент итератора и не сдвигающее его. Если итератор не имеет первого элемента, то есть создан на основе пустого итерируемого объекта, то должно быть возбуждено исключение AttributeError с текстом: Исходный итерируемый объект пуст
        """
        return self._first

    @property
    def last(self):
        """
        свойство, доступное только для чтения, возвращающее последний элемент, сгенерированный итератором на данный момент. Если итератор еще не сгенерировал ни одного элемента, то должно быть возбуждено исключение AttributeError с текстом: Последнего элемента нет
        """
        return self._last
# --------альтернативное решение---------------------------------------------
class LoopTracker:
    def __init__(self, iterable):
        self._iterable = iter(iterable)
        self._empty_accesses = self._accesses = 0
        self._is_empty = False
        try:
            self._nextvalue = self._first = next(self._iterable)
        except StopIteration:
            self._is_empty = True
        
    def __iter__(self):
        return self

    def __next__(self):
        if self._is_empty:
            self._empty_accesses += 1
            raise StopIteration
        self._curvalue = self._nextvalue
        self._accesses += 1
        try:
            self._nextvalue = next(self._iterable)
        except StopIteration:
            self._is_empty = True
        return self._curvalue

    @property
    def accesses(self):
        return self._accesses

    @property
    def empty_accesses(self):
        return self._empty_accesses

    @property
    def first(self):
        if hasattr(self, '_first'):
            return self._first
        raise AttributeError('Исходный итерируемый объект пуст')

    @property
    def last(self):
        if hasattr(self, '_curvalue'):
            return self._curvalue
        raise AttributeError('Последнего элемента нет')

    def is_empty(self):
        return self._is_empty
# ---------------------------------------------------------------


# Класс  ReversedSequence
# 938
# Реализуйте класс ReversedSequence, описывающий объект, который реализует доступ к элементам некоторой последовательности в обратном порядке. При создании экземпляра класс должен принимать один аргумент:
#     sequence — последовательность
# При передаче экземпляра класса ReversedSequence в функцию len() должна возвращаться его длина, представленная количеством элементов в исходной последовательности.
# Также экземпляр класса ReversedSequence должен быть итерируемым объектом, элементами которого являются элементы исходной последовательности в обратном порядке.
# Наконец, экземпляр класса ReversedSequence должен позволять получать значения элементов исходной последовательности с помощью индексов, при этом индексация должна производиться в обратном порядке, то есть по индексу 0 должен быть доступен последний элемент исходной последовательности, по индексу 1 — предпоследний элемент, по индексу 2 — предпредпоследний элемент, и так далее.
# Примечание 1. Гарантируется, что при доступе к элементам используются только неотрицательные индексы.
# Примечание 2. Экземпляр класса ReversedSequence должен зависеть от последовательности, на основе которой он был создан. Другими словами, если исходная последовательность изменится, то должен измениться и экземпляр класса ReversedSequence.
# ---------------------------------------------------------------
class ReversedSequence:
    def __init__(self, sequence) -> None:
        self.sequence = sequence

    def __len__(self):
        return len(self.sequence)

    def __getitem__(self, key):
        if not isinstance(key, int):
            raise TypeError('Индекс должен быть целым числом')
        if key < 0 or key >= len(self.sequence):
            raise IndexError('Неверный индекс')
        return self.sequence[-key-1]

    def __contains__(self, item):
        return item in self.sequence

    def __iter__(self):
        yield from reversed(self.sequence)

    def __reversed__(self):
        return self.sequence   
# ---------------------------------------------------------------
class ReversedSequence:
    def __init__(self, sequence):
        self.sequence = sequence
    
    def __len__(self):
        return len(self.sequence)
    
    def __getitem__(self, key):
        return self.sequence[::-1][key]
# ---------------------------------------------------------------
class ReversedSequence:
    def __init__(self, seq):
        self.seq = seq
        
    def __len__(self):
        return len(self.seq)
    
    def __getitem__(self, item):
        return self.seq[~item]
# ---------------------------------------------------------------


# Класс SparseArray
# 945
# Разреженный массив (список) — абстрактное представление обычного массива (списка), в котором данные представлены не непрерывно, а фрагментарно: большинство его элементов принимает одно и то же значение по умолчанию, обычно 0 или None. В разреженном массиве возможен доступ к неопределенным элементам, в этом случае массив вернет некоторое значение по умолчанию.
# Реализуйте класс SparseArray, описывающий разреженный массив. При создании экземпляра класс должен принимать один аргумент:
#     default — значение по умолчанию для неопределенных элементов разреженного массива
# Экземпляр класса SparseArray должен позволять получать и изменять значения своих элементов с помощью индексов. При попытке получить значение элемента по несуществующему индексу должно быть возвращено значение по умолчанию.
# Примечание 1. Гарантируется, что при доступе к элементам используются только неотрицательные индексы.
# ---------------------------------------------------------------

class SparseArray:
    def __init__(self, default) -> None:
        self.default = default
        self.collection = {}
        
        
    def __getitem__(self, key):     # определяет поведение при доступе к элементу, используя синтаксис self[key]
        self.collection.setdefault(key, self.default)        
        return self.collection[key]         
        
        
    def __setitem__(self, key, value):        
        self.collection[key] = value 
# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Класс CyclicList
# 942
# Реализуйте класс CyclicList, описывающий циклический список. При создании экземпляра класс должен принимать один аргумент:
#     iterable — итерируемый объект, определяющий начальный набор элементов циклического списка. Если не передан, начальный набор элементов считается пустым
# Класс CyclicList должен иметь два метода экземпляра:
#     append() — метод, принимающий в качестве аргумента произвольный объект и добавляющий его в конец циклического списка
#     pop() — метод, который принимает в качестве аргумента индекс элемента циклического списка, возвращает его значение и удаляет из циклического списка элемент с данным индексом. Если аргумент не передан, возвращаемым и удаляемым элементом считается последний элемент циклического списка 
# При передаче экземпляра класса CyclicList в функцию len() должно возвращаться количество элементов в нем.
# Также экземпляр класса CyclicList должен быть зацикленным итерируемым объектом. Другими словами, итерация по нему должна происходить бесконечно, и при каждом достижении его последнего элемента она должна начинаться сначала.
# Наконец, экземпляр класса CyclicList должен позволять получать значения своих элементов с помощью индексов, при этом индексы должны работать циклически. Например, в циклическом списке [1, 2, 3] элементом с индексом 4 должно являться число 2.
# Примечание 1. Гарантируется, что при доступе к элементам используются только неотрицательные индексы.
# Примечание 2. Экземпляр класса CyclicList не должен зависеть от итерируемого объекта, на основе которого он был создан. Другими словами, если исходный итерируемый объект изменится, то экземпляр класса CyclicList измениться  не должен.
# ---------------------------------------------------------------

from itertools import cycle

class CyclicList:
    def __init__(self, iterable=[]) -> None:
        self.iterable = iterable[:]

    def append(self, elem):
        """метод, принимающий в качестве аргумента произвольный объект и добавляющий его в конец циклического списка """
        self.iterable.append(elem)


    def pop(self, elem=-1):
        """метод, который принимает в качестве аргумента индекс элемента циклического списка, возвращает его значение и удаляет из циклического списка элемент с данным индексом. Если аргумент не передан, возвращаемым и удаляемым элементом считается последний элемент циклического списка  """
        return self.iterable.pop(elem)
    
    def __iter__(self):        
        while True:
            yield from self.iterable

    def __len__(self):
        return len(self.iterable)

    def __getitem__(self, key):
        
        if not isinstance(key, int):
            raise TypeError('Индекс должен быть целым числом')
        if key > len(self.iterable):
            key = key % len(self.iterable)
        return self.iterable[key]

    def __setitem__(self, key, value):        
        self.iterable[key] = value


#------тест--------
cyclic_list = CyclicList()
cyclic_list.append(1)

for index, elem in enumerate(cyclic_list):
    if index > 6:
        break
    print(elem, end=' ')
# ------преп----------------------------------------------------
from itertools import cycle


class CyclicList:
    def __init__(self, iterable=()):
        self._data = list(iterable) or []

    def append(self, item):
        self._data.append(item)

    def pop(self, index=None):
        if index is None:
            return self._data.pop()
        return self._data.pop(index)

    def __len__(self):
        return len(self._data)

    def __iter__(self):
        yield from cycle(self._data)

    def __getitem__(self, index):
        return self._data[index % len(self._data)]
# ---------------------------------------------------------------



# Класс SequenceZip
# 802
# Реализуйте класс SequenceZip. При создании экземпляра класс должен принимать произвольное количество позиционных аргументов, каждый из которых является последовательностью. Класс SequenceZip должен описывать последовательность, элементами которой являются элементы переданных в конструктор итерируемых объектов, объединенные в кортежи. Объединение должно происходить аналогично тому, как это делает функция zip().
# При передаче экземпляра класса SequenceZip в функцию len() должно возвращаться количество элементов в нем.
# Также экземпляр класса SequenceZip должен быть итерируемым объектом, то есть позволять перебирать свои элементы, например, с помощью цикла for.
# Наконец, экземпляр класса SequenceZip должен позволять получать значения своих элементов с помощью индексов.
# Примечание 1. Гарантируется, что при доступе к элементам используются только неотрицательные индексы.
# Примечание 2. Экземпляр класса SequenceZip не должен зависеть от последовательностей, на основе которых он был создан. Другими словами, если исходные последовательности изменятся, то экземпляр класса SequenceZip измениться  не должен.
# ---------------------------------------------------------------
class SequenceZip:
    
# ---------------------------------------------------------------

# ---------------------------------------------------------------



# 
# 
# 
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Функция print_file_content()
# 939
# Реализуйте функцию print_file_content(), которая принимает один аргумент:
#     filename — имя текстового файла
# Функция должна выводить содержимое файла с именем filename. Если файла с данным именем нет в папке с программой, функция должна вывести текст:
# # Файл не найден
# Примечание 1. Имя файла, передаваемого в функцию, уже содержит расширение.
# Примечание 2. При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------
def print_file_content(filename: str) -> None:
    """Функция выводит содержимое файла filename"""
    
    try:
        with open(filename, encoding='utf-8') as file:
            lines = (line.rstrip() for line in file if line)
            print(*lines, sep='\n')          
        
    except FileNotFoundError:
        print('Файл не найден')
# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Функция non_closed_files()
# 
# Реализуйте функцию non_closed_files(), которая принимает один аргумент:
#     files — список файловых объектов
# Функция должна возвращать список, элементами которого являются открытые файловые объекты из списка files.
# Примечание 1. Файловые объекты в возвращаемом функцией списке должны располагаться в своем исходном порядке.
# ---------------------------------------------------------------
def non_closed_files(files: list) -> list:
    """Функция возвращает список, элементами которого являются открытые файловые объекты из списка files"""

    return [file for file in files if not file.closed]       
# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Функция log_for()
# 921
# Лог-файл — это текстовый файл, в который автоматически записывается важная информация о работе системы или программы. Форматов лог-файла довольно много, однако в рамках этой задачи будем считать, что все лог-файлы имеют следующий единый формат:
# 2022-01-01 INFO: User logged in
# 2022-01-01 ERROR: Invalid input data
# 2022-01-01 WARNING: File not found
# 2022-01-02 INFO: User logged out
# 2022-01-03 INFO: User registered
# То есть каждая строка лог-файла описывает некоторое событие, которое характеризуется датой в формате YYYY-MM-DD, типом и кратким описанием.
# Реализуйте функцию log_for(), которая принимает два аргумента в следующем порядке:
#     logfile — имя лог-файла
#     date_str — строковая дата в формате YYYY-MM-DD
# Функция должна создавать текстовый файл с именем:
# log_for_<date_str>.txt
# и записывать в него все события из файла logfile, которые произошли в дату date_str. События должны записываться без указания даты, а также располагаться в своем исходном порядке.
# Примечание 1. Имя файла, передаваемого в функцию, уже содержит расширение.
# Примечание 2. При открытии файла используйте явное указание кодировки UTF-8.
# ---------------------------------------------------------------

def log_for(logfile: str, date_str: str) -> None:
    """Функция создаёт текстовый файл и записывает в него все события из файла logfile, которые произошли в дату date_str"""
    
    log_dates = {}

    with open(logfile, mode='r', encoding='utf-8') as file_object_read:
        for line in file_object_read:
            key, value = line[:10], line[11:].strip()            
            log_dates.setdefault(key, []).append(value)            
    
    
    with open(f'log_for_{date_str}.txt', mode='w', encoding='utf-8') as file_object_write:
        for event in log_dates[date_str]:
            print(event, file=file_object_write)
# -------преп--------------------------------------------------
def log_for(logfile, date_str):
    with (
        open(logfile, encoding='utf-8') as file_in,
        open(f'log_for_{date_str}.txt', 'w', encoding='utf-8') as file_out
    ):
        for line in file_in:
            d, *info = line.split()
            if d == date_str:
                print(' '.join(info), file=file_out)
# ---------------------------------------------------------------



# Иерархия классов 🛸
# 953
# С помощью наследования и приведенной ниже схемы постройте иерархию пустых классов, описывающих транспортные средства:
# ---------------------------------------------------------------
class Vehicle:
    pass

class LandVehicle(Vehicle):
    pass


class Car(LandVehicle):
    pass

class Motorcycle(LandVehicle):
    pass

class Bicycle(LandVehicle):
    pass



class WaterVehicle(Vehicle):
    pass




class AirVehicle(Vehicle):
    pass

class Propeller(AirVehicle):
    pass

class Jet(AirVehicle):
    pass
# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Иерархия классов 🔶
# 
# С помощью наследования и приведенной ниже схемы постройте иерархию пустых классов, описывающих геометрические фигуры:
# ---------------------------------------------------------------
class Shape:
    pass


class Polygon(Shape):
    pass

class Circle(Shape):
    pass


class Quadrilateral(Polygon):
    pass

class Triangle(Polygon):
    pass



class Parallelogram(Quadrilateral):
    pass
class IsoscelesTriangle(Triangle):
    pass
class EquilateralTriangle(Triangle):
    pass


class Rectangle(Parallelogram):
    pass

class Square(Rectangle):
    pass
# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Иерархия классов 🐍
# 949
# С помощью наследования и приведенной ниже схемы постройте иерархию классов, описывающих животных:
# Класс Animal должен иметь два метода экземпляра:
#     sleep() — пустой метод
#     eat()— пустой метод
# Класс Fish должен иметь один метод экземпляра:
#     swim()— пустой метод
# Класс Bird должен иметь один метод экземпляра:
#     lay_eggs()— пустой метод
# Класс FlyingBird должен иметь один метод экземпляра:
#     fly()— пустой метод
# ---------------------------------------------------------------
class Animal:
    def sleep(self):   # sleep = lambda self: None
        pass

    def eat(self):
        pass


class Fish(Animal):
    def swim(self):
        pass


class Bird(Animal):
    def lay_eggs(self):
        pass

class FlyingBird(Bird):
    def fly(self):
        pass   

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Классы User и PremiumUser
# 956
# Реализуйте класс User, описывающий пользователя некоторого интернет-ресурса. При создании экземпляра класс должен принимать один аргумент:
#     name — имя пользователя
# Класс User должен иметь один метод экземпляра:
#     skip_ads() — метод, всегда возвращающий False 
# Также реализуйте класс PremiumUser, наследника класса User, описывающий пользователя некоторого интернет-ресурса с премиум подпиской. Процесс создания экземпляра класса PremiumUser должен совпадать с процессом создания экземпляра класса User.
# Класс PremiumUser должен иметь один метод экземпляра:
#     skip_ads() — метод, всегда возвращающий True 
# ---------------------------------------------------------------
class User:
    def __init__(self, name) -> None:
        self.name = name

    def skip_ads(self):
        return False


class PremiumUser(User):
    def __init__(self, name):
        User.__init__(self, name)    # вызываем инициализатор родительского класса        
        
    def skip_ads(self):
        return True
# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Классы Validator и NumberValidator
# 951
# Реализуйте класс Validator, описывающий объект, проверяющий значение на корректность. При создании экземпляра класс должен принимать один аргумент:
#     obj — произвольный объект
# Класс Validator должен иметь один метод экземпляра:
#     is_valid() — пустой метод, всегда возвращающий значение None
# Также реализуйте класс NumberValidator, наследника класса Validator, описывающий объект, проверяющий значение на принадлежность типу int или float. Процесс создания экземпляра класса NumberValidator должен совпадать с процессом создания экземпляра класса Validator.
# Класс NumberValidator должен иметь один метод экземпляра:
#     is_valid() — метод, возвращающий True, если значение переданное в инициализатор принадлежит типу int или float, или False в противном случае
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------
class Validator:
    def __init__(self, obj) -> None:
        self.obj = obj

    def is_valid(self):
        return None


class NumberValidator(Validator):
    def __init__(self, obj):
        Validator.__init__(self, obj)           # вызываем инициализатор родительского класса
        self.obj = obj

    def is_valid(self):
        return isinstance(self.obj, (int, float))
# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Класс Counter и подклассы
# 
# 1. Реализуйте класс Counter, описывающий неотрицательный счетчик. При создании экземпляра класс должен принимать один аргумент:
#     start — начальное значение счетчика, по умолчанию равняется 0
# Экземпляр класса Counter должен иметь один атрибут:
#     value — текущее значение счетчика
# Класс Counter должен иметь два метода экземпляра:
#     inc() — метод, принимающий в качестве аргумента целое число и увеличивающий значение счетчика на это число. Если число не передано, метод должен увеличить значение счетчика на единицу
#     dec() — метод, принимающий в качестве аргумента целое число и уменьшающий значение счетчика на это число. Если число не передано, метод должен уменьшить значение счетчика на единицу. Значение счетчика считается равным 0, если при уменьшении оно становится отрицательным
# 2. Также реализуйте класс NonDecCounter, наследника класса Counter, описывающий счетчик, значение которого можно увеличивать, но нельзя уменьшать. Процесс создания экземпляра класса NonDecCounter должен совпадать с процессом создания экземпляра класса Counter.
# Экземпляр класса NonDecCounter должен иметь один атрибут:
#     value — текущее значение счетчика
# Класс NonDecCounter должен иметь один метод экземпляра:
#     dec() — пустой метод. Сигнатура метода должна совпадать с сигнатурой метода dec() класса Counter
# 3. Наконец, реализуйте класс LimitedCounter, наследника класса Counter, описывающий счетчик, значение которого можно увеличивать лишь до определенного числа. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     start — начальное значение счетчика, по умолчанию равняется 0
#     limit — максимально возможное значение счетчика, по умолчанию равняется 10
# Экземпляр класса LimitedCounter должен иметь один атрибут:
#     value — текущее значение счетчика
# Класс LimitedCounter должен иметь один метод экземпляра:
#     inc() — метод, принимающий в качестве аргумента целое число и увеличивающий значение счетчика на это число. Если число не передано, метод должен увеличить значение счетчика на единицу. При увеличении значения счетчика метод не должен превышать установленный лимит
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------
class Counter:
    def __init__(self, start=0) -> None:
        self.start = start
        self.value = start
    
    
    def inc(self, num=None):
        if num:
            self.value += num
        else:
            self.value += 1
    
    
    def dec(self, num=None):
        if num:
            self.value -= num
        else:            
            self.value -= 1

        if self.value < 0:
            self.value = 0


class NonDecCounter(Counter):
    def __init__(self, start=0) -> None:
        Counter.__init__(self, start=0)
        self.start = start
        self.value = start


    def dec(self, num=None):
        pass



class LimitedCounter(Counter):
    def __init__(self, start=0, limit=10) -> None:        
        self.start = start
        self.value = start
        self.limit = limit

    def inc(self, num=None):
        if num:
            self.value += num
        else:
            self.value += 1

        if self.value > self.limit:
            self.value = self.limit    
# ---------преп-------------------------------------------------
class Counter:
    def __init__(self, start=0):
        self.value = start

    def inc(self, n=1):
        self.value += n

    def dec(self, n=1):
        self.value = max(self.value - n, 0)


class NonDecCounter(Counter):
    def dec(self, n=1):
        return None


class LimitedCounter(Counter):
    def __init__(self, start=0, limit=10):
        Counter.__init__(self, start)
        self.limit = limit

    def inc(self, n=1):
        self.value = min(self.value + n, self.limit)
# ---------------------------------------------------------------



# 
# 
# 
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Классы BasicPlan и подклассы
# 
# 1. Реализуйте класс BasicPlan, описывающий подписку базового уровня на некотором онлайн-сервисе. При создании экземпляра класс не должен принимать никаких аргументов.

# Класс BasicPlan должен иметь семь атрибутов:

#     can_stream —  атрибут, имеющий значение True
#     can_download — атрибут, имеющий значение True
#     has_SD — атрибут, имеющий значение True
#     has_HD — атрибут, имеющий значение False
#      has_UHD — атрибут, имеющий значение False
#     num_of_devices — атрибут, имеющий значение 1
#     price — атрибут, имеющий значение 8.99$

# 2. Также реализуйте класс SilverPlan, наследника класса BasicPlan, описывающий подписку среднего уровня на некотором онлайн-сервисе. Процесс создания экземпляра класса SilverPlan должен совпадать с процессом создания экземпляра класса BasicPlan.

# Класс SilverPlan должен иметь семь атрибутов:

#     can_stream —  атрибут, имеющий значение True
#     can_download — атрибут, имеющий значение True
#     has_SD — атрибут, имеющий значение True
#     has_HD — атрибут, имеющий значение True
#      has_UHD — атрибут, имеющий значение False
#     num_of_devices — атрибут, имеющий значение 2
#     price — атрибут, имеющий значение 12.99$

# 3. Наконец, реализуйте класс GoldPlan, наследника класса BasicPlan, описывающий подписку высокого уровня на некотором онлайн-сервисе. Процесс создания экземпляра класса GoldPlan должен совпадать с процессом создания экземпляра класса BasicPlan.

# Класс GoldPlan должен иметь семь атрибутов:

#     can_stream —  атрибут, имеющий значение True
#     can_download — атрибут, имеющий значение True
#     has_SD — атрибут, имеющий значение True
#     has_HD — атрибут, имеющий значение True
#      has_UHD — атрибут, имеющий значение True
#     num_of_devices — атрибут, имеющий значение 4
#     price — атрибут, имеющий значение 15.99$

# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------
class BasicPlan:
    
    can_stream = True
    can_download = True
    has_SD = True
    has_HD = False
    has_UHD = False
    num_of_devices = 1
    price = '8.99$'

class SilverPlan(BasicPlan):
    # Процесс создания экземпляра класса SilverPlan должен совпадать с процессом создания экземпляра класса BasicPlan
    can_stream = True
    can_download = True
    has_SD = True
    has_HD = True
    has_UHD = False
    num_of_devices = 2
    price = '12.99$'

class GoldPlan(SilverPlan):
    
    can_stream = True
    can_download = True
    has_SD = True
    has_HD = True
    has_UHD = True
    num_of_devices = 4
    price = '15.99$'
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Классы WeatherWarning и WeatherWarningWithDate
# 950
# Реализуйте класс WeatherWarning, описывающий объект, предупреждающий о погодных изменениях. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс WeatherWarning должен иметь три метода экземпляра:
#     rain() — метод, выводящий текст:
#     Ожидаются сильные дожди и ливни с грозой
#     snow() — метод, выводящий текст:
#     Ожидается снег и усиление ветра
#     low_temperature() — метод, выводящий текст:
#     Ожидается сильное понижение температуры
# Также реализуйте класс WeatherWarningWithDate, наследника класса WeatherWarning, описывающий объект, предупреждающий о погодных изменениях с указанием даты. Процесс создания экземпляра класса WeatherWarningWithDate должен совпадать с процессом создания экземпляра класса WeatherWarning.
# Класс WeatherWarningWithDate должен иметь три метода экземпляра:
#     rain() — метод, принимающий в качестве аргумента дату (тип date) и выводящий текст:
#     <дата в формате DD.MM.YYYY>
#     Ожидаются сильные дожди и ливни с грозой
#     snow() — метод, принимающий в качестве аргумента дату (тип date) и выводящий текст:
#     <дата в формате DD.MM.YYYY>
#     Ожидается снег и усиление ветра
#     low_temperature() — метод, принимающий в качестве аргумента дату (тип date) и выводящий текст:
#     <дата в формате DD.MM.YYYY>
#     Ожидается сильное понижение температуры
# ---------------------------------------------------------------

from datetime import date

class WeatherWarning:
    def rain(self):
        print('Ожидаются сильные дожди и ливни с грозой')

    def snow(self):
        print('Ожидается снег и усиление ветра')

    def low_temperature(self):
        print('Ожидается сильное понижение температуры')


class WeatherWarningWithDate(WeatherWarning):
    def rain(self, date):
        print(date.strftime('%d.%m.%Y'))
        print('Ожидаются сильные дожди и ливни с грозой')

    def snow(self, date):
        print(date.strftime('%d.%m.%Y'))
        print('Ожидается снег и усиление ветра')

    def low_temperature(self, date):
        print(date.strftime('%d.%m.%Y'))
        print('Ожидается сильное понижение температуры')
# ---------------------------------------------------------------
from datetime import date


class WeatherWarning:
    @staticmethod
    def rain():
        print('Ожидаются сильные дожди и ливни с грозой')

    @staticmethod
    def snow():
        print('Ожидается снег и усиление ветра')

    @staticmethod
    def low_temperature():
        print('Ожидается сильное понижение температуры')


class WeatherWarningWithDate(WeatherWarning):
    def rain(self, d: date):
        print(d.strftime('%d.%m.%Y'))
        super().rain()

    def snow(self, d: date):
        print(d.strftime('%d.%m.%Y'))
        super().snow()

    def low_temperature(self, d: date):
        print(d.strftime('%d.%m.%Y'))
        super().low_temperature()
# ---------------------------------------------------------------

# Классы Triangle и EquilateralTriangle
# 966
# Реализуйте класс Triangle, описывающий треугольник. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     a — длина стороны треугольника
#     b — длина стороны треугольника
#     c — длина стороны треугольника
# Класс Triangle должен иметь один метод экземпляра:
#     perimeter() — метод, возвращающий периметр треугольника
# Также реализуйте класс EquilateralTriangle, наследника класса Triangle, описывающий равносторонний треугольник. При создании экземпляра класс должен принимать один аргумент:
#     side — длина стороны треугольника
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 2. Никаких ограничений касательно реализации классов нет, она может быть произвольной.
# ---------------------------------------------------------------
class Triangle:
    def __init__(self, a, b, c) -> None:
        self.perimetr = self.a, self.b, self.c = a, b, c
    
    def perimeter(self):
        return sum(self.perimetr)

class EquilateralTriangle(Triangle):
    def __init__(self, side) -> None:
        super().__init__(side, side, side)
        self.side = side
# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Класс Counter и DoubledCounter
# 954
# Вам доступен класс Counter, описывающий неотрицательный счетчик. При создании экземпляра класс принимает один аргумент:
#     start — начальное значение счетчика, по умолчанию равняется 0
# Экземпляр класса Counter имеет один атрибут:
#     value — текущее значение счетчика
# Класс Counter имеет два метода экземпляра:
#     inc() — метод, принимающий в качестве аргумента целое число и увеличивающий значение счетчика на это число. Если число не передано, метод увеличивает значение счетчика на единицу
#     dec() — метод, принимающий в качестве аргумента целое число и уменьшающий значение счетчика на это число. Если число не передано, метод уменьшает значение счетчика на единицу. Значение счетчика считается равным 0, если при уменьшении оно становится отрицательным
# Реализуйте класс DoubledCounter, наследника класса Counter, описывающий неотрицательный счетчик, значение которого увеличивается и уменьшается дважды при вызове соответствующих методов. Процесс создания экземпляра класса DoubledCounter должен совпадать с процессом создания экземпляра класса Counter.
# Экземпляр класса DoubledCounter должен иметь один атрибут:
#     value — текущее значение счетчика
# Класс DoubledCounter должен иметь два метода экземпляра:
#     inc() — метод, принимающий в качестве аргумента целое число и увеличивающий значение счетчика на это число дважды. Если число не передано, метод должен увеличить значение счетчика на два
#     dec() — метод, принимающий в качестве аргумента целое число и уменьшающий значение счетчика на это число дважды. Если число не передано, метод должен уменьшить значение счетчика на два. Значение счетчика считается равным 0, если при уменьшении оно становится отрицательным
# ---------------------------------------------------------------
class Counter:
    def __init__(self, start) -> None:
        self.value = self.start = start
        
    
    def inc(self, num=1):
        self.value += num

    def dec(self, num=1):
        self.value = max(self.value - num, 0)   # Если в функцию max передается два или более позиционных аргумента, возвращается самый большой из них.
    

class DoubledCounter(Counter):
    def __init__(self, start) -> None:   
        super().__init__(start)          # вызываем инициализатор родительского класса
                                        # Процесс создания экземпляра класса DoubledCounter должен совпадать с процессом создания экземпляра класса Counter.
        self.value = self.start = start
        

    def inc(self, num=1):
        self.value += 2*num

    def dec(self, num=1):
        self.value = max(self.value - 2*num, 0)   # Если в функцию max передается два или более позиционных аргумента, возвращается самый большой из них.
# ---------------------------------------------------------------
class Counter:
    def __init__(self, start=0):
        self.value = start

    def inc(self, n=1):
        self.value += n

    def dec(self, n=1):
        self.value = max(self.value - n, 0)


class DoubledCounter(Counter):
    def inc(self, n=1):
        super().inc(n * 2)

    def dec(self, n=1):
        super().dec(n * 2)
# ---------------------------------------------------------------


# Классы Summator и подклассы🌶️
# 923
# 1. Реализуйте класс Summator, описывающий объект, вычисляющий сумму натуральных чисел от 11 до nn:
# 1+2+3+...+nПри создании экземпляра класс не должен принимать никаких аргументов.
# Класс Summator должен иметь один метод экземпляра:
#     total() — метод, принимающий в качестве аргумента целое число n и возвращающий сумму целых чисел от 1 до n включительно
# 2. Помимо этого, реализуйте класс SquareSummator, наследника класса Summator, описывающий объект, вычисляющий сумму квадратов натуральных чисел от 11 до nn:
# 12+22+32+...+n2
# 12+22+32+...+n2Процесс создания экземпляра класса SquareSummator должен совпадать с процессом создания экземпляра класса Summator.
# Класс SquareSummator должен иметь один метод экземпляра:
#     total() — метод, принимающий в качестве аргумента целое число n и возвращающий сумму квадратов целых чисел от 1 до n включительно
# 3. Также реализуйте класс QubeSummator, наследника класса Summator, описывающий объект, вычисляющий сумму кубов натуральных чисел от 11 до nn:
# 13+23+33+...+n3
# 13+23+33+...+n3
# Процесс создания экземпляра класса QubeSummator должен совпадать с процессом создания экземпляра класса Summator.
# Класс QubeSummator должен иметь один метод экземпляра:
#     total() — метод, принимающий в качестве аргумента целое число n и возвращающий сумму кубов целых чисел от 1 до n включительно
# 4. Наконец, реализуйте класс CustomSummator, наследника класса Summator, описывающий объект, вычисляющий сумму произвольных степеней натуральных чисел от 11 до nn:
# 1m+2m+3m+...+nm
# При создании экземпляра класс должен принимать один аргумент:
#     m — степень чисел в последовательности
# Класс CustomSummator должен иметь один метод экземпляра:
#     total() — метод, принимающий в качестве аргумента целое число n и возвращающий сумму целых чисел в степени m от 1 до n включительно
# Примечание 1. Попытайтесь реализовать классы таким образом, чтобы метод total() был определен лишь в классе Summator.
# ---------------------------------------------------------------

from functools import reduce

class Summator:
    def total(self, n, power=1):
        return reduce(lambda x, y: x + y**power, range(1, n + 1))

class SquareSummator(Summator):
    def total(self, n, power=2):
        return super().total(n, power)
            
class QubeSummator(Summator):
    def total(self, n, power=3):
        return super().total(n, power)

class CustomSummator(Summator):
    def __init__(self, m):
        
        self.power = m        
        self.n = len(range(m))
        
    def total(self, n):        
        return super().total(n, self.power)


#---тест
summator1 = Summator()
summator2 = SquareSummator()
summator3 = QubeSummator()

print(summator1.total(3))    # 1 + 2 + 3
print(summator2.total(3))    # 1 + 4 + 9
print(summator3.total(3))    # 1 + 8 + 27

# ---------------------------------------------------------------
class Summator:
    def transform(self, n):
        return n
    
    def total(self, n):
        return sum(self.transform(i) for i in range(1, n + 1))
    
class SquareSummator(Summator):
    def transform(self, n):
        return n ** 2
    
class QubeSummator(Summator):
    def transform(self, n):
        return n ** 3
    
class CustomSummator(Summator):
    def __init__(self, power):
        self.power = power
    
    def transform(self, n):
        return n ** self.power
# ---------------------------------------------------------------


# Класс FieldTracker🌶️🌶️
# 
# Реализуйте класс FieldTracker, наследники которого получают возможность отслеживать состояние определенных атрибутов своих экземпляров класса. Дочерние классы должны наследовать четыре метода экземпляра:
#     base() — метод, принимающий в качестве аргумента имя атрибута и возвращающий либо текущее значение этого атрибута, либо исходное (указанное при определении) значение этого атрибута, если оно было изменено
#     has_changed() — метод, принимающий в качестве аргумента имя атрибута и возвращающий True, если значение этого атрибута было изменено хотя бы раз, или False в противном случае
#     changed() — метод, возвращающий словарь, в котором ключами являются имена атрибутов, которые изменяли свои значения, а значениями — их исходные значения
#     save() — метод, сбрасывающий отслеживание. После вызова метода считается, что все атрибуты ранее не изменяли свои значения, а их текущие значения считаются исходными

# Гарантируется, что наследники класса FieldTracker:

#     всегда имеют атрибут класса fields, содержащий кортеж с атрибутами, которые необходимо отслеживать
#     в своем инициализаторе всегда вызывают инициализатор класса FieldTracker после установки первичных значений отслеживаемым атрибутам
# ---------------------------------------------------------------
from typing import Any


class FieldTracker:
    def __init__(self) -> None:
        self.dict_attr = {name_attr: [value_attr] for name_attr, value_attr in self.__dict__.items()}     
        

    def __setattr__(self, name_attr: str, value_attr: Any) -> None:        
        if 'dict_attr' in self.__dict__:            
            self.dict_attr[name_attr].append(value_attr)     # добавляем измененное значение     
        self.__dict__[name_attr] = value_attr

                
    def base(self, name_attr: str) -> int:
        """метод, принимающий в качестве аргумента имя атрибута и возвращающий либо текущее значение этого атрибута, либо исходное (указанное при определении) значение этого атрибута, если оно было изменено"""
        if len(self.dict_attr[name_attr]) > 1:
            return self.dict_attr[name_attr][0]     # исходное (указанное при определении)
        return getattr(self, name_attr, None)       # текущее значение атрибута

    
    def has_changed(self, name_attr: str) -> bool:
        """метод, принимающий в качестве аргумента имя атрибута и возвращающий True, если значение этого атрибута было изменено хотя бы раз, или False в противном случае"""       
        return len(self.dict_attr[name_attr]) > 1

    
    def changed(self) -> dict:
        """метод, возвращающий словарь, в котором ключами являются имена атрибутов, которые изменяли свои значения, а значениями — их исходные значени"""
        dict_attr_changed = {}
        for name_attr, value_attr in self.dict_attr.items():
            if len(value_attr) > 1:
                dict_attr_changed.setdefault(name_attr, value_attr[0])

        return dict_attr_changed

    
    def save(self) -> None:
        """метод, сбрасывающий отслеживание. После вызова метода считается, что все атрибуты ранее не изменяли свои значения, а их текущие значения считаются исходными"""
        for value_attr in self.dict_attr.values():
            old_value = value_attr[0]  # сохраняем начальное значение атрибута 
            value_attr.clear()
            value_attr.append(old_value)



class Point(FieldTracker):
    fields = ('x', 'y', 'z')

    def __init__(self, x, y, z):
        self.x, self.y, self.z = x, y, z
        super().__init__()

point = Point(1, 2, 3)
point.x = 0
point.z = 4
point.save()

print(point.base('x'))
print(point.base('z'))
print(point.has_changed('x'))
print(point.has_changed('z'))
print(point.changed())


# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс UpperPrintString
# 
# Реализуйте класс UpperPrintString, наследника класса str, описывающий строку. Процесс создания экземпляра класса UpperPrintString должен совпадать с процессом создания экземпляра класса str.
# Экземпляр класса UpperPrintString должен иметь следующее неформальное строковое представление:
# <значение строки в верхнем регистре>
# ---------------------------------------------------------------
class UpperPrintString(str):
    def __init__(self, string1: str) -> None:
        self.string1 = string1
    
    def __str__(self):
        return self.string1.upper()

# ---------------------------------------------------------------
class UpperPrintString(str):
    def __str__(self):
        return self.upper()
# ---------------------------------------------------------------


# Класс LowerString
# 
# Реализуйте класс LowerString, наследника класса str, описывающий строку, которая во время создания автоматически переводится в нижний регистр. При создании экземпляра класс должен принимать один аргумент:
    # obj — объект, определяющий начальное значение строки. Может быть не передан, в таком случае начальное значение считается пустой строкой
# ---------------------------------------------------------------
class LowerString(str):
    def __new__(cls, string=''):
        instance = super().__new__(cls, str(string).lower())
        return instance

s1 = LowerString('BEEGEEK')
s2 = LowerString('BeeGeek')

print(s1)
print(s2)
print(s1 == s2)
print(issubclass(LowerString, str))

# ---------------------------------------------------------------
class LowerString(str):
    def __new__(cls, obj=''):
        obj = str(obj).lower()
        instance = super().__new__(cls, obj)
        return instance
# ---------------------------------------------------------------


# Класс FuzzyString
# 
# Реализуйте класс FuzzyString, наследника класса str, описывающий строку, которая при любых сравнениях (==, !=, >, <, >=, <=) и проверках на принадлежность (in, not in) не учитывает регистр. Процесс создания экземпляра класса FuzzyString должен совпадать с процессом создания экземпляра класса str.
# Примечание 1. Если объект, с которым выполняется операция сравнения, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# Примечание 2. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------

class FuzzyString(str):
    # В этой реализации мы наследуемся от класса str и переопределяем методы сравнения (__eq__, __ne__, __lt__, __gt__, __le__, __ge__) 
    # и метод __contains__ для проверки на принадлежность (in, not in). В каждом из этих методов мы сначала проверяем, является ли другой объект строкой (str). 
    # Если это так, мы выполняем сравнение или проверку на принадлежность, не учитывая регистр, с помощью метода lower(). 
    # Если объект другого типа, мы возвращаем NotImplemented, чтобы позволить Python попробовать другие способы сравнения или проверки на принадлежность.

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    # !!!!!!  @total_ordering  !!!!!
    # 
    # total_ordering не поможет не потому, что наследуемся от str, а потому, что он реализовывает отсутствующие методы сравнения.
    #  А все методы сравнения реализованы в классе str. Поэтому, если мы не сделаем этого сами, эти методы будут взять из класса str, 
    # а не реализованы с помощью @total_ordering. Это справедливо при наследовании от любого класса, у которого есть эти методы 
    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    def __eq__(self, other):
        if isinstance(other, str):
            return self.lower() == other.lower()
        return NotImplemented

    def __ne__(self, other):
        if isinstance(other, str):
            return self.lower() != other.lower()
        return NotImplemented

    def __lt__(self, other):
        if isinstance(other, str):
            return self.lower() < other.lower()
        return NotImplemented

    def __gt__(self, other):
        if isinstance(other, str):
            return self.lower() > other.lower()
        return NotImplemented

    def __le__(self, other):
        if isinstance(other, str):
            return self.lower() <= other.lower()
        return NotImplemented

    def __ge__(self, other):
        if isinstance(other, str):
            return self.lower() >= other.lower()
        return NotImplemented

    def __contains__(self, item):
        if isinstance(item, str):
            return item.lower() in self.lower()
        return NotImplemented
# ---------------------------------------------------------------



# Класс TitledText
# 902
# Реализуйте класс TitledText, наследника класса str, который описывает текст, имеющий заголовок. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     content — текст
#     text_title — заголовок текста
# Класс TitledText должен иметь один метод экземпляра:
#     title() — метод, возвращающий заголовок текста
# Примечание 1. Значением экземпляра класса TitledText должен быть именно текст, а не заголовок текста или текст вместе с заголовком.
# ---------------------------------------------------------------


#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# Процесс создания экземпляра класса Some_class должен совпадать с процессом создания экземпляра класса str
# Это значит, что либо метод __new__() вообще НЕ НУЖНО ПЕРЕОПРЕДЕЛЯТЬ, 
# ЛИБО НУЖНО ВЫЗЫВАТЬ В НЕМ МЕТОД РОДИТЕЛЬСКОГО КЛАССА, если нужно какие-то дополнительные атрибуты добавить, к примеру)
    
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



class TitledText(str):

    # В этом коде мы определяем класс TitledText, который наследуется от класса str. 
    # Мы переопределяем метод __new__, чтобы передать аргумент content в качестве аргумента базового класса str. Метод __init__ сохраняет значение text_title в переменной _title. Мы также добавляем метод title, который возвращает заголовок текста.
    # Вы можете создать экземпляр класса TitledText следующим образом:
    # text = TitledText("Текст статьи...", "Заголовок статьи")
    # print(text)  # Выводит: Текст статьи...
    # print(text.title())  # Выводит: Заголовок статьи

# В данном примере text является экземпляром класса TitledText, и он содержит только текст. Метод title() возвращает заголовок текста, который был передан при создании объекта.
        
    
    def __new__(cls, content, text_title):
        return super().__new__(cls, content)

    def __init__(self, content, text_title):
        self._title = text_title

    def title(self):
        return self._title

titled = TitledText('Сreate a class Soda', 'Homework')

print(titled)
print(titled.title())
print(issubclass(TitledText, str))   

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Класс SuperInt
# 846
# Реализуйте класс SuperInt, наследника класса int, описывающий целое число с дополнительным функционалом. Процесс создания экземпляра класса SuperInt должен совпадать с процессом создания экземпляра класса int.
# Класс SuperInt должен иметь четыре метода экземпляра:
#     repeat() — метод, принимающий в качестве аргумента целое число n, по умолчанию равное 2, и возвращающий экземпляр класса SuperInt, продублированный n раз
#     to_bin() — метод, возвращающий двоичное представление экземпляра класса SuperInt. Двоичное представление может быть как в виде экземпляра класса str, так и int
#     next() — метод, возвращающий новый экземпляр класса SuperInt, который больше текущего на единицу
#     prev() — метод, возвращающий новый экземпляр класса SuperInt, который меньше текущего на единицу
# Также экземпляр класса SuperInt должен быть итерируемым объектом, элементами которого являются его цифры слева направо. Сами цифры так же должны быть представлены в виде экземпляров класса SuperInt.
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------





#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

# Процесс создания экземпляра класса Some_class должен совпадать с процессом создания экземпляра класса str
# Это значит, что либо метод __new__() вообще НЕ НУЖНО ПЕРЕОПРЕДЕЛЯТЬ, 
# ЛИБО НУЖНО ВЫЗЫВАТЬ В НЕМ МЕТОД РОДИТЕЛЬСКОГО КЛАССА, если нужно какие-то дополнительные атрибуты добавить, к примеру)
    
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

class SuperInt(int):

    def repeat(self, n=2):
        if self >= 0:
            num = int(f'{self}' * n)
        else:
            num = -int(f'{abs(self)}' * n)
        return SuperInt(num)
    
    # или так можно реализовать метод
    
    # def repeat(self, n=2):
    #     digit = f"{'-' * (self < 0)}{f'{abs(self)}' * n}"
    #     return type(self)(digit)


    def to_bin(self):
        return f'{self:b}'    # Тип форматируемого объекта   (b - двоичный формат)

    def next(self):
        return SuperInt(self + 1)

    def prev(self):
        return SuperInt(self - 1)
    
    
    def __iter__(self):        
        it = map(SuperInt, str(abs(self)))        
        yield from it
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс RoundedInt
# 863
# Ближайшим четным числом для целого нечетного числа n будем считать n + 1, ближайшим четным числом для целого четного числа будет оно само. Аналогично ближайшим нечетным числом для целого четного числа n будем считать n + 1, ближайшим нечетным числом для целого нечетного числа будет оно само.
# Реализуйте класс RoundedInt, наследника класса int, описывающий целое число, которое во время создания автоматически округляется до ближайшего четного или нечетного числа. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     num — объект, определяющий числовое значение экземпляра класса RoundedInt
#     even — булево значение, определяющее четность при округлении. Если имеет значение True, округление происходит до ближайшего четного, если False — до ближайшего нечетного. По умолчанию имеет значение True
# ---------------------------------------------------------------
class RoundedInt(int):
    
    def __new__(cls, num, even=True):
        
        if even:
            num += even if num % 2 else 0
        else:
            num += 0 if num % 2 else 1
        
        instance = super().__new__(cls, num )
        return instance



print(RoundedInt(7))
print(RoundedInt(8))
print(RoundedInt(7, False))
print(RoundedInt(8, False))
# -------преп----------------------------------------------------
class RoundedInt(int):
    def __new__(cls, value, even=True, *args, **kwargs):
        value += (value % 2 == 1) if even else (value % 2 == 0)
        instance = super().__new__(cls, value)
        return instance
# ---------------------------------------------------------------
class RoundedInt(int):
    def __new__(cls, num, even=True):
        num = (num, num + 1)[num % 2 == even]
        return int.__new__(cls, num)
# ---------------------------------------------------------------

# Класс AdvancedTuple
# 805
# Реализуйте класс AdvancedTuple, наследника класса tuple, который описывает кортеж, умеющий выполнять операцию сложения (+, +=) не только с экземплярами классов AdvancedTuple и tuple, но и с любыми итерируемыми объектами. Процесс создания экземпляра класса AdvancedTuple должен совпадать с процессом создания экземпляра класса tuple.
# Примечание 1. Как бы ни выполнялось сложение, с помощью оператора + или +=, результатом операции должен являться новый экземпляр класса AdvancedTuple.
# ---------------------------------------------------------------
class AdvancedTuple(tuple):   
    
    def __init__(self, iterable) -> None:        
        self.iterable = tuple(iterable)

    
    def __add__(self, other):        
        if hasattr(other, '__iter__'):
            return AdvancedTuple(self.iterable + tuple(other))   
        return NotImplemented
    
        
    def __radd__(self, other):        
        return AdvancedTuple(tuple(other) + self.iterable)


    def __iadd__(self, other):       
        return self.__add__(other)
    

advancedtuple = AdvancedTuple([1, 2, 3])

print(advancedtuple + (4, 5))
print(advancedtuple + [4, 5])
print({'a': 1, 'b': 2} + advancedtuple)

# -------------преп--------------------------------------------
class AdvancedTuple(tuple):
    def __add__(self, other):
        if hasattr(other, '__iter__'):
            return AdvancedTuple(tuple(self) + tuple(other))
        return NotImplemented

    def __radd__(self, other):
        if hasattr(other, '__iter__'):
            return AdvancedTuple(tuple(other) + tuple(self))
        return NotImplemented

    def __iadd__(self, other):
        if hasattr(other, '__iter__'):
            return AdvancedTuple(tuple(self) + tuple(other))
        return NotImplemented
# ---------------------------------------------------------------


# Класс ModularTuple
# 852
# Реализуйте класс ModularTuple, наследника класса tuple, описывающий кортеж, элементы которого во время создания автоматически делятся с остатком на заданное число. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     iterable — итерируемый объект, определяющий начальный набор элементов экземпляра класса ModularTuple. Если не передан, начальный набор элементов считается пустым
#     size — целое число, на которое делятся с остатком все элементы создаваемого экземпляра класса ModularTuple, по умолчанию имеет значение 100
# Примечание 1. Экземпляр класса ModularTuple не должен зависеть от итерируемого объекта, на основе которого он был создан. Другими словами, если исходный итерируемый объект изменится, то экземпляр класса ModularTuple измениться  не должен.
# Примечание 2. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------
class ModularTuple(tuple):
    """All elements divide by number"""

    def __new__(cls, iterable=None, size=100):    # Наследование от встроенных классов ничем не отличается от наследования от собственных классов, то есть мы так же получаем все методы и атрибуты родительского класса
        if iterable:
            iterable1 = (i % size for i in iterable)       
            instance = super().__new__(cls, iterable1)        
            return instance
        return super().__new__(cls)

# ------тест---------------------------------------------------------
modulartuple = ModularTuple([1, 2, 3, 4, 5], 2)

print(modulartuple)
# -----преп-----------------------------------------------------
class ModularTuple(tuple):
    def __new__(cls, iterable, *args, size=100, **kwargs):              # Наследование от встроенных классов ничем не отличается от наследования от собственных классов, то есть мы так же получаем все методы и атрибуты родительского класса
        iterable = map(lambda item: item % size, iterable)
        instance = super().__new__(cls, iterable)
        return instance

# ---------------------------------------------------------------


# Класс DefaultList
# 
# Реализуйте класс DefaultList, наследника класса UserList, описывающий список, который при попытке получить элемент по несуществующему индексу возвращает значение по умолчанию. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     iterable — итерируемый объект, определяющий начальный набор элементов экземпляра класса DefaultList. Если не передан, начальный набор элементов считается пустым
#     default — значение, возвращаемое при попытке получить элемент по несуществующему индексу. По умолчанию равняется None
# Примечание 1. Экземпляр класса DefaultList не должен зависеть от итерируемого объекта, на основе которого он был создан. Другими словами, если исходный итерируемый объект изменится, то экземпляр класса DefaultList измениться  не должен.
# ---------------------------------------------------------------

from collections import UserList     # Класс UserList – это удобная обертка для обычного объекта list. 
                                     # Этот класс обеспечивает то же поведение, что list, 
                                     # с дополнительной возможностью предоставления доступа к базовому списку через атрибут экземпляра data.

class DefaultList(UserList):
    
    def __init__(self, iterable=[], default=None):
        super().__init__(item for item in iterable)
        self.default = default

    def __getitem__(self, index):
        if not (0 <= index < len(self.data)  or -len(self.data) <= index <= -1):  # доступа к базовому списку через атрибут экземпляра data
            return self.default
        return self.data[index]
    
    #def __setitem__(self, index, item):
    #    self.data[index] = str(item)
# ------------преп---------------------------------------------------
from collections import UserList


class DefaultList(UserList):
    """
    Класс DefaultList
    """

    def __init__(self, iterable=(), default=None):
        super().__init__(item for item in iterable)
        self._default = default

    def __getitem__(self, key):
        try:
            return super().__getitem__(key)
        except IndexError:
            return self._default
# ---------------------------------------------------------------



# Класс EasyDict
# 865
# Реализуйте класс EasyDict, наследника класса dict, описывающий словарь, значения элементов которого можно получать как по ключам ([key]), так и по одноименным атрибутам (.key). Процесс создания экземпляра класса EasyDict должен совпадать с процессом создания экземпляра класса dict.
# ---------------------------------------------------------------
class EasyDict(dict):
    """словарь, значения элементов которого можно получать как по ключам, так и по одноименным атрибутам"""


    def __init__(self, items, **kwargs):
        self.update(items)
        self.update(kwargs)
        for name_attr, value_attr in self.items():
            setattr(self, name_attr, value_attr)

      
    def __setitem__(self, key, value):
        setattr(self, key, value)
        super().__setitem__(key, value)

# ---------------------------------------------------------------
class EasyDict(dict):    
    __getattr__ = dict.__getitem__
# ---------------------------------------------------------------
class EasyDict(dict):
    def __getattr__(self, item):
        return self.get(item)
# ---------------------------------------------------------------
class EasyDict(dict):
    def __getattr__(self, item):
        return super().__getitem__(item)
# ---------------------------------------------------------------

# Класс TwoWayDict
# 857
# Реализуйте класс TwoWayDict, наследника класса UserDict, описывающий двунаправленный словарь, в который при добавлении пары ключ: значение также добавляется и пара значение: ключ. Процесс создания экземпляра класса TwoWayDict должен совпадать с процессом создания экземпляра класса UserDict.
# ---------------------------------------------------------------
from collections import UserDict
                # Класс UserDict – это удобная обертка для обычного объекта dict. Этот класс обеспечивает то же поведение, что и dict, с дополнительной возможностью предоставления доступа к базовому словарю через атрибут экземпляра data.
                
class TwoWayDict(UserDict):
    def __setitem__(self, key, value):        
        self.data.__setitem__(key, value)
        self.data.__setitem__(value, key)

# ---------преп---------------------------------------------------
from collections import UserDict

class TwoWayDict(UserDict):
    def __setitem__(self, key, value):
        self.data[key] = value
        self.data[value] = key
# ---------------------------------------------------------------



# Класс AdvancedList
# 
# Реализуйте класс AdvancedList, наследника класса list, описывающий список с дополнительным функционалом. Процесс создания экземпляра класса AdvancedList должен совпадать с процессом создания экземпляра класса list.
# Класс AdvancedList должен иметь три метода экземпляра:
#     join() — метод, объединяющий все элементы экземпляра класса AdvancedList в строку и возвращающий полученный результат. Метод должен принимать один строковый аргумент, по умолчанию равный пробелу, который является разделителем элементов списка в результирующей строке
#     map() — метод, принимающий в качестве аргумента функцию func и применяющий ее к каждому элементу экземпляра класса AdvancedList. Метод должен изменять исходный экземпляр класса AdvancedList, а не возвращать новый
#     filter() — метод, принимающий в качестве аргумента функцию func и удаляющий из экземпляра класса AdvancedList те элементы, для которых функция func вернула значение False. Метод должен изменять исходный экземпляр класса AdvancedList, а не возвращать новый
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 2. Никаких ограничений касательно реализации класса AdvancedList нет, она может быть произвольной.
# ---------------------------------------------------------------

from collections import UserList

class AdvancedList(UserList):
    def join(self, separator=' '):
        return f'{separator}'.join(str(i) for i in self)

    def map(self, func):
        for i in range(len(self.data)):
            i = super().__setitem__(i, func(self.data[i]))

    def filter(self, func):
        for i in range(-len(self.data), 0):  # удаляем (с конца списка к началу)
            if not func(self.data[i]):
                    self.data.pop(i)
# ---------------------------------------------------------------
class AdvancedList(list):

    def join(self, sep=' '):
        return sep.join(map(str, self))

    def map(self, func):
        self[:] = [func(i) for i in self]
        
    def filter(self, func):
        self[:] = [i for i in self if func(i)]
# ---------------------------------------------------------------
# ---------------------------------------------------------------



# Класс NumberList
#
# Реализуйте класс NumberList, наследника класса UserList, описывающий список, элементами которого могут быть лишь числа. При создании экземпляра класс должен принимать один аргумент:
#     iterable — итерируемый объект, определяющий начальный набор элементов экземпляра класса NumberList. Если хотя бы один элемент переданного итерируемого объекта не является числом, должно быть возбуждено исключение TypeError с текстом:
#     Элементами экземпляра класса NumberList должны быть числа
#     Итерируемый объект может быть не передан, в таком случае начальный набор элементов считается пустым
# При изменении экземпляра класса NumberList с помощью индексов, операций сложения (+, +=) и методов append(), extend() и insert() должна производиться проверка на то, что добавляемые элементы являются числами, в противном случае должно возбуждаться исключение TypeError с текстом:
# Элементами экземпляра класса NumberList должны быть числа
# Примечание 1. Числами будем считать экземпляры классов int и float.
# Примечание 2. Экземпляр класса NumberList не должен зависеть от итерируемого объекта, на основе которого он был создан. Другими словами, если исходный итерируемый объект изменится, то экземпляр класса NumberList измениться  не должен.
# ---------------------------------------------------------------
from collections import UserList

class NumberList(UserList):
    def __init__(self, iterable=None):
        super().__init__()
        if iterable is not None:
            self._check_elements(iterable)
            self.data = list(iterable)

    def _check_elements(self, iterable):
        if not all(isinstance(item, (int, float)) for item in iterable):
            raise TypeError("Элементами экземпляра класса NumberList должны быть числа")

    def __setitem__(self, key, value):
        self._check_elements([value])
        super().__setitem__(key, value)

    def __add__(self, other):
        self._check_elements(other)
        return super().__add__(other)

    def __iadd__(self, other):
        self._check_elements(other)
        return super().__iadd__(other)

    def append(self, item):
        self._check_elements([item])
        super().append(item)

    def extend(self, iterable):
        self._check_elements(iterable)
        super().extend(iterable)

    def insert(self, index, item):
        self._check_elements([item])
        super().insert(index, item)    

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Класс ValueDict
# 833
# Реализуйте класс ValueDict, наследника класса dict, описывающий словарь c дополнительным функционалом. Процесс создания экземпляра класса ValueDict должен совпадать с процессом создания экземпляра класса dict.
# Класс ValueDict должен иметь два метода экземпляра:
#     key_of() — метод, принимающий в качестве аргумента объект value и возвращающий первый ключ экземпляра класса ValueDict, имеющий значение value. Если такого ключа нет, метод должен вернуть None.
#     keys_of() — метод, принимающий в качестве аргумента объект value и возвращающий итерируемый объект, элементами которого являются все ключи экземпляра класса ValueDict, имеющие значение value
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------
class ValueDict(dict):
    def key_of(self, value=None):
        if value in self.values():            
            for key, val in self.items():
                if val == value:
                    return key     
            
        
    def keys_of(self, value):
        l1 = [key_self for key_self, value_self in self.items() if value_self == value]
        return l1
#--------
data = {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8, 'i': 9, 'j': 10, 'k': 11, 'l': 12, 'm': 13,
        'n': 14, 'o': 15, 'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20, 'u': 21, 'v': 22, 'w': 23, 'x': 24, 'y': 25,
        'z': 26, 'A': 1, 'B': 2, 'C': 3, 'D': 4, 'E': 5, 'F': 6, 'G': 7, 'H': 8, 'I': 9, 'J': 10, 'K': 11, 'L': 12,
        'M': 13, 'N': 14, 'O': 15, 'P': 16, 'Q': 17, 'R': 18, 'S': 19, 'T': 20, 'U': 21, 'V': 22, 'W': 23, 'X': 24,
        'Y': 25, 'Z': 26}


valuedict = ValueDict(data)

print(valuedict.key_of(21))
print(*valuedict.keys_of(17))

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Класс BirthdayDict
# 824
# Реализуйте класс BirthdayDict, наследника класса UserDict, описывающий словарь с информацией о днях рождения, ключами в котором являются имена, а значениями — даты дней рождения. Процесс создания экземпляра класса BirthdayDict должен совпадать с процессом создания экземпляра класса UserDict.
# При добавлении новой пары ключ: значение в экземпляр класса BirthdayDict должна производиться проверка на наличие в этом экземпляре пары, которая имеет такое же значение, что и добавляемая пара. И если такая пара есть, должен выводиться текст:
# Хей, <ключ добавляемой пары>, не только ты празднуешь день рождения в этот день!
# Аналогичное поведение должно быть и при изменении значения по ключу.
# ---------------------------------------------------------------
from collections import UserDict


class BirthdayDict(UserDict):
    def __setitem__(self, key, value):
        if value in self.data.values():
            print(f'Хей, {key}, не только ты празднуешь день рождения в этот день!')           
        
        self.data.__setitem__(key, value)


# ----тест -----------
from datetime import date

birthdaydict = BirthdayDict()

birthdaydict['Боб'] = date(1987, 6, 15)
birthdaydict['Том'] = date(1984, 7, 15)
birthdaydict['Мария'] = date(1987, 6, 15)

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Класс MutableString
# 798
# Реализуйте класс MutableString, наследника класса UserString, описывающий изменяемую строку. Процесс создания экземпляра класса MutableString должен совпадать с процессом создания экземпляра класса UserString.
# Класс MutableString должен иметь три метода экземпляра:
#     lower() — метод, переводящий все символы изменяемой строки в нижний регистр
#     upper() — метод, переводящий все символы изменяемой строки в верхний регистр
#     sort() — метод, сортирующий символы изменяемой строки. Может принимать два необязательных именованных аргумента key и reverse, выполняющих ту же задачу, что и в функции sorted()
# Экземпляр класса MutableString должен позволять получать, изменять и удалять значения своих элементов с помощью индексов, причем как положительных, так и отрицательных.
# ---------------------------------------------------------------
from collections import UserString

class MutableString(UserString):
    def lower(self):
        self.data = ''.join([i.lower() for i in self.data])         
        return self.data  # везде работаем с self.data
    
    def upper(self):
        self.data = ''.join([i.upper() for i in self.data])         
        return self.data

    def sort(self, key=None, reverse=False): 
        self.data = ''.join(sorted(list(self.data), key=key, reverse=reverse))
        return self.data

    def __delitem__(self, key):
        tmp = self._set_or_del(key)
        self.data = ''.join(tmp)

    def __setitem__(self, key, value):
        tmp = self._set_or_del(key, value)
        self.data = ''.join(tmp)

    def __getitem__(self, key):
        return MutableString(self._string[key])
    
    def _set_or_del(self, key, value=None):
        """метод _set_or_del(), в котором и осуществляется либо удаление, либо установка значения по индексу или срезу"""
        tmp = list(self.data)
        if value:
            tmp[key] = value
        else:
            del tmp[key]
        return tmp

# см. решение задачи ниже 
# https://stepik.org/lesson/805785/step/18?thread=solutions&unit=816644

    
# -----преп----------------------------------------------------
from collections import UserString


class MutableString(UserString):
    def __setitem__(self, index, value):
        data_as_list = list(self.data)
        data_as_list[index] = value
        self.data = "".join(data_as_list)

    def __delitem__(self, index):
        data_as_list = list(self.data)
        del data_as_list[index]
        self.data = "".join(data_as_list)

    def upper(self):
        self.data = self.data.upper()

    def lower(self):
        self.data = self.data.lower()

    def sort(self, key=None, reverse=False):
        self.data = "".join(sorted(self.data, key=key, reverse=reverse))
# ---------------------------------------------------------------


# Классы Average, Median и Harmonic
# 889
# Вам доступны классы Average, Median и Harmonic, имеющие сходный интерфейс. Все три класса используются для обработки пользовательских оценок и оценок критиков некоторого медиаконтента по стобалльной шкале и вычисления средних значений этих оценок. Задачей класса Average является нахождение среднего арифметического пользовательских оценок или оценок критиков, классов Median и Harmonic — медианы и среднего гармонического соответственно.
# Изучите приведенные классы, реализуйте абстрактный базовый класс Middle и постройте корректную схему наследования. При выполнении старайтесь избегать дублирования кода.
# Примечание 1. Функционал классов Average, Median и Harmonic должен остаться прежним, необходимо лишь объединить их в иерархию, определив для них единый базовый абстрактный класс Middle.
# ---------------------------------------------------------------
from abc import ABC, abstractmethod

class Middle(ABC):
    def __init__(self, user_votes, expert_votes):
        self.user_votes = user_votes                   # пользовательские оценки
        self.expert_votes = expert_votes 
    
    
    def get_correct_user_votes(self):
        """Возвращает нормализованный список пользовательских оценок
        без слишком низких и слишком высоких значений"""
        return [vote for vote in self.user_votes if 10 < vote < 90]
    
   
    def get_correct_expert_votes(self):
        """Возвращает нормализованный список оценок критиков
        без слишком низких и слишком высоких значений"""
        return [vote for vote in self.expert_votes if 5 < vote < 95]

    @abstractmethod
    def get_average(self, users=True):
        """Возвращает среднее арифметическое пользовательских оценок или
        оценок критиков в зависимости от значения параметра users"""
        

class Average(Middle):    
    def get_average(self, users=True):        
        if users:
            votes = self.get_correct_user_votes()
        else:
            votes = self.get_correct_expert_votes()

        return sum(votes) / len(votes)

class Median(Middle):   
    def get_average(self, users=True):        
        if users:
            votes = sorted(self.get_correct_user_votes())
        else:
            votes = sorted(self.get_correct_expert_votes())

        return votes[len(votes) // 2]

class Harmonic(Middle):    
    def get_average(self, users=True):        
        if users:
            votes = self.get_correct_user_votes()
        else:
            votes = self.get_correct_expert_votes()

        return len(votes) / sum(map(lambda vote: 1 / vote, votes))


# ---------------------------------------------------------------
from abc import ABC, abstractmethod


class Middle(ABC):
    
    def __init__(self, user_votes, expert_votes):
        self.user_votes = user_votes  # пользовательские оценки
        self.expert_votes = expert_votes  # оценки критиков

    def get_correct_user_votes(self):
        """Возвращает нормализованный список пользовательских оценок
        без слишком низких и слишком высоких значений"""
        return [vote for vote in self.user_votes if 10 < vote < 90]

    def get_correct_expert_votes(self):
        """Возвращает нормализованный список оценок критиков
        без слишком низких и слишком высоких значений"""
        return [vote for vote in self.expert_votes if 5 < vote < 95]

    @abstractmethod
    def get_average(self, users=True):
        """Возвращает среднее арифметическое пользовательских оценок или
        оценок критиков в зависимости от значения параметра users"""
        if users:
            votes = self.get_correct_user_votes()
        else:
            votes = self.get_correct_expert_votes()
        return votes


class Average(Middle):
    def get_average(self, users=True):
        votes = super().get_average(users)
        return sum(votes) / len(votes)


class Median(Middle):
    def get_average(self, users=True):
        votes = sorted(super().get_average(users))
        return votes[len(votes) // 2]


class Harmonic(Middle):
    def get_average(self, users=True):
        votes = super().get_average(users)
        return len(votes) / sum(map(lambda vote: 1 / vote, votes))
# ---------------------------------------------------------------


# Классы ChessPiece, King и Knight
# 756
# 1. Реализуйте абстрактный класс ChessPiece, описывающий шахматную фигуру. Инициализатор класса должен принимать два аргумента в следующем порядке:
#     horizontal — координата фигуры по горизонтали, представленная латинской буквой от a до h
#     vertical — координата фигуры по вертикали, представленная целым числом от 1 до 8 включительно
# Класс ChessPiece должен иметь один метод экземпляра:
#     can_move() — пустой абстрактный метод

# 2. Также реализуйте класс King, наследника класса ChessPiece, описывающий шахматного короля. Процесс создания экземпляра класса King должен совпадать с процессом создания экземпляра класса ChessPiece.
# Класс King должен иметь один метод экземпляра:
#     can_move() — метод, принимающий в качестве аргументов шахматные координаты по горизонтали и вертикали и возвращающий True, если фигура может переместиться по указанным координатам, или False в противном случае
# Экземпляр класса King  должен иметь два атрибута:
#     horizontal — координата фигуры по горизонтали, представленная латинской буквой от a до h
#     vertical — координата фигуры по вертикали, представленная целым числом от 1 до 8 включительно

# 3. Наконец, реализуйте класс Knight, наследника класса ChessPiece, описывающий шахматного коня. Процесс создания экземпляра класса Knight должен совпадать с процессом создания экземпляра класса ChessPiece.
# Класс Knight должен иметь один метод экземпляра:
#     can_move() — переопределенный родительский метод, принимающий в качестве аргументов координаты по горизонтали и вертикали и возвращающий True, если фигура может переместиться по указанным координатам, и False в противном случае
# Экземпляр класса Knight  должен иметь два атрибута:
#     horizontal — координата фигуры по горизонтали, представленная латинской буквой от a до h
#     vertical — координата фигуры по вертикали, представленная целым числом от 1 до 8 включительно
# ---------------------------------------------------------------
from abc import ABC, abstractmethod

class ChessPiece(ABC):
    def __init__(self, horizontal, vertical) -> None:
        self.horizontal = horizontal
        self.vertical = vertical

    @abstractmethod
    def can_move():
        """метод, принимающий в качестве аргументов шахматные координаты по горизонтали и вертикали
         и возвращающий True, если фигура может переместиться по указанным координатам, 
                    или False в противном случае"""


class King(ChessPiece):
    def can_move(self, horizontal, vertical):
        
        x1 = ord(self.horizontal) - 96
        x2 = ord(horizontal) - 96

        y1 = self.vertical
        y2 = vertical

        if x1 == x2 and y1 == y2:   # проверка на то что это не таже самая клетка (т.е сделан ход или нет)
            return False
        return abs(x1 - x2) <= 1 and abs(y1 - y2) <= 1
        

class Knight(ChessPiece):
    def can_move(self, horizontal, vertical):
        
        x1 = ord(self.horizontal) - 96
        x2 = ord(horizontal) - 96

        y1 = self.vertical
        y2 = vertical

        if x1 == x2 and y1 == y2:   # проверка на то что это не таже самая клетка (т.е сделан ход или нет)    
            return False        
        return abs((x1 - x2) * (y1 - y2)) == 2


king = King('e', 3)

print(king.can_move('e', 3))
print(king.can_move('e', 4))
print(king.can_move('b', 1))


# Ход ладьи:
# x1 == x2 or y1 == y2

# Ход коня:
# abs((x1 - x2) * (y1 - y2)) == 2

# Ход слона:
# abs(x1 - x2) == abs(y1 - y2)

# Ход ферзя (слон or ладья):
# abs(x1 - x2) == abs(y1 - y2) or x1 == x2 or y1 == y2

# Ход короля:
# abs(x1 - x2) <= 1 and abs(y1 - y2) <= 1


# -----------преп------------------------------------------------
from abc import ABC, abstractmethod


class ChessPiece(ABC):
    def __init__(self, horizontal, vertical):
        self.horizontal = horizontal
        self.vertical = vertical

    @abstractmethod
    def can_move(self, horizontal, vertical):
        pass


class King(ChessPiece):
    def can_move(self, horizontal, vertical):
        can = abs(ord(horizontal) - ord(self.horizontal)) + abs(vertical - self.vertical)
        return all(
            (
                abs(ord(horizontal) - ord(self.horizontal)) <= 1,
                abs(vertical - self.vertical) <= 1,
                can in (1, 2)
            )
        )


class Knight(ChessPiece):
    def can_move(self, horizontal, vertical):
        return (ord(self.horizontal) - ord(horizontal)) ** 2 + (self.vertical - vertical) ** 2 == 5


# ---------------------------------------------------------------


# Классы Validator, Number и String
# 
# 1. Реализуйте абстрактный класс Validator, описывающий дескриптор, который проверяет, что устанавливаемое или изменяемое значение является корректным. При создании экземпляра класс не должен принимать никаких аргументов.
# Дескриптор должен закрепляться за атрибутом, имеющим то же имя, что и переменная, которой присваивается дескриптор.
# При обращении к атрибуту дескриптор должен возвращать значение этого атрибута, если оно установлено. Если значение атрибута не установлено, должно быть возбуждено исключение AttributeError с текстом:
# Атрибут не найден
# При установке или изменении значения атрибута дескриптор должен сперва проверять его на корректность с помощью метода validate().
# Класс Validator должен иметь один абстрактный метод экземпляра:
#     validate() — пустой метод

# 2. Также реализуйте класс Number, наследника класса Validator, описывающий дескриптор, который проверяет, что устанавливаемое или изменяемое значение является числом из определенного диапазона. Дескриптор должен закрепляться за атрибутом, имеющим то же имя, что и переменная, которой присваивается дескриптор. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     minvalue — левая граница диапазона, по умолчанию имеет значение None и не ограничивает число слева
#     maxvalue — правая граница диапазона, по умолчанию имеет значение None и не ограничивает число справа
# Класс Number должен иметь один метод экземпляра:
#     validate() — метод, принимающий в качестве аргумента произвольный объект и возбуждающий исключение, если он не удовлетворяет каким-либо условиям. Если указанный объект не принадлежит типу int или float, должно быть возбуждено исключение TypeError с текстом:
#     Устанавливаемое значение должно быть числом
#     Если указанный объект является числом меньше minvalue, должно быть возбуждено исключение ValueError с текстом:
#     Устанавливаемое число должно быть больше или равно <minvalue>
#     Если указанный объект является числом больше maxvalue, должно быть возбуждено исключение ValueError с текстом:
#     Устанавливаемое число должно быть меньше или равно <maxvalue>

# 3. Наконец, реализуйте класс String, наследника класса Validator, описывающий дескриптор, который проверяет, что устанавливаемое или изменяемое значение является строкой определенной длины. Дескриптор должен закрепляться за атрибутом, имеющим то же имя, что и переменная, которой присваивается дескриптор. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     minsize — минимальная длина слова, по умолчанию имеет значение None и не ограничивает минимальную длину
#     maxsize — максимальная длина слова, по умолчанию имеет значение None и не ограничивает максимальную длину
#     predicate — функция-предикат для дополнительной валидации, по умолчанию имеет значение None и не используется
# Класс String должен иметь один метод экземпляра:
#     validate() — метод, принимающий в качестве аргумента произвольный объект и возбуждающий исключение, если он не удовлетворяет каким-либо условиям. Если указанный объект не принадлежит типу str, метод должен возбуждать исключение TypeError с сообщением:
#     Устанавливаемое значение должно быть строкой
#     Если указанный объект является строкой с длиной меньше minsize, должно быть возбуждено исключение ValueError с текстом:
#     Длина устанавливаемой строки должна быть больше или равна <minsize>
#     Если указанный объект является строкой с длиной больше maxsize, должно быть возбуждено исключение ValueError с текстом:
#     Длина устанавливаемой строки должна быть меньше или равна <maxsize>
#     Если указанный объект при передаче в функцию predicate() возвращает False, должно быть возбуждено исключение ValueError с текстом:
#     Устанавливаемая строка не удовлетворяет дополнительным условиям

# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованные классы используется только с корректными данными.
# Примечание 2. Никаких ограничений касательно реализации классов нет, она может быть произвольной.
# ---------------------------------------------------------------
# from abc import ABC, abstractmethod

# class Validator(ABC):





# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Функции is_iterator() и is_iterable()
# 
# 1. Реализуйте функцию is_iterable(), которая принимает один аргумент:
#     obj — произвольный объект
# Функция должна возвращать True, если объект obj является итерируемым объектом, или False в противном случае.
# 2. Также реализуйте функцию is_iterator(), которая принимает один аргумент:
#     obj — произвольный объект
# Функция должна возвращать True, если объект obj является итератором, или False в противном случае.
# ---------------------------------------------------------------

def is_iterable(obj):    
    try:
        iter(obj)
        return True
    except TypeError:
        return False

def is_iterator(obj):    
    try:
        next(obj)
        return True
    except TypeError:
        return False


print(is_iterable(123))
print(is_iterable([1, 2, 3]))
print(is_iterable((1, 2, 3)))
print(is_iterable('123'))
print(is_iterable(iter('123')))
print(is_iterable(map(int, '123')))
# ---------------------------------------------------------------



from collections.abc import Iterator, Iterable


def is_iterable(obj):
    return isinstance(obj, Iterable)


def is_iterator(obj):
    return isinstance(obj, Iterator)
# ---------------------------------------------------------------



# Класс CustomRange
# 804
# Назовем диапазоном запись двух целых неотрицательных чисел через дефис a-b, где a — левая граница диапазона, b — правая граница диапазона, причем a <= b. Диапазон содержит в себе все числа от a до b включительно. Например, диапазон 1-4 содержит числа 1, 2, 3 и 4.
# Реализуйте класс CustomRange, описывающий последовательность, элементами которой являются одиночные целые числа и числа из определенных диапазонов. При создании экземпляра класс должен принимать произвольное количество позиционных аргументов, каждый из которых является одиночным целым числом либо диапазоном.
# При передаче экземпляра класса CustomRange в функцию len() должно возвращаться количество элементов в нем. При передаче экземпляра класса CustomRange в функцию reversed() должен возвращаться итератор, элементами которого являются элементы переданного экземпляра класса CustomRange, расположенные в обратном порядке.
# Экземпляр класса CustomRange должен быть итерируемым объектом, то есть позволять перебирать свои элементы, например, с помощью цикла for.
# Помимо этого, экземпляр класса CustomRange должен поддерживать операцию проверки на принадлежность с помощью оператора in.
# Наконец, экземпляр класса CustomRange должен позволять получать значения своих элементов с помощью индексов, причем как положительных, так и отрицательных
# Примечание 1. Перед решением подумайте, какой абстрактный класс из модуля collections.abc будет удобен в качестве родительского.
# ---------------------------------------------------------------


from collections.abc import Iterable, Sequence

class CustomRange(Sequence):
    """класс CustomRange, описывающий последовательность, элементами которой являются одиночные целые числа и числа из определенных диапазонов."""

    def __init__(self, *args) -> None:
        self.numbers_range = []
        for i in args:
            if isinstance(i, int):
                self.numbers_range.append(i)
            elif isinstance(i, str):
                a, b = map(int, i.split('-'))
                range_i = range(a, b + 1)
                self.numbers_range.extend(range_i)   
        
        # print(self.numbers_range)

    # тк класс наследован от collections.abc.Sequenceб то нужно переопределить только 2 метода ниже(см. таблицу)
    def __len__(self):
        return len(self.numbers_range)

    
    def __getitem__(self, index):
        if not (0 <= index < len(self.numbers_range)  or -len(self.numbers_range) <= index <= -1):  # индексы как положительные так и отрицательные индексы
            raise IndexError ("Индекс не существует")
        return self.numbers_range[index]

customrange = CustomRange(1, '2-5', 5, '6-8')

print(customrange[0])
print(customrange[1])
print(customrange[2])
print(customrange[-1])
print(customrange[-2])
print(customrange[-3])

# ----------преп-----------------------------------------------
from collections.abc import Sequence


class CustomRange(Sequence):
    def __init__(self, *args):
        self._data = []
        for arg in args:
            start, stop = (arg, arg) if isinstance(arg, int) else map(int, arg.split('-'))
            self._data.extend(range(start, stop + 1))

    def __getitem__(self, item):
        if isinstance(item, (int, slice)):
            return self._data[item]
        return NotImplemented

    def __len__(self):
        return len(self._data)
# ---------------------------------------------------------------


# Класс BitArray
# 756
# Реализуйте класс BitArray, описывающий битовый список, то есть список, элементами которого являются только нули и единицы. При создании экземпляра класс должен принимать один аргумент:
#     iterable — итерируемый объект, определяющий начальный набор элементов битового списка. Если не передан, начальный набор считается пустым
# Экземпляр класса BitArray должен иметь следующее неформальное строковое представление:
# [<первый элемент битового списка>, <второй элемент битового списка>, ...]
# При передаче экземпляра класса BitArray в функцию len() должно возвращаться количество элементов в нем. При передаче экземпляра класса BitArray в функцию reversed() должен возвращаться итератор, элементами которого являются элементы переданного экземпляра класса BitArray , расположенные в обратном порядке.
# Экземпляр класса BitArray должен быть итерируемым объектом, то есть позволять перебирать свои элементы, например, с помощью цикла for.
# Помимо этого, экземпляр класса BitArray должен поддерживать операцию проверки на принадлежность с помощью оператора in.
# Также экземпляр класса BitArray должен позволять получать значения своих элементов с помощью индексов, причем как положительных, так и отрицательных.
# Вдобавок ко всему, экземпляр класса BitArray должен поддерживать унарный оператор ~, выполняющий операцию логического отрицания для каждого бита битового списка, тем самым преобразуя 0 в 1, а 1 в 0. Результатом работы оператора должен являться новый экземпляр класса BitArray.
# Наконец, экземпляры класса BitArray должны поддерживать между собой логические операции с помощью операторов & и |:
#     оператор & должен выполнять операцию логического И над каждой парой битов двух битовых списков равной длины. Результатом работы оператора должен являться новый экземпляр класса BitArray
#     оператор | должен выполнять операцию логического ИЛИ над каждой парой битов двух битовых списков равной длины. Результатом работы оператора должен являться новый экземпляр класса BitArray
# Примечание 1. Перед решением подумайте, какой абстрактный класс из модуля collections.abc будет удобен в качестве родительского.
# Примечание 2. Экземпляр класса BitArray не должен зависеть от итерируемого объекта, на основе которого он был создан. Другими словами, если исходный итерируемый объект изменится, то экземпляр класса BitArray измениться  не должен.
# ---------------------------------------------------------------
from collections.abc import Sequence
    
class BitArray(Sequence):  
    
    def __init__(self, iterable=[]) -> None:
        self.iterable = iterable[:]
        

    def __repr__(self) -> str:
        return f'[{", ".join(map(str, self.iterable))}]'
    
    
    def __getitem__(self, item):
        if isinstance(item, (int, slice)):
            return self.iterable[item]
        return NotImplemented

    def __len__(self):
        return len(self.iterable)

    def __iter__(self):
        return iter(self.iterable)

    def __invert__(self):
        lst = []
        for i in self.iterable:
            lst.append(int(not(bool(i))))            
        return BitArray(lst)

    def __and__(self, other):
        
        lst = []   

        if isinstance(other, BitArray):
            if len(self.iterable) == len(other.iterable):  
                for a, b  in zip(self.iterable, other.iterable):
                    lst.append(a & b)
                return BitArray(lst)

            else:
                raise TypeError(('Списки должны быть равной длины'))
            
        return NotImplemented

    def __or__(self, other):        
        
        lst = []

        if isinstance(other, BitArray):
            if len(self.iterable) == len(other.iterable):
                for a, b  in zip(self.iterable, other.iterable):
                    lst.append(a | b)
                return BitArray(lst)
            else:
                raise TypeError(('Списки должны быть равной длины'))   
                
        return NotImplemented  
# ------преп-------------------------------------------------


from collections.abc import Sequence


class BitArray(Sequence):
    def __init__(self, iterable=()):
        self._data = list(iterable)

    def __str__(self):
        return str(self._data)

    def __len__(self):
        return len(self._data)

    def __getitem__(self, index):
        if isinstance(index, (int, slice)):
            return self._data[index]
        return NotImplemented

    def __invert__(self):
        return __class__(int(not item) for item in self._data)

    def __or__(self, other):
        if isinstance(other, __class__) and len(self) == len(other):
            return __class__(self_item | other_item for self_item, other_item in zip(self._data, other._data))
        return NotImplemented   # если вернется константа NotImplemented, то будет возбуждено исключение TypeError с сообщением о том, что операция не поддерживается.
    # это такое поведение на уровне C. Когда возвращается константа NotImplemented, поведение может быть реализовано абсолютно разное. Если полистать исходный код python, то можно заметить, что там довольно часто встречается что-то вроде if value == NotImplemented {<какие-то действия>}. И эти действия для разных ситуаций будут разные. Где-то исключение будет выброшено, где-то проверка иная, где-то еще что.


    def __and__(self, other):
        if isinstance(other, __class__) and len(self) == len(other):    # __class__ Это атрибут класса и он содержит имя класса, необязательно обращаться к нему через экземпляр
            return __class__(self_item & other_item for self_item, other_item in zip(self._data, other._data))
        return NotImplemented   # если вернется константа NotImplemented, то будет возбуждено исключение TypeError с сообщением о том, что операция не поддерживается.
    # это такое поведение на уровне C. Когда возвращается константа NotImplemented, поведение может быть реализовано абсолютно разное. Если полистать исходный код python, то можно заметить, что там довольно часто встречается что-то вроде if value == NotImplemented {<какие-то действия>}. И эти действия для разных ситуаций будут разные. Где-то исключение будет выброшено, где-то проверка иная, где-то еще что.

# ------------наследование от обычного list----не по условиюб но всё же-----------------------------------------
class BitArray(list):
    def __invert__(self):
        return BitArray([abs(i-1) for i in self])
    
    def __and__(self, other):
        if isinstance(other, __class__):
            return BitArray([i and j for i,j in zip(self, other)])
        else:
            return NotImplemented
    
    def __or__(self, other):
        if isinstance(other, __class__):
            return BitArray([i or j for i,j in zip(self, other)])
        else:
            return NotImplemented
# ---------------------------------------------------------------


# Класс DNA
# 
# ДНК состоит из двух цепей, ориентированных азотистыми основаниями друг к другу. В ДНК встречается четыре вида азотистых оснований: аденин (A), гуанин (G), тимин (T) и цитозин (C). Азотистые основания одной из цепей соединены с азотистыми основаниями другой цепи водородными связями согласно принципу комплементарности: аденин (A) соединяется только с тимином (T), гуанин (G) — только с цитозином (C).
# Реализуйте класс DNA, описывающий двухцепочную спираль ДНК. При создании экземпляра класс должен принимать один аргумент:
#     chain — первая цепь ДНК, представляющая собой строку из символов A, G, T и C (азотистых оснований)
# Экземпляр класса DNA должен иметь следующее неформальное строковое представление:
# <азотистые основания первой цепи ДНК>
# При передаче экземпляра класса DNA в функцию len() должно возвращаться количество азотистых оснований в одной из его цепей. При передаче экземпляра класса в функцию reversed() должен возвращаться итератор, элементами которого являются элементы переданного экземпляра класса DNA, расположенные в обратном порядке.
# Помимо этого, экземпляр класса DNA должен быть итерируемым объектом, то есть позволять перебирать свои элементы, например, с помощью цикла for.
# Также экземпляр класса DNA должен позволять получать значения своих элементов с помощью индексов, причем как положительных, так и отрицательных.
# В случае с функцией reversed(), итерацией и доступу по индексам элементы экземпляра класса DNA должны быть представлены в виде кортежей из двух элементов, первым из которых является основание первой цепи ДНК по указанному индексу, вторым — азотистое основание второй цепи ДНК по указанному индексу. Азотистое основание второй цепи ДНК можно получить при помощи принципа комплементарности.
# Вдобавок ко всему, экземпляр класса DNA должен поддерживать операцию проверки на принадлежность с помощью оператора in. В данном случае должно проверяться, входит ли азотистое основание в первую цепь ДНК.
# Экземпляры класса DNA должны поддерживать между собой операции сравнения с помощью операторов == и!=. Две ДНК считаются равными, если их первые цепи совпадают.
# Наконец, экземпляры класса DNA должны поддерживать между собой операцию сложения с помощью оператора +, результатом которой должен являться новый экземпляр класса DNA, первой цепью которого является конкатенация первых цепей исходных экземпляров класса DNA.
# Примечание 1. Перед решением подумайте, какой абстрактный класс из модуля collections.abc будет удобен в качестве родительского.
# Примечание 2. Если объект, с которым выполняется операция сравнения или сложения, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# ---------------------------------------------------------------
from collections.abc import Sequence

class DNA(Sequence):
    def __init__(self, chain) -> None:
        self.chain = chain

    def __repr__(self) -> str:
        return str(self.chain)
# ---------------------------------------------------------------

# ---------------------------------------------------------------



# 
# 
# 
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Иерархия классов 🔠
# 893
# С помощью наследования и приведенной ниже схемы постройте иерархию пустых классов:
# ---------------------------------------------------------------
class A:
    pass

class B(A):
    pass

class C(A):
    pass

class D(A):
    pass

class E(B, D):
    pass

print(issubclass(E, B))
print(issubclass(E, C))
print(issubclass(E, D))

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Иерархия классов 🔠
# 880
# С помощью наследования и приведенной ниже схемы постройте иерархию пустых классов:
# ---------------------------------------------------------------
class H:
    pass



class D(H):
    pass

class E(H):
    pass

class F(H):
    pass

class G(H):
    pass



class B(D, E):
    pass

class C(F, G):
    pass


class A(B, C):
    pass


print(issubclass(D, H))
print(issubclass(E, H))
print(issubclass(F, H))
print(issubclass(G, H))
# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Функция get_method_owner()
# 860 
# Реализуйте функцию get_method_owner(), которая принимает два аргумента в следующем порядке:
    # cls — произвольный класс/
    # method — строковое название метода
# Функция должна возвращать класс, от которого класс cls унаследовал метод method. Если метода method нет ни в самом классе, ни в одном другом классе из его иерархии, функция get_method_owner() должна вернуть значение None.
# ---------------------------------------------------------------

from typing import Type, Any

def get_method_owner(cls: Type[Any], method):
    for i in cls.mro():
        if method in i.__dict__
            return i



# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Семья
# 
# С помощью множественного наследования постройте иерархию из приведенных ниже четырех классов. При решении старайтесь свести дублирование кода к минимуму.
# 1. Реализуйте класс Father, описывающий отца. При создании экземпляра класс должен принимать один аргумент:
#     mood — настроение, по умолчанию равняется строке neutral
# Экземпляр класса Father должен иметь один атрибут:
#     mood — настроение
# Класс Father должен иметь два метода экземпляра:
#     greet() — метод, возвращающий строку Hello!
#     be_strict() — метод, изменяющий значение атрибута mood на строку strict
# 2. Также реализуйте класс Mother, описывающий мать. При создании экземпляра класс должен принимать один аргумент:
#     mood — настроение, по умолчанию равняется строке neutral
# Экземпляр класса Mother должен иметь один атрибут:
#     mood — настроение
# Класс Mother должен иметь два метода экземпляра:
#     greet() — метод, возвращающий строку Hi, honey!
#     be_kind() — метод, изменяющий значение атрибута mood на строку kind
# 3. Помимо этого, реализуйте класс Daughter, описывающий дочь. При создании экземпляра класс должен принимать один аргумент:
#     mood — настроение, по умолчанию равняется строке neutral
# Экземпляр класса Daughter должен иметь один атрибут:
#     mood — настроение
# Класс Daughter должен иметь три метода экземпляра:
#     greet() — метод, возвращающий строку Hi, honey!
#     be_kind() — метод, изменяющий значение атрибута mood на строку kind
#     be_strict() — метод, изменяющий значение атрибута mood на строку strict
# 4. Наконец, реализуйте класс Son, описывающий сына. При создании экземпляра класс должен принимать один аргумент:
#     mood — настроение, по умолчанию равняется строке neutral
# Экземпляр класса Son должен иметь один атрибут:
#     mood — настроение
# Класс Son должен иметь три метода экземпляра:
#     greet() — метод, возвращающий строку Hello!
#     be_kind() — метод, изменяющий значение атрибута mood на строку kind
#     be_strict() — метод, изменяющий значение атрибута mood на строку strict
# ---------------------------------------------------------------
class Father:
    def __init__(self, mood='neutral') -> None:
        self.mood = mood

    def greet(self) -> str:
        return 'Hello!' 

    def be_strict(self, strict='strict') -> None:
        self.mood = strict

class Mother():
    def __init__(self, mood='neutral') -> None:
        self.mood = mood

    def greet(self) -> str:
        return 'Hi, honey!' 

    def be_kind(self, kind='kind') -> None:
        self.mood = kind

class Daughter(Mother, Father):
    pass

class Son(Father, Mother):
    pass

# -------------
father = Father('happy')
mother = Mother('unhappy')

print(father.mood)
print(mother.mood)
father.be_strict()
mother.be_kind()
print(father.mood)
print(mother.mood)


# -----преп------------------------------------------------------
from abc import ABC, abstractmethod


class Family(ABC):                      # этот класс служит интерфейсом для дочерних классов. Т.е. сразу видно, какой метод общий и какой нужно обязательно реализовать для каждого такого класса.
    def __init__(self, mood='neutral'):
        self.mood = mood

    @abstractmethod
    def greet(self):
        pass


class Father(Family):
    def greet(self):
        return 'Hello!'

    def be_strict(self):
        self.mood = 'strict'


class Mother(Family):
    def greet(self):
        return 'Hi, honey!'

    def be_kind(self):
        self.mood = 'kind'


class Daughter(Mother, Father):
    pass


class Son(Father, Mother):
    pass


# ---------------------------------------------------------------


# Класс MROHelper
# 839
# Реализуйте класс MROHelper, описывающий набор функций для работы с MRO произвольных классов. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс MROHelper должен иметь три статических метода:
#     len() — метод, принимающий в качестве аргумента класс и возвращающий количество элементов в его MRO
#     class_by_index() — метод, принимающий в качестве аргументов класс cls и целое число n, по умолчанию равное нулю, и возвращающий класс с индексом n в MRO класса cls
#     index_by_class() — метод, принимающий в качестве аргументов два класса child и parent и возвращающий целое число — индекс класса parent в MRO класса child
# Примечание 1. Нумерация классов в MRO начинается с нуля.
# Примечание 2. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# Примечание 3. Никаких ограничений касательно реализации класса MROHelper нет, она может быть произвольной.
# ---------------------------------------------------------------

from typing import Type, Any

class MROHelper:
    """
    класс описывающий набор функций для работы с MRO произвольных классов
    """
    
    @staticmethod
    def len(cls: Type[Any]) -> int:
        """метод, принимающий в качестве аргумента класс и возвращающий количество элементов в его MRO"""
        
        return len(cls.mro())

    @staticmethod
    def class_by_index(cls: Type[Any], n=0) -> Type[Any]:
        """метод, принимающий в качестве аргументов класс cls и целое число n, по умолчанию равное нулю, и возвращающий класс с индексом n в MRO класса cls"""
        return cls.mro()[n]

    @staticmethod
    def index_by_class(child: Type[Any], parent: Type[Any]):
        """метод, принимающий в качестве аргументов два класса child и parent и возвращающий целое число — индекс класса parent в MRO класса child"""
        for index, class_name in enumerate(child.mro()):
            if class_name == parent:
                return index 
# -------------
class A:
    pass
    
class B(A):
    pass
    
class C(A):
    pass
    
class D(B, C):
    pass
    
print(MROHelper.class_by_index(D, 2))
print(MROHelper.class_by_index(B))              

# ------преп-----------------------------------------------------
class MROHelper:
    @staticmethod
    def len(cls):
        return len(cls.mro())

    @staticmethod
    def class_by_index(cls, n=0):
        return cls.mro()[n]

    @staticmethod
    def index_by_class(child, parent):
        return child.mro().index(parent)
# ---------------------------------------------------------------
class MROHelper:
    len = lambda cls: len(cls.__mro__)
    class_by_index = lambda cls, n=0: cls.__mro__[n]
    index_by_class = lambda child, parent: child.__mro__.index(parent)
# ---------------------------------------------------------------
class MROHelper:
    @staticmethod 
    def len(class_):
        return len(class_.__mro__)
        
    @staticmethod     
    def class_by_index(class_, n=0):
        return class_.__mro__[n]
        
    @staticmethod
    def index_by_class(child, parent):
        return child.__mro__.index(parent)
# ---------------------------------------------------------------




# Классы USADate и ItalianDate
# 
# 1. Реализуйте класс USADate, описывающий дату в американском формате. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     year — год
#     month — месяц
#     day — день
# Класс USADate должен иметь два метода экземпляра:
#     format() — метод, который возвращает строку, представляющую собой дату в формате MM-DD-YYYY
#     iso_format() — метод, который возвращает строку, представляющую собой дату в формате YYYY-MM-DD
# 2. Также реализуйте класс ItalianDate, описывающий дату в итальянском формате, конструктор которого принимает три аргумента:
#     year — год
#     month — месяц
#     day — день
# Класс ItalianDate должен иметь два метода экземпляра:
#     format() — который возвращает строку, представляющую собой дату в формате DD/MM/YYYY
#     iso_format() — который возвращает строку, представляющую собой дату в формате YYYY-MM-DD
# ---------------------------------------------------------------
from abc import ABC, abstractmethod
from datetime import date

class Data(ABC):
    def __init__(self, year, month, day) -> None:    
        self.date = date(year, month, day)

    
    def iso_format(self) -> str:
        return self.date.isoformat()  

    @abstractmethod
    def format(self) -> str:
        pass    



class USADate(Data):
    def format(self) -> str:
        return self.date.strftime('%m-%d-%Y')

       

class ItalianDate(Data):
    def format(self) -> str:
        return self.date.strftime('%d/%m/%Y')


# ----------
italiandate = ItalianDate(2023, 4, 6)
usadate = USADate(2023, 4, 6)

print(italiandate.format())
print(italiandate.iso_format()) 


print(usadate.format())
print(usadate.iso_format())
# ---------------------------------------------------------------



# Классы MinStat, MaxStat и AverageStat
# 
# 1. Реализуйте класс MinStat, описывающий объект, который находит минимальное значение среди определенного набора чисел. При создании экземпляра класс должен принимать один аргумент:
#     iterable — итерируемый объект, определяющий начальный набор чисел. Если не передан, начальный набор считается пустым
# Класс MinStat должен иметь три метода экземпляра:
#     add() — метод, принимающий в качестве аргумента число и добавляющий его в набор
#     result() — метод, возвращающий минимальное число из набора. Если набор пуст, метод должен вернуть значение None
#     clear() — метод, удаляющий из набора все числа
# 2. Также реализуйте класс MaxStat, описывающий объект, который находит максимальное значение среди определенного набора чисел. При создании экземпляра класс должен принимать один аргумент:
#     iterable — итерируемый объект, определяющий начальный набор чисел. Если не передан, начальный набор считается пустым
# Класс MaxStat должен иметь три метода экземпляра:
#     add() — метод, принимающий в качестве аргумента число и добавляющий его в набор
#     result() — метод, возвращающий максимальное число из набора. Если набор пуст, метод должен вернуть значение None
#     clear() — метод, удаляющий из набора все числа
# 3. Наконец, реализуйте класс AverageStat, описывающий объект, который находит среднее арифметическое определенного набора чисел. При создании экземпляра класс должен принимать один аргумент:
#     iterable — итерируемый объект, определяющий начальный набор чисел. Если не передан, начальный набор считается пустым
# Класс AverageStat должен иметь три метода экземпляра:
#     add() — метод, принимающий в качестве аргумента число и добавляющий его в набор
#     result() — метод, возвращающий среднее арифметическое набора чисел. Если набор пуст, метод должен вернуть значение None
#     clear() — метод, удаляющий из набора все числа
# ---------------------------------------------------------------


from abc import ABC, abstractmethod
# import statistics


class Stat(ABC):
    def __init__(self, iterable=()) -> None:
        self.iterable = list(iterable)

    def add(self, num: int | float) -> None:
        """метод, принимающий в качестве аргумента число и добавляющий его в набор"""

        self.iterable.append(num)


    def clear(self):
        self.iterable.clear()


    @abstractmethod
    def result(self):
        pass



class MinStat(Stat):
    """
    класс MinStat, описывающий объект, который находит минимальное значение среди определенного набора чисел.
    """

    def result(self) -> int | float:
        """метод, возвращающий минимальное число из набора. Если набор пуст, метод должен вернуть значение None"""

        return min(self.iterable, default=None)


class MaxStat(Stat):
    """
    класс MaxStat, описывающий объект, который находит максимальное значение среди определенного набора чисел
    """

    def result(self) -> int | float:
        """метод, возвращающий минимальное число из набора. Если набор пуст, метод должен вернуть значение None"""

        return max(self.iterable, default=None)


class AverageStat(Stat):
    """
    класс AverageStat, описывающий объект, который находит среднее арифметическое определенного набора чисел
    """
        
    def result(self) -> int | float:
        """ метод, возвращающий среднее арифметическое набора чисел. Если набор пуст, метод должен вернуть значение None"""    
        
        if self.iterable:
            return sum(self.iterable) / len(self.iterable)   # statistics.fmean(self.iterable)
# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Классы LeftParagraph и RightParagraph
# 
# Будем называть словом любую последовательность из одной или более латинских букв.
# 1. Реализуйте класс LeftParagraph, описывающий абзац, выровненный по левому краю. При создании экземпляра класс должен принимать один аргумент:
#     length — длина строки абзаца
# Класс LeftParagraph должен иметь два метода экземпляра:
#     add() — метод, принимающий в качестве аргумента слово или несколько слов, разделенных пробелом, и добавляющий их в текущий абзац. Если слово не помещается на текущей строке, оно переносится на следующую. Также метод должен автоматически добавлять один пробел после каждого добавленного слова (кроме последнего)
#     end() — метод, печатающий текущий абзац, выровненный по левому краю. После вызова метода текущий абзац считается пустым, то есть начинается формирование нового
# 2. Также реализуйте класс RightParagraph, описывающий абзац, выровненный по правому краю. При создании экземпляра класс должен принимать один аргумент:
#     length — длина строки абзаца
# Класс RightParagraph должен иметь два метода экземпляра:
#     add() — метод, принимающий в качестве аргумента слово или несколько слов, разделенных пробелом, и добавляющий их в текущий абзац. Если слово не помещается на текущей строке, оно переносится на следующую. Также метод должен автоматически добавлять один пробел после каждого добавленного слова (кроме последнего)
#     end() — метод, печатающий текущий абзац, выровненный по правому краю с учетом длины строки. После вызова метода текущий абзац считается пустым, то есть начинается формирование нового
# ---------------------------------------------------------------

from abc import ABC, abstractmethod
import textwrap

class Paragraph(ABC):    
    def __init__(self, length) -> None:
        self.length = length
        self.paragraph = []

        
    def add(self, text='') -> None:
        """метод, принимающий в качестве аргумента слово или несколько слов, разделенных пробелом, и добавляющий их в текущий абзац. Если слово не помещается на текущей строке, оно переносится на следующую. Также метод должен автоматически добавлять один пробел после каждого добавленного слова (кроме последнего)"""
        
        self.paragraph.extend(text.split())   


    @abstractmethod
    def end(self) -> None:
        pass
    
    
    
class LeftParagraph(Paragraph):
    def end(self) -> None:
        """метод, печатающий текущий абзац, выровненный по левому краю. После вызова метода текущий абзац считается пустым, то есть начинается формирование нового"""

        lst = ' '.join(self.paragraph) 
        result = textwrap.wrap(lst, width=self.length)    # Разбивает абзац text по строкам так, что каждая строка имеет не более width символов длиной. Возвращает список строк, без завершающего символа новой строки \n.    
        
        for line in result:
            # line = line.ljust(self.length)
            print(line)
        
        self.paragraph.clear()



class RightParagraph(Paragraph):
    def end(self) -> None:
        """метод, печатающий текущий абзац, выровненный по правому краю с учетом длины строки. После вызова метода текущий абзац считается пустым, то есть начинается формирование нового"""
        
        lst = ' '.join(self.paragraph) 
        result = textwrap.wrap(lst, width=self.length)    # Разбивает абзац text по строкам так, что каждая строка имеет не более width символов длиной. Возвращает список строк, без завершающего символа новой строки \n.    
        
        for line in result:
            line = line.rjust(self.length)
            print(line)
        
        self.paragraph.clear()

# --------------------------
rightparagraph = RightParagraph(28)

rightparagraph.add('I will not regret the roses')
rightparagraph.add('Withered with a light spring')
rightparagraph.add('I love the grapes on the vines')
rightparagraph.add('Ripened in the hands under the mountain')
rightparagraph.end()

rightparagraph.add('The beauty of my green valley')
rightparagraph.add('Golden joy of autumn')
rightparagraph.add('oblong and transparent')
rightparagraph.add('Like the fingers of a young maiden')
rightparagraph.end()
# -------преп----------------------------------------------------
from abc import ABC, abstractmethod


class Paragraph(ABC):
    def __init__(self, length):
        self._size = length
        self._paragraph = ['']

    def add(self, words):
        words = words.split()
        for word in words:
            if len(self._paragraph[-1] + f' {word}') > self._size:
                self._paragraph.append('')
            self._paragraph[-1] = (self._paragraph[-1] + f' {word}').lstrip()

    @abstractmethod
    def end(self):
        pass


class LeftParagraph(Paragraph):
    def end(self):
        for line in self._paragraph:
            print(line)
        self._paragraph = ['']


class RightParagraph(Paragraph):
    def end(self):
        for line in self._paragraph:
            print(line.rjust(self._size))
        self._paragraph = ['']
# ---------------------------------------------------------------


# Классы Point и Circle
# 860
# 1. Реализуйте класс Point, описывающий точку на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата точки по оси xx
#     y — координата точки по оси yy
# Экземпляр класса Point должен иметь следующее неформальное строковое представление:
# ​(<координата x>, <координата y>)
# 2. Также реализуйте класс Circle, описывающий окружность на плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     radius — радиус окружности
#     center — точка с координатами центра окружности, представленная экземпляром класса Point
# Экземпляр класса Circle должен иметь следующее неформальное строковое представление:
# (<координата центра по оси x>, <координата центра по оси y>), r = <радиус>
# Примечание 1. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованные классы используются только с корректными данными.
# Примечание 2. Никаких ограничений касательно реализаций классов нет, они могут быть произвольными.
# Примечание 3. Тестовые данные доступны по ссылкам:
# ---------------------------------------------------------------

class Point:
    def __init__(self, x, y) -> None:
        self.x = x
        self.y = y

    def __repr__(self) -> str:
        return f'({self.x}, {self.y})'


class Circle:
    def __init__(self, radius, center) -> None:
        self.radius = radius
        self.center = center        

    def __repr__(self) -> str:
        return f'({self.center.x}, {self.center.y}), r = {self.radius}'

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Классы Item и ShoppingCart
# 837
# 1. Реализуйте класс Item, описывающий товар. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     name — название товара
#     price — цена товара в долларах
# Экземпляр класса Item должен иметь следующее неформальное строковое представление:
# <название товара>, <цена товара>$
# 2. Также реализуйте класс ShoppingCart, описывающий корзину для покупок. При создании экземпляра класс должен принимать один аргумент:
#     items — итерируемый объект, определяющий начальный набор товаров в корзине. Если не передан, корзина считается пустой
# Класс ShoppingCart должен иметь три метода экземпляра:
#     add() — метод, принимающий в качестве аргумента товар и добавляющий его в корзину
#     total() — метод, возвращающий суммарную стоимость всех товаров в корзине
#     remove() — метод, принимающий в качестве аргумента название товара и удаляющий его из корзины. Если в корзине несколько товаров с указанным именем, они должны быть удалены все
# Экземпляр класса ShoppingCart должен иметь следующее неформальное строковое представление:
# <название первого товара в корзине>, <цена первого товара в корзине>$
# <название второго товара в корзине>, <цена второго товара в корзине>$
# ...
# Примечание 1. Если корзина для покупок пуста, то ее неформальным строковым представлением должна быть пустая строка.
# ---------------------------------------------------------------
class Item:
    def __init__(self, name: str, price: int) -> None:
        self.name = name
        self.price = price

    def __repr__(self) -> str: 
        return f'{self.name}, {self.price}$'

    
class ShoppingCart:
    def __init__(self, items=()) -> None:
        self.items = list(items)

    def add(self, item: 'Item') -> None:
        self.items.append(item) 

    def total(self) -> None:
        price_goods = sum(i.price for i in self.items)

        return price_goods

    def remove(self, name: str) -> None:
        self.items = [item for item in self.items if item.name != name]




    def __repr__(self) -> str:
        if self.items:
            lst = (f"{i.name}, {i.price}$" for i in self.items)
            return '\n'.join(lst)
        return ''

# -----------------------
shopping_cart = ShoppingCart([Item('Yoga Mat', 130), Item('Flannel Shirt', 22)])

shopping_cart.remove('Yoga Mat')
print(shopping_cart)
print(shopping_cart.total())
# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Классы Card и Deck
# 
# 1. Реализуйте класс Card, описывающий игральную карту. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     suit — масть игральной карты, представленная одним из следующих символов:
#     ♣, ♢, ♡, ♠
#     rank — ранг игральной карты, представленный одним из следующих символов или парой символов:
#     2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K, A
# Экземпляр класса Card должен иметь следующее неформальное строковое представление:
# <масть игральной карты><ранг игральной карты>
# 2. Также реализуйте класс данных Deck, описывающий классическую колоду из 52 игральных карт. Карты в колоде должны быть расположены сперва в порядке возрастания мастей, а затем — в порядке возрастания рангов. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Deck должен иметь два метода экземпляра:
#     shuffle() — метод, перемешивающий все карты в колоде. Перемешивать колоду можно только в том случае, если в колоде на данный момент находятся все 52 карты. Если в колоде меньше 52 карт, должно быть возбуждено исключение ValueError с текстом:
#     Перемешивать можно только полную колоду
#     deal() — метод, удаляющий из колоды последнюю карту и возвращающий ее. Если колода пуста, должно быть возбуждено исключение ValueError с текстом:
#     Все карты разыграны
# Экземпляр класса Deck должен иметь следующее неформальное строковое представление:
# Карт в колоде: <текущее количество карт в колоде>
# Примечание 1. Порядок старшинства карточных рангов от младшего к старшему:
# 2, 3, 4, 5, 6, 7, 8, 9, 10, J, Q, K, A
# Порядок старшинства карточных мастей от младшего к старшему:
# ♣, ♢, ♡, ♠
# ---------------------------------------------------------------

from random import shuffle
# from itertools import product

class Card:
    def __init__(self, suit, rank) -> None:
        self.suit = suit
        self.rank = rank

    def __repr__(self) -> str:
        return f'{self.suit}{self.rank}'    


class Deck:
        
    __SUITS = ('♣', '♢', '♡', '♠')
    __RANKS = ('2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A')
    
    def __init__(self) -> None:
        self.classical_pack_52 = [Card(suit, rank) for suit in self.__SUITS for rank in self.__RANKS]
        # self.deck = list(Card(x, y) for x, y in product(self.SUITS, self.RANKS))
    
    def shuffle(self):
        if len(self.classical_pack_52) < 52:
            raise ValueError('Перемешивать можно только полную колоду')
        shuffle(self.classical_pack_52)
       
    def deal(self):
        if not self.classical_pack_52:            
            raise ValueError('Все карты разыграны')
        return self.classical_pack_52.pop()


    def __repr__(self) -> str:
        return f'Карт в колоде: {len(self.classical_pack_52)}'


# ----тест -------
deck = Deck()

deck.deal()
    
try:
    deck.shuffle()
except ValueError as error:
    print(error)



# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Класс Queue
# 754
# Реализуйте класс Queue, описывающий очередь, элементами которой являются пары ключ: значение. При создании экземпляра класс должен принимать один аргумент:
#     pairs — список или словарь, определяющий начальный набор элементов очереди. Порядок элементов в очереди должен совпадать с их порядком в переданном итерируемом объекте. Если не передан, очередь считается пустой
# Класс Queue должен иметь два метода экземпляра:
#     add() — метод, принимающий в качестве аргумента элемент и добавляющий его в конец очереди. Элементом в данном случае является двухэлементный кортеж, содержащий ключ и значение. Если в очереди уже содержится элемент с указанным ключом, он должен быть перенесен в конец очереди, а его значение должно быть обновлено
#     pop() — метод, удаляющий из очереди первый элемент и возвращающий его. Элементом в данном случае является двухэлементный кортеж, содержащий ключ и значение. Если очередь пуста, должно быть возбуждено исключение KeyError с текстом:
#     Очередь пуста
# Экземпляр класса Queue должен иметь следующее формальное строковое представление:
# Queue([(<ключ 1-го элемента>, <значение 1-го элемента>), (<ключ 2-го элемента>, <значение 2-го элемента>), ...])
# При передаче экземпляра класса Queue в функцию len() должно возвращаться количество элементов в нем.
# Примечание 1. Вероятно, при решении задачи будет удобно воспользоваться одним из классов из модуля collections.
# ---------------------------------------------------------------

class Queue:
    def __init__(self, pairs=()) -> None:
        self.pairs = dict(pairs)   

    def add(self, elem: tuple):        
        if elem[0] in self.pairs:
            self.pairs.pop(elem[0])         
        self.pairs.update([elem])

    def pop(self):
        if self.pairs:
            for key in self.pairs.keys():
                return (key, self.pairs.pop(key, None))
        else:
            raise KeyError('Очередь пуста')

    def __repr__(self) -> str:
        return f'Queue({[(key, value) for key, value in self.pairs.items()]})'      
        

    def __len__(self) -> int:
        return len(self.pairs)

# --------------
queue = Queue([('one', 1)])

queue.add(('two', 2))
print(queue.pop())
print(queue.pop())
print(queue)
# ---------------------------------------------------------------

from collections import deque

class Queue(deque):
    def add(self, item):
        for elem in self:
            if elem[0]==item[0]:
                del self[self.index(elem)]
                break
        self.append(item)
                
    
    def pop(self):
        if len(self):
            return self.popleft()
        raise KeyError('Очередь пуста')
# ---------------------------------------------------------------



# Классы Lecture и Conference🌶️🌶️
# 634
# 1. Реализуйте класс Lecture, описывающий некоторое выступление. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     topic — тема выступления
#     start_time — время начала выступления в виде строки в формате HH:MM
#     duration — длительность выступления в виде строки в формате HH:MM
# 2. Также реализуйте класс Conference, описывающий конференцию, протяженностью в один день. Конференция представляет собой набор последовательных выступлений. При создании экземпляра класс не должен принимать никаких аргументов.
# Класс Conference должен иметь четыре метода экземпляра:
#     add() — метод, принимающий в качестве аргумента выступление и добавляющий его в конференцию. Если выступление пересекается по времени с другими выступлениями, должно быть возбуждено исключение ValueError с текстом:
#     Провести выступление в это время невозможно
#     total() — метод, возвращающий суммарную длительность всех выступлений в конференции в виде строки в формате HH:MM
#     longest_lecture() — метод, возвращающий длительность самого долгого выступления в конференции в виде строки в формате HH:MM
#     longest_break() — метод, возвращающий длительность самого долгого перерыва между выступлениями в конференции в виде строки в формате HH:MM
# Примечание 1. Перерыв между выступлениями может быть нулевым. Другими словами, одно выступление может заканчиваться, например, в 12:00, а другое начинаться в 12:00.
# ---------------------------------------------------------------

from datetime import datetime, timedelta


class Lecture:
    def __init__(self, topic: str, start_time: str, duration: str) -> None:
        self.topic = topic
        self.start_time = datetime.strptime(start_time, "%H:%M")
        
        h, m = map(int, duration.split(':'))
        self.duration = timedelta(hours=h, minutes=m)
        
        self.end_time = self.start_time + self.duration     


    
class Conference:
    def __init__(self) -> None:
        self.lst_lecture = []

    
    def add(self, other: 'Lecture')-> None:
        """метод, принимающий в качестве аргумента выступление и добавляющий его в конференцию"""
        
        for lecture in self.lst_lecture:
            if (lecture.start_time <= other.start_time < lecture.end_time) or (other.start_time <= lecture.start_time < other.end_time):
                raise ValueError('Провести выступление в это время невозможно')
        self.lst_lecture.append(other)
        # self.lst_lecture.sort(key=lambda x: x.start_time)


    def total(self) -> str:
        """метод, возвращающий суммарную длительность всех выступлений в конференции в виде строки в формате HH:MM"""
        lst = sum(lecture.duration.total_seconds() for lecture in self.lst_lecture)
        h, m = map(int, divmod(lst/60, 60))
        return f"{str(h).rjust(2, '0')}:{str(m).rjust(2, '0')}"


    def longest_lecture(self) -> str:
        """метод, возвращающий длительность самого долгого выступления в конференции в виде строки в формате HH:MM"""

        lst = max([lecture.duration.total_seconds() for lecture in self.lst_lecture])
        h, m = map(int, divmod(lst/60, 60))
        return f"{str(h).rjust(2, '0')}:{str(m).rjust(2, '0')}"
        
    
    def longest_break(self) -> str:
        """метод, возвращающий длительность самого долгого перерыва между выступлениями в конференции в виде строки в формате HH:MM"""

        longest = max(self.lst_lecture[i + 1].start_time - self.lst_lecture[i].end_time for i in range(len(self.lst_lecture) - 1))
        hours, minutes = int(longest.total_seconds()) // 3600, (int(longest.total_seconds()) // 60) % 60
        return f'{hours:0>2}:{minutes:0>2}'
# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Класс Shape
# 
# Реализуйте класс Shape, описывающий геометрическую фигуру. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     name — название фигуры
#     color — цвет фигуры
#     area — площадь фигуры
# Экземпляр класса Shape должен иметь три атрибута:
#     name — название фигуры
#     color — цвет фигуры
#     area — площадь фигуры
# Помимо приведенных выше трех атрибутов, экземпляр класса Shape не должен иметь возможности получить какие-либо другие атрибуты.
# Также экземпляр класса Shape должен иметь следующее неформальное строковое представление:
# <цвет фигуры> <название фигуры> (<площадь фигуры>)
# Наконец, экземпляры класса Shape должны поддерживать между собой все операции сравнения с помощью операторов ==, !=, >, <, >=, <=. Две фигуры считаются равными, если их площади совпадают. Фигура считается больше другой фигуры, если ее площадь больше.
# Примечание 1. Если объект, с которым выполняется операция сравнения, некорректен, метод, реализующий эту операцию, должен вернуть константу NotImplemented.
# Примечание 2. Дополнительная проверка данных на корректность не требуется. Гарантируется, что реализованный класс используется только с корректными данными.
# ---------------------------------------------------------------
from functools import total_ordering


@total_ordering
class Shape:
    """
    класс Shape, описывающий геометрическую фигуру
    """
    __slots__= ('name','color', 'area')

    def __init__(self, name: str, color: str, area: int | float) -> None:
        self.name = name
        self.color = color
        self.area = area
    
    def __str__(self) -> str:
        return f'{self.color} {self.name} ({self.area})'

    
    def __eq__(self, other: 'Shape') -> bool:
        if isinstance(other, Shape):
            return self.area == other.area
        return NotImplemented
    
    
    def __lt__(self, other: 'Shape') -> bool:
        if isinstance(other, Shape):
            return self.area < other.area
        return NotImplemented

# ------------
shape = Shape('triangle', 'red', 12)

print(shape.name)
print(shape.color)
print(shape.area)

print(Shape('rectangle', 'green', 12) == Shape('triangle', 'red', 12))
print(Shape('triangle', 'red', 15) > Shape('triangle', 'red', 12))
print(Shape('Square', 'Red', 4))


shape = Shape('triangle', 'red', 12)
try:
    shape.perimeter = 9
except AttributeError:
    print('Error')

# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Класс HTTPStatusCodes
# 828
# Коды состояния HTTP представляют собой трехзначные целые числа и используются для указания успешности конкретного HTTP запроса. Выделяют пять групп кодов состояния:
#     информация (100-199)
#     успех (200-299)
#     перенаправление (300-399)
#     ошибка клиента (400-499)
#     ошибка сервера (500-599)
# Реализуйте класс HTTPStatusCodes, описывающий перечисление с  кодами состояния HTTP. Перечисление должно иметь пять элементов:
#     CONTINUE — элемент со значением 100
#     OK — элемент со значением 200
#     USE_PROXY — элемент со значением 305
#     NOT_FOUND — элемент со значением 404
#     BAD_GATEWAY — элемент со значением 502
# Элемент перечисления должен иметь два метода:
#     info() — метод, возвращающий двухэлементный кортеж, содержащий имя элемента и его значение
#     code_class() — метод, возвращающий название группы на русском, к которой относится элемент
# ---------------------------------------------------------------

from enum import Enum


class HTTPStatusCodes(Enum):    
    CONTINUE = 100
    OK = 200
    USE_PROXY = 305
    NOT_FOUND = 404
    BAD_GATEWAY = 502

    

    def info(self):
        return (self.name, self.value)
    
    
     
    def code_class(self):      
        GROUP = {range(100,200): 'информация ',
            range(200,300): 'успех ',
            range(300,400): 'перенаправление',
            range(400,500): 'ошибка клиента',
            range(500,600): 'ошибка сервера '}

        for i in GROUP:
            if self.value in i:
                return GROUP[i]
# ---------------------------------------------------------------
from enum import Enum


class HTTPStatusCodes(Enum):
    CONTINUE = 100
    OK = 200
    USE_PROXY = 305
    NOT_FOUND = 404
    BAD_GATEWAY = 502

    def info(self):
        return self.name, self.value

    def code_class(self):
        groups = ('информация', 'успех', 'перенаправление', 'ошибка клиента', 'ошибка сервера')
        codes = dict(zip(HTTPStatusCodes, groups))
        return codes[self]
# ---------------------------------------------------------------



# Класс Seasons
# 819
# Реализуйте класс Seasons, описывающий перечисление с временами года. Перечисление должно иметь четыре элемента:
#     WINTER — элемент со значением 1
#     SPRING — элемент со значением 2
#     SUMMER — элемент со значением 3
#     FALL — элемент со значением 4
# Элемент перечисления должен иметь один метод:
#     text_value() — метод, принимающий в качестве аргумента код страны en или ru и возвращающий строковое значение элемента в зависимости от переданного аргумента. Для WINTER en и ru значениями являются winter и зима соответственно, для SPRING — spring и весна, для SUMMER — summer и лето, для FALL — fall и осень
# ---------------------------------------------------------------

from enum import Enum

class Seasons(Enum):
    
    WINTER = 1
    SPRING = 2
    SUMMER = 3
    FALL = 4

    def text_value(self, code: str):
        code_country_en = ('winter', 'spring', 'summer', 'fall')
        code_country_ru = ('зима', 'весна', 'лето', 'осень')
        
        if code == 'ru':        
            return code_country_ru[self.value - 1]
        elif code == 'en':
            return code_country_en[self.value - 1]
# ---------------------------------------------------------------
from enum import Enum


class Seasons(Enum):
    WINTER = 1
    SPRING = 2
    SUMMER = 3
    FALL = 4
    
    def text_value(self, lang):
        times_year = {
            'WINTER': ('winter', 'зима'),
            'SPRING': ('spring', 'весна'),
            'SUMMER': ('summer', 'лето'),
            'FALL': ('fall', 'осень')
        }
        return times_year[self.name][lang == 'ru']
# ---------------------------------------------------------------



# Классы Weekday и NextDate
# 662
# 1. Реализуйте класс Weekday, описывающий перечисление с днями недели. Перечисление должно иметь семь элементов:

#     MONDAY — элемент со значением 0
#     TUESDAY — элемент со значением 1
#     WEDNESDAY — элемент со значением 2
#     THURSDAY — элемент со значением 3
#     FRIDAY — элемент со значением 4
#     SATURDAY — элемент со значением 5
#     SUNDAY — элемент со значением 6

# 2. Также реализуйте класс NextDate, позволяющий определять дату следующего дня недели, начиная с текущего дня. При создании экземпляра класс должен принимать три аргумента в следующем порядке:
#     today — дата текущего дня, представленная экземпляром класса date
#     weekday — день недели, представленный элементом перечисления Weekday
#     after_today — булево значение, по умолчанию равняется False
# Параметр after_today должен определять, учитывается ли текущая дата при определении даты следующего дня недели. Если он имеет значение False, текущая дата не должна учитываться, если True — должна учитываться.
# Класс NextDate должен иметь два метода экземпляра:
#     date() — метод, возвращающий дату следующего дня недели в виде экземпляра класса date
#     days_until() — метод, возвращающий количество дней до даты следующего дня недели
# ---------------------------------------------------------------
from enum import Enum
from datetime import date, timedelta

class Weekday(Enum):
    """
     класс Weekday, описывающий перечисление с днями недели
    """
    MONDAY = 0
    TUESDAY = 1
    WEDNESDAY = 2
    THURSDAY = 3
    FRIDAY = 4
    SATURDAY = 5
    SUNDAY = 6

class NextDate:
    """
     класс NextDate, позволяющий определять дату следующего дня недели, начиная с текущего дня
    """
    
    def __init__(self, today: 'date', weekday: 'Weekday', after_today=False) -> None:
        self.today = today
        self.weekday = weekday
        self.after_today = after_today


    def date(self):
        """метод, возвращающий дату следующего дня недели в виде экземпляра класса date"""
        
        d = self.today
        
        while d.weekday() != self.weekday.value:
            d += timedelta(days=1)
        
        if self.today.weekday() == d.weekday():
            return d + timedelta(days=7)
        else:
            return d 

        

    def days_until(self):
        """ метод, возвращающий количество дней до даты следующего дня недели"""            
        day1 = abs((self.today - self.date()).days)
        
        if self.today.weekday() == self.date().weekday():
            return day1 
        return day1
        # return  day1 if self.after_today else day1 + 7


# ---------------------------------------------------------------
# НЕ РЕШЕНА
# ---------------------------------------------------------------



# Класс OrderStatus
# 775
# Реализуйте класс OrderStatus, описывающий флаг с состояниями интернет-заказов. Флаг должен иметь три элемента:
#     ORDER_PLACED
#     PAYMENT_RECEIVED
#     SHIPPING_COMPLETE
# ---------------------------------------------------------------

from enum import Flag, auto

class OrderStatus(Flag):
    ORDER_PLACED = auto() 
    PAYMENT_RECEIVED = auto()
    SHIPPING_COMPLETE = auto()
# ---------------------------------------------------------------
from enum import Flag

OrderStatus = Flag('OrderStatus', ['ORDER_PLACED', 'PAYMENT_RECEIVED', 'SHIPPING_COMPLETE'])
# ---------------------------------------------------------------
class OrderStatus(Flag):
    ORDER_PLACED, PAYMENT_RECEIVED, SHIPPING_COMPLETE = (auto() for _ in '...')
# ---------------------------------------------------------------


# Классы MovieGenres и Movie
# 768
# 1. Реализуйте класс MovieGenres, описывающий флаг с жанрами кино. Флаг должен иметь пять элементов:
#     ACTION
#     COMEDY
#     DRAMA
#     FANTASY
#     HORROR
# 2. Также реализуйте класс Movie, описывающий фильм. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     name — название фильма
#     genres — жанр фильма (элемент флага MovieGenres)
# Класс Movie должен иметь один метод экземпляра:
#     in_genre() — метод, принимающий в качестве аргумента жанр и возвращающий True, если фильм принадлежит данному жанру, или False в противном случае
# Экземпляр класса Movie должен иметь следующее неформальное строковое представление:
# <название фильма>
# ---------------------------------------------------------------
from enum import Flag, auto

class MovieGenres(Flag):    
    ACTION = auto()
    COMEDY = auto()
    DRAMA = auto()
    FANTASY = auto()
    HORROR = auto()

class Movie:
    def __init__(self, name: str, genres: 'MovieGenres') -> None:
        self.name = name
        self.genres = genres


# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Декоратор @reverse_args
# 802
# Вам доступен декоратор @reverse_args, который передает все позиционные аргументы в декорируемую функцию в обратном порядке. Реализуйте декоратор @reverse_args в виде класса декоратора.
# Примечание 1. Не забывайте, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимый декоратор @reverse_args, но не код, вызывающий его.﻿
# ---------------------------------------------------------------
from typing import Any, Callable
import functools

# def reverse_args(func):
#     @functools.wraps(func)
#     def wrapper(*args, **kwargs):
#         args = reversed(args)
#         return func(*args, **kwargs)
#     return wrapper


class reverse_args:
    def __init__(self, func: Callable[..., Any]) -> None:
        functools.update_wrapper(self, func)
        self.func = func

    def __call__(self, *args: Any, **kwargs: Any) -> Any:
        args = reversed(args)
        return self.func(*args, **kwargs) 


# -----тесты -------
@reverse_args
def power(a, n):
    return a ** n
    
print(power(2, 3))


@reverse_args
def concat(a, b, c):
    return a + b + c
    
print(concat('apple', 'cherry', 'melon'))

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Декоратор @limited_calls
# 788
# Реализуйте класс декоратор @limited_calls, который принимает один аргумент:
#     n — целое число
# Декоратор должен разрешать вызывать декорируемую функцию n раз. Если декорируемая функция вызывается более n раз, должно быть возбуждено исключение MaxCallsException с текстом:
# Превышено допустимое количество вызовов
# Примечание 1. Не забывайте про то, что декоратор не должен поглощать возвращаемое значение декорируемой функции, а также должен уметь декорировать функции с произвольным количеством позиционных и именованных аргументов.
# ---------------------------------------------------------------
from typing import Callable
import functools

class MaxCallsException(Exception):
    pass


class limited_calls:
    """
    Декоратор должен разрешать вызывать декорируемую функцию n раз. 
    Если декорируемая функция вызывается более n раз, должно быть возбуждено исключение MaxCallsException с текстом:
    Превышено допустимое количество вызовов
    """


    def __init__(self, n: int) -> None:
        self.n = n
        self.counter = 0 
        
    
    def __call__(self, func: Callable[..., Any]) -> Any:      

        @functools.wraps(func)
        def wrapper(*args, **kwargs): 
            if self.counter > self.n - 1:       
                raise MaxCallsException('Превышено допустимое количество вызовов')                
            
            value = func(*args, **kwargs)
            self.counter += 1
            
            return value    
        return wrapper

# =====тест =========
@limited_calls(3)
def add(a, b):
    return a + b
    
print(add(1, 2))
print(add(3, 4))
print(add(5, 6))

try:
    print(add())
    print(add())
except MaxCallsException as e:
    print(e)
# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Декоратор @takes_numbers
# 776
# # Реализуйте класс декоратор @takes_numbers, который проверяет, что все аргументы, передаваемые в декорируемую функцию, принадлежат типам int или float. Если хотя бы один аргумент принадлежит какому-либо другому типу, должно быть возбуждено исключение TypeError с текстом:
# Аргументы должны принадлежать типам int или float
# ---------------------------------------------------------------

from typing import Any, Callable
from functools import update_wrapper
from itertools import chain

class takes_numbers:
    """
    класс декоратор @takes_numbers, который проверяет, что все аргументы, передаваемые в декорируемую функцию, принадлежат типам int или float. Если хотя бы один аргумент принадлежит какому-либо другому типу, должно быть возбуждено исключение TypeError с текстом:
    Аргументы должны принадлежать типам int или float
    """
    def __init__(self, func: Callable[..., Any]) -> None:
        update_wrapper(self, func)      # сохранение информации о декорируемой функции
        self.func = func

    def __call__(self, *args: int | float, **kwargs: int | float) -> Any:
        for arg in chain(args, kwargs.values()):
            if not isinstance(arg, (int, float)):
                raise TypeError('Аргументы должны принадлежать типам int или float')    
        value = self.func(*args, **kwargs)
        return value

# =========
@takes_numbers
def mul(a, b):
    return a * b
    
print(mul(1, 2))
print(mul(1, 2.5))
print(mul(1.5, 2))
print(mul(1.5, 2.5))

# =========
@takes_numbers
def mul(a, b):
    return a * b
    
try:
    print(mul(1, '2'))
except TypeError as error:
    print(error)        

# ----преп------------------------------------------------------
import functools

class takes_numbers:
    def __init__(self, func):
        functools.update_wrapper(self, func)
        self.func = func

    def __call__(self, *args, **kwargs):
        if any((
                not all(isinstance(arg, (int, float)) for arg in args),
                not all(isinstance(arg, (int, float)) for arg in kwargs.values())
        )):
            raise TypeError('Аргументы должны принадлежать типам int или float')
        return self.func(*args, **kwargs)

# ---------------------------------------------------------------



# Декоратор @returns
# 776
# Реализуйте класс декоратор @returns, который принимает один аргумент:
    # datatype — тип данных
# Декоратор должен проверять, что возвращаемое значение декорируемой функции принадлежит типу datatype. Если возвращаемое значение принадлежит какому-либо другому типу, должно быть возбуждено исключение TypeError.
# ---------------------------------------------------------------
from typing import Any, Callable
from functools import wraps



class returns:
    """
    класс декоратор @returns, должен проверять, что возвращаемое значение декорируемой функции принадлежит типу datatype. Если возвращаемое значение принадлежит какому-либо другому типу, должно быть возбуждено исключение TypeError
    """
    def __init__(self, datatype: object) -> None:
        self.datatype = datatype

    def __call__(self, func: Callable[..., Any]) -> Any: 
        @wraps(func)
        def wrapper(*args, **kwargs):
            value = func(*args, **kwargs)
            
            if not isinstance(value, self.datatype):
                raise TypeError
            
            return value
        return wrapper

# ====тестs ==========
@returns(int)
def add(a, b):
    return a + b

print(add(1, 2))


# ==============
@returns(int)
def add(a, b):
    return a + b

try:
    print(add('1', '2'))
except Exception as error:
    print(type(error))

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Декоратор @exception_decorator
# 770
# Реализуйте класс декоратор @exception_decorator, который возвращает
    # кортеж (value, None), если декорируемая функция завершила свою работу без возбуждения исключения, где value — возвращаемое значение декорируемой функции
    # кортеж (None, errortype), если во время выполнения декорируемой функции было возбуждено исключение, где errortype — тип возбужденного исключения
# ---------------------------------------------------------------
from functools import update_wrapper
from typing import Any, Callable


class exception_decorator:
    """
    класс декоратор , который возвращает 
    - кортеж (value, None), если декорируемая функция завершила свою работу без возбуждения исключения, где value — возвращаемое значение декорируемой функции
    - кортеж (None, errortype), если во время выполнения декорируемой функции было возбуждено исключение, где errortype — тип возбужденного исключения
    """
    def __init__(self, func: Callable[..., Any]) -> None:
        update_wrapper(self, func)
        self.func = func

    def __call__(self, *args: Any, **kwargs: Any) -> Any:
        try:
            value = self.func(*args, **kwargs)
        except Exception as err:
            errortype = type(err)
            return (None, errortype)
        
        return (value, None)

# =========тесты ===========
@exception_decorator
def func(x):
    return 2*x + 1
    
print(func(1))
print(func('bee'))

#  ===========
@exception_decorator
def f(x, y):
    return x * y
    
print(f('stepik', 10))
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Декоратор @ignore_exception
# 756
# Реализуйте класс декоратор @ignore_exception, который принимает произвольное количество позиционных аргументов — типов исключений, и выводит текст:
# Исключение <тип исключения> обработано
# если во время выполнения декорируемой функции было возбуждено исключение, принадлежащее одному из переданных типов. Если возбужденное исключение не принадлежит ни одному из переданных типов, оно должно быть возбуждено снова.
# ---------------------------------------------------------------
from functools import update_wrapper, wraps
from typing import Any, Callable


class ignore_exception:
    """
    класс декоратор @ignore_exception, который принимает произвольное количество позиционных аргументов — типов исключений, и выводит текст:Исключение <тип исключения> обработано если во время выполнения декорируемой функции было возбуждено исключение, принадлежащее одному из переданных типов. Если возбужденное исключение не принадлежит ни одному из переданных типов, оно должно быть возбуждено снова.
    """
    def __init__(self, *args: Any) -> None:        
        self.args_err = args


    def __call__(self, decorated_function: Callable) -> Any:
        @wraps(decorated_function)
        def wrapper(*args, **kwargs):
            try:
                value = decorated_function(*args, **kwargs)
                return value
            except (self.args_err) as err:              
                    print(f'Исключение {err.__class__.__name__} обработано')   #  type(err).__name__
                        
        return wrapper 

# =====тесты =======
@ignore_exception(ZeroDivisionError, TypeError, ValueError)
def func(x):
    return 1 / x
    
func(0)
# =====тесты =======
min = ignore_exception(ZeroDivisionError)(min)

try:
    print(min(1, '2', 3, [4, 5]))
except Exception as error:
    print(type(error))
# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Декоратор @type_check
# 752
# # Реализуйте класс декоратор @type_check, который принимает один аргумент:
#     types — список, элементами которого являются типы данных
# Декоратор должен проверять, что типы всех позиционных аргументов, передаваемых в декорируемую функцию, полностью сопоставляются с типами из списка types, то есть типом первого аргумента является первый элемент списка types, типом второго аргумента — второй элемент списка types, и так далее. Если данное условие не выполняется, должно быть возбуждено исключение TypeError.
# Если количество позиционных аргументов больше, чем количество элементов в списке types, то не сопоставляемые аргументы не должны учитываться при проверке. Если количество позиционных аргументов меньше чем количество элементов в списке types, то не сопоставляемые типы из списка types не должны учитываться при проверке.
# ---------------------------------------------------------------
from typing import Any, Callable
from functools import wraps


class type_check:
    """
    класс декоратор @type_check проверяет, что типы всех позиционных аргументов, передаваемых в декорируемую функцию, полностью сопоставляются с типами из списка types, то есть типом первого аргумента является первый элемент списка types, типом второго аргумента — второй элемент списка types, и так далее. Если данное условие не выполняется, должно быть возбуждено исключение TypeError.
    """
    def __init__(self, types: object) -> None:
        self.types = types

    def __call__(self, decorated_function: Callable[..., Any]) -> Any:
        @wraps(decorated_function)
        def wrapper(*args, **kwargs):            
            for arg, arg_type in zip(args, self.types):
                if isinstance(arg, arg_type):  # args[i] == type(self.types[i]):
                    continue
                else:
                    raise TypeError
            value = decorated_function(*args, **kwargs)
            return value
        return wrapper

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Декоратор @track_instances
# 
#  Реализуйте декоратор @track_instances для декорирования класса. Декоратор должен добавлять декорируемому классу атрибут instances, содержащий список всех созданных экземпляров этого класса.
# Примечание 1. Экземпляры декорируемого класса в списке по атрибуту instances должны располагаться в том порядке, в котором они были созданы.
# ---------------------------------------------------------------
import functools

def track_instances(cls):
    """ декоратор @track_instances для декорирования класса. Декоратор должен добавлять декорируемому классу атрибут instances, содержащий список всех созданных экземпляров этого класса."""
    
    old_init = cls.__init__   # сохраняем исходный инициализатор
    cls.instances = []
    
    @functools.wraps(old_init)
    def new_init(self, *args, **kwargs):
        old_init(self, *args, **kwargs)    # вызываем исходный инициализатор
        
        cls.instances.append(self)

    cls.__init__ = new_init    # заменяем инициализатор новым
    return cls

# ====тесты =========
@track_instances
class Person:
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return f'Person({self.name!r})'


obj1 = Person('object 1')
obj2 = Person('object 2')

print(Person.instances)
# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Декоратор @add_attr_to_class
# 749
# Словарь атрибутов класса, в отличие от словаря атрибутов экземпляра класса, является объектом типа mappingproxy, а не dict.
# Приведенный ниже код:
# class MyClass:
#     pass
# print(type(MyClass.__dict__))
# выводит:
# <class 'mappingproxy'>
# Тип mappingproxy представляет собой упрощенный словарь. От типа dict он отличается меньшим количеством методов, а главное — отсутствием магического метода __setitem__(). Это значит, в объект типа mappingproxy нельзя напрямую добавить новую пару ключ-значение, а также изменить значение имеющегося ключа.
# Приведенный ниже код:
# class MyClass:
#     pass
# MyClass.__dict__['__doc__'] = 'docstring'
# приводит к возбуждению исключения:
# TypeError: 'mappingproxy' object does not support item assignment
# Для добавления классу необходимого атрибута можно использовать функцию setattr().
# Приведенный ниже код:
# class MyClass:
#     pass
# setattr(MyClass, '__doc__', 'docstring')
# print(MyClass.__doc__)
# выводит:
# docstring
# Реализуйте декоратор @add_attr_to_class для декорирования класса. Декоратор должен принимать произвольное количество именованных аргументов и добавлять их декорируемому классу в качестве атрибутов.
# ---------------------------------------------------------------
def add_attr_to_class(**attrs):
    def wrapper(cls):
        for key, value in attrs.items():  
            setattr(cls, key, value)
        return cls
    return wrapper
     

# ===тест ======
@add_attr_to_class(first_attr=1, second_attr=2)
class MyClass:
    pass

print(MyClass.first_attr)
print(MyClass.second_attr)
# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Декоратор @jsonattr
# 739
# Реализуйте декоратор @jsonattr для декорирования класса. Декоратор должен принимать один аргумент:
    # filename — имя json файла, содержимым которого является JSON объект
# Декоратор должен открывать файл filename и добавлять в качестве атрибута декорируемому классу каждую пару ключ-значение JSON объекта, содержащегося в этом файле.
# ---------------------------------------------------------------
import json


def jsonattr(filename):
    with open('test.json', 'r') as file:
        attrs = json.load(file)   
        
    def wrapper(cls):
        for name, value in attrs.items():
            setattr(cls, name, value)
        return cls
    return wrapper

# =====тест ========
with open('test.json', 'w') as file:
    file.write('{"x": 1, "y": 2}')

@jsonattr('test.json')
class MyClass:
    pass
    
print(MyClass.x)
print(MyClass.y)


# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Декоратор @singleton
# 682
# Реализуйте декоратор @singleton для декорирования класса. Декоратор должен превращать декорируемый класс в синглтон, то есть в класс, при первом вызове создающий единственный свой экземпляр и при последующих вызовах возвращающий его же.
# ---------------------------------------------------------------
import functools

def singleton(cls):
    old_new = cls.__new__ 

    cls.__instance = None
    

    @functools.wraps(old_new)
    def new_new(cls, *args, **kwargs):        
        if cls.__instance is None:
            cls.__instance = object.__new__(cls)
        return cls.__instance     

        
    cls.__new__ = new_new  
    return cls
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# Декоратор @snake_case
# 602
# Snake Case — стиль написания составных слов, при котором несколько слов разделяются символом нижнего подчеркивания (_) и не имеют пробелов в записи, причём каждое слово пишется с маленькой буквы. Например, bee_geek и hello_world.
# Camel Case — стиль написания составных слов, при котором несколько слов пишутся слитно без пробелов, при этом каждое слово пишется с заглавной буквы. Например, BeeGeek и HelloWorld.
# Частным случаем стиля Camel Case является lower Camel Case, когда с заглавной буквы пишутся все слова, кроме первого. Например, beeGeek и helloWorld.
# Реализуйте декоратор @snake_case для декорирования класса. Декоратор должен принимать один аргумент:
#     attrs — булево значение, по умолчанию равняется False
# Декоратор должен переименовать все не магические методы в декорируемом классе, меняя их стиль написания c Camel Case и lower Camel Case на Snake Case. Параметр attrs должен определять, будут ли аналогичным образом переименованы атрибуты класса. Если он имеет значение True, стиль написания имен атрибутов класса должен поменяться с Camel Case и lower Camel Case на Snake case, если False — остаться прежним.

# Примечание 1. Гарантируется, что имена всех не магических методов и атрибутов в классе написаны в стилях Camel Case, lower Camel Case или Snake Case.

# ---------------------------------------------------------------
import re


def snake_case(attrs=False):
    """Декоратор должен переименовать все не магические методы в декорируемом классе, меняя их стиль написания c Camel Case и lower Camel Case на Snake Case"""
 
    def wrapper(cls):

        attr_new = []
        for key, value in cls.__dict__.items():               
            
            # условие для методов
            if (not attrs) and callable(getattr(cls, key)) and (key[:2], key[-2:]) != ('__', '__'):                
                name_attr_split_list = re.sub(r'([A-Z])', r' \1', key).split()  # деление по заглавным буквам строки записанной слитно
                res = '_'.join(word.casefold() for word in name_attr_split_list)  

                if res.startswith('__'):  # если атрибут был защищенный, то образовывалось двойное подчеркивание (одно удалим) 
                    res = res[1:]                    

                name_attr = res[0].casefold() + res[1:]       
                attr_new.append((key, name_attr , value))
                
            
            # условие для атрибутов  
            elif (attrs) and (not callable(getattr(cls, key))) and (key[:2] != '__'):
                name_attr_split_list = re.sub(r'([A-Z])', r' \1', key).split()  # деление по заглавным буквам строки записанной слитно
                res = '_'.join(word.casefold() for word in name_attr_split_list)                     
                
                if res.startswith('__'):    # если атрибут был защищенный, то образовывалось двойное подчеркивание (одно удалим) 
                    res = res[1:]  

                attr_new.append((key, res , value))

               
        for old_attr, new_attr, value in attr_new:  # удаляем старые значения и добавляем новые имена атрибутов
            delattr(cls, old_attr)
            setattr(cls, new_attr, value)


        return cls            
    return wrapper
# ====тест =======
@snake_case()
class MyClass:
    def _FirstMethod(self):
        return 1

    def _superSecondMethod(self):
        return 2


obj = MyClass()

print(obj._first_method())
print(obj._super_second_method())
# ---------------------------------------------------------------
import re
from typing import Callable


def snake_case(attrs=False):
    regex_object = re.compile(r'_?\B([A-Z])')

    def wrapper(cls, *args, **kwargs):
        class_attributes = list(cls.__dict__.keys())
        for attribute in class_attributes:
            if any((
                    attribute.startswith('__') and attribute.endswith('__'),
                    not isinstance(cls.__dict__[attribute], Callable) and not attrs
            )):
                continue
            setattr(cls, regex_object.sub(r'_\1', attribute).lower(), cls.__dict__[attribute])
            delattr(cls, attribute)
        return cls

    return wrapper
# ---------------------------------------------------------------
from functools import wraps
from inflection import camelize, underscore

def snake_case(attrs=False):
    def decorator(cls):
        for i,j in list(cls.__dict__.items()):
            if i.count('_') < 4 and not callable(j) == attrs:
                attr = j
                delattr(cls,i)
                setattr(cls,underscore(i),attr)
        return cls
    return decorator
# ---------------------------------------------------------------



# Декоратор @auto_repr🌶️
# 595
# Реализуйте декоратор @auto_repr для декорирования класса. Декоратор должен принимать два аргумента в следующем порядке:
#     args — список имен атрибутов
#     kwargs — список имен атрибутов
# Декоратор должен реализовывать формальное строковое представление для экземпляров декорируемого класса. Строковое представление должно содержать имя класса и значения атрибутов экземпляра класса и иметь вид:
# <имя класса>(<атрибут>, <атрибут>, ...)
# Если атрибут указан в списке args, в строковом представлении должно быть только его значение, если же атрибут указан в списке kwargs, в строковом представлении должно быть его значение вместе с именем.
# Примечание 1. Атрибуты в форматированной строке должны располагаться в том порядке, в котором они были присвоены экземпляру.
# Примечание 2. Гарантируется, что при декорировании указываются все необходимые имена атрибутов. Также гарантируется, что имя атрибута указывается либо только в списке args, либо только в списке kwargs. Причем порядок расположения имен атрибутов в списках args и kwargs повторяет их расположение в сигнатуре инициализатора декорируемого класса.
# ---------------------------------------------------------------
import functools

def auto_repr(args=(), kwargs=()):
    def decorator(cls):
        old_repr = cls.__repr__

        @functools.wraps(old_str)
        def new_repr(self):
            old_repr(self)
            
            string1 = (f'{self.__dict__[i]!r}' for i in args)
            string1 = ', '.join(i for i in string1)
            
            string2 = (f'{i}={self.__dict__[i]!r}' for i in kwargs)
            string2 = ', '.join(i for i in string2)
            
            result_string = ", ".join(filter(None, (string1, string2)))        
                
            
            return f'{self.__class__.__name__}({result_string})'
        
        cls.__repr__ = new_repr


        return cls
    return decorator
# ---------------------------------------------------------------
def auto_repr(args, kwargs):
    def decorator(cls):
        def __repr__(self):
            attributes = []
            for attr in args:
                attributes.append(repr(getattr(self, attr)))
            for attr in kwargs:
                attributes.append(f'{attr}={getattr(self, attr)!r}')
            return f'{self.__class__.__name__}({", ".join(attributes)})'

        setattr(cls, '__repr__', __repr__)
        return cls

    return decorator
# ---------------------------------------------------------------


# Декоратор @limiter🌶️🌶️
# 544
# Любой пользовательский класс по умолчанию способен создавать бесконечное количество собственных экземпляров. Шаблон проектирования синглтон, напротив, гарантирует, что класс имеет только один собственный экземпляр, и при попытке создать новый, он возвращает уже имеющийся. 
# Реализуйте декоратор @limiter для декорирования класса, с помощью которого можно ограничивать количество создаваемых декорируемым классом экземпляров до определенного числа. Декоратор должен принимать три аргумента в следующем порядке:
#     limit — количество экземпляров, которое может создать декорируемый класс
#     unique — имя атрибута экземпляра декорируемого класса, значение которого является его идентификатором. Два экземпляра с одинаковыми идентификаторами существовать не могут. Если происходит попытка создать экземпляр, идентификатор которого совпадает с идентификатором одного из ранее созданных экземпляров, должен быть возвращен этот ранее созданный экземпляр
#     lookup — определяет, какой объект должен быть возвращен, если превышено ограничение limit, а значение атрибута unique ранее не использовалось. При значении FIRST возвращается самый первый созданный экземпляр, при значении LAST — самый последний созданный экземпляр
# Примечание 1. Гарантируется, что экземпляры декорируемого класса всегда имеют атрибут, который содержит их идентификатор.
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Класс City
# 766
# Вам доступен класс City, описывающий город. При создании экземпляра класс принимает три аргумента в следующем порядке:
#     name — название города (тип str)
#     population — население города (тип int)
#     founded — год основания города (тип int)
# Экземпляр класса City имеет три атрибута:
#     name — название города
#     population — население города
#     founded — год основания города
# Также экземпляр класса City имеет следующее формальное строковое представление:
# City(name='<название города>', population=<население города>, founded=<год основания города>)
# Наконец, экземпляры класса City поддерживают между собой операцию сравнения с помощью операторов == и !=. Два города считаются равными, если их названия, население и годы основания совпадают.
# Реализуйте класс City в виде класса данных.

# ----- было ----------------------------------------------------
class City:
    def __init__(self, name, population, founded):
        self.name = name
        self.population = population
        self.founded = founded

    def __repr__(self):
        return f"City(name='{self.name}', population={self.population}, founded={self.founded})"

    def __eq__(self, other):
        if isinstance(other, City):
            return (self.name, self.population, self.founded) == (other.name, other.population, other.founded)
        return NotImplemented

# --------- СТАЛО !!! ------------------------------------------------------
from dataclasses import dataclass

@dataclass
class City:   
        name: str
        population: int
        founded :int
# ---------------------------------------------------------------




# Класс MusicAlbum
# 754
# Реализуйте неизменяемый класс MusicAlbum, описывающий музыкальный альбом. При создании экземпляра класс должен принимать четыре аргумента в следующем порядке:
#     title — название альбома (тип str)
#     artist — автор альбома (тип str)
#     genre — жанр альбома (тип str)
#     year — год выпуска альбома (тип int)
# Экземпляр класса MusicAlbum должен иметь четыре атрибута:
#     title — название альбома
#     artist — автор альбома
#     genre — жанр альбома
#     year — год выпуска альбома
# Также экземпляр класса MusicAlbum должен иметь следующее формальное строковое представление:
# MusicAlbum(title='<название альбома>', artist='<автор альбома>')
# Наконец, экземпляры класса MusicAlbum должны поддерживать между собой операцию сравнения с помощью операторов == и!=. Два музыкальных альбома считаются равными, если их названия, авторы и годы выпуска совпадают. 
# ---------------------------------------------------------------
from dataclasses import dataclass, field

@dataclass(frozen=True)
class MusicAlbum:
    title: str
    artist: str
    genre: str = field(repr=False, compare=False)
    year: int = field(repr=False)

# ------При использовании make_dataclass тоже можно указывать типы значений атрибутов, значения по умолчанию и делать экземпляры класса неизменяемыми.---------------------------------------------------------
from dataclasses import field, make_dataclass

MusicAlbum = make_dataclass('MusicAlbum',
                            [('title', str),
                             ('artist', str),
                             ('genre', str, field(repr=False, compare=False)),
                             ('year', int, field(repr=False))],
                            frozen=True)
# ---------------------------------------------------------------




# Класс Point
# 721
# Реализуйте класс данных Point, описывающий точку на координатной плоскости. При создании экземпляра класс должен принимать два аргумента в следующем порядке:
#     x — координата точки по оси xx (тип float), по умолчанию имеет значение 0.0
#     y — координата точки по оси yy (тип float), по умолчанию имеет значение 0.0
# Экземпляр класса Point должен иметь три атрибута:
#     x — координата точки по оси xx
#     y — координата точки по оси yy
#     quadrant — координатная четверть, к которой принадлежит точка (тип int). Если точка лежит на одной из осей, координатная четверть считается равной 0
# Класс Point должен иметь два метода экземпляра:
#     symmetric_x() — метод, возвращающий новый экземпляр класса Point, представляющий точку, симметричную текущей точке относительно оси xx
#     symmetric_y() — метод, возвращающий новый экземпляр класса Point, представляющий точку, симметричную текущей точке относительно оси yy
# Экземпляр класса Point должен иметь следующее формальное строковое представление:
# Point(x=<координата x>, y=<координата y>, quadrant=<координатная четверть>)
# Наконец, экземпляры класса Point должны поддерживать между собой операцию сравнения с помощью операторов == и!=. Две точки считаются равными, если их координаты по обеим осям совпадают.
# Примечание 1. Для точки с координатами (x,y)(x,y) симметричной относительно оси xx будем считать точку с координатами (x,−y)(x,−y), симметричной относительно оси yy — точку с координатами (−x,y)(−x,y).
# Примечание 2. Координатные четверти:
# ---------------------------------------------------------------

from dataclasses import dataclass, field

@dataclass
class Point:
    """
    класс данных Point, описывающий точку на координатной плоскости
    """
    x: int | float  = field(default=0.0)
    y: int | float = field(default=0.0)
    quadrant: int = field(init=False)

    def __post_init__(self) -> None:
        if not self.x or not self.y:
            self.quadrant = 0
        elif self.x > 0 and self.y > 0:
            self.quadrant = 1
        elif self.x < 0 and self.y > 0:
            self.quadrant = 2
        elif self.x < 0 and self.y < 0:
            self.quadrant = 3
        elif self.x > 0 and self.y < 0:
            self.quadrant = 4

    def symmetric_x(self) -> "Point":
        return Point(self.x, -self.y)

    def symmetric_y(self) -> "Point":
        return Point(-self.x, self.y)
# ------преп----------------------------------------------------
from dataclasses import dataclass, field


@dataclass
class Point:
    x: float = 0.0
    y: float = 0.0
    quadrant: int = field(default=0, compare=False)

    def __post_init__(self):
        if self.x > 0 and self.y != 0:
            self.quadrant = (1, 4)[self.y < 0]
        elif self.x < 0 and self.y != 0:
            self.quadrant = (2, 3)[self.y < 0]

    def symmetric_x(self):
        return type(self)(self.x, -self.y)

    def symmetric_y(self):
        return type(self)(-self.x, self.y)
# ---------------------------------------------------------------




# Классы FootballPlayer и FootballTeam
# 719
# 1. Реализуйте класс данных FootballPlayer, описывающий футбольного игрока. При создании экземпляра класса должен принимать три аргумента в следующем порядке:
#     name — имя футболиста (тип str)
#     surname — фамилия футболиста (тип str)
#     value — рыночная стоимость футболиста в евро (тип int)
# Экземпляр класса FootballPlayer должен иметь три атрибута:
#     name — имя футболиста
#     surname — фамилия футболиста
#     value — рыночная стоимость футболиста в евро
# Также экземпляр класса FootballPlayer должен иметь следующее формальное строковое представление:
# FootballPlayer(name='<имя футболиста>', surname='<фамилия футболиста>')
# Наконец, экземпляры класса FootballPlayer должны поддерживать между собой все операции сравнения с помощью операторов ==, !=, >, <, >=, <=. Два футболиста считаются равными, если их рыночные стоимости совпадают. Футболист считается больше другого футболиста, если его рыночная стоимость больше.
# 2. Реализуйте класс данных FootballTeam, описывающий футбольную команду. При создании экземпляра класса должен принимать один аргумент:
#     name — название команды (тип str)
# Экземпляр класса FootballTeam должен иметь два атрибута:
#     name — название команды (тип str)
#     players — изначально пустой список, содержащий игроков команды (тип list)
# Класс FootballTeam должен иметь один метод экземпляра:
#     add_players() — метод, принимающий произвольное количество позиционных аргументов, каждый из которых представляет футболиста, и добавляющий их в команду
# Также экземпляр класса FootballTeam должен иметь следующее формальное строковое представление:
# FootballTeam(name='<название футбольной команды>')
# Наконец, экземпляры класса FootballTeam должны поддерживать между собой операции сравнения с помощью операторов == и !=. Две футбольные команды считаются равными, если их названия совпадают.
# ---------------------------------------------------------------
from dataclasses import dataclass, field


@dataclass(order=True)
class FootballPlayer:
    """
    класс данных FootballPlayer, описывающий футбольного игрока
    """
    
    name: str = field(compare=False) 
    surname: str = field(compare=False) 
    value: int = field(repr=False)



@dataclass
class FootballTeam:
    """
    класс данных FootballTeam, описывающий футбольную команду
    """
    
    name: str
    players:  list = field(default_factory=list, compare=False, repr=False)

    
    def add_players(self, *args) -> None:
        """метод, принимающий произвольное количество позиционных аргументов, каждый из которых представляет футболиста, и добавляющий их в команду"""
        self.players.extend(args)


# ---------------------------------------------------------------
from dataclasses import make_dataclass, field


FootballPlayer = make_dataclass(
    'FootballPlayer', [('name', str, field(compare=False)),
                       ('surname', str, field(compare=False)),
                       ('value', int, field(repr=False))], 
    order=True
)


FootballTeam = make_dataclass(
    'FootballTeam', [('name', str),
                     ('players', list, field(default_factory=list, compare=False, repr=False))],
    namespace={'add_players': lambda self, *players: self.players.extend(players)}
)
# ---------------------------------------------------------------


# ---------------------------------------------------------------
# ------- решение доп задач -------------------------------------
# ---------------------------------------------------------------
# ---------------------------------------------------------------

# Функция anything()
# 485
# Реализуйте функцию anything(), которая возвращает такой объект, результат сравнения с которым c помощью операторов ==, !=, >, <, >= и <= всегда равен True.
# Примечание 1. В тестирующую систему сдайте программу, содержащую только необходимую функцию anything(), но не код, вызывающий ее.
# ---------------------------------------------------------------
class Anything:
    def __eq__(self, __o: object) -> bool:
        return True

    __ne__ = __lt__ = __gt__ = \
    __le__ = __ge__ = __eq__

def anything():
    return Anything()


# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Класс Vector
# 
# Реализуйте класс Vector, экземпляр которого представляет собой вектор произвольной размерности. Экземпляр класса Vector должен создаваться на основе собственных координат:

# a = Vector(1, 2, 3)
# b = Vector(3, 4, 5)
# c = Vector(5, 6, 7, 8)

# В качестве неформального строкового представления вектор должен иметь собственные координаты, заключенные в круглые скобки:

# print(a)                       # (1, 2, 3)
# print(b)                       # (3, 4, 5)
# print(c)                       # (5, 6, 7, 8)

# Векторы должны поддерживать между собой операции сложения, вычитания, произведения и нормирования:

# print(a + b)                   # (4, 6, 8)
# print(a - b)                   # (-2, -2, -2)
# print(a * b)                   # 1*3 + 2*4 + 3*5 = 26
# print(c.norm())                # sqrt(5**2 + 6**2 + 7**2 + 8**2) = sqrt(174) = 13.19090595827292

# а также операции сравнения на равенство и неравенство:

# print(a == Vector(1, 2, 3))    # True
# print(a == Vector(4, 5, 6))    # False

# При попытке выполнить какую-либо операцию с векторами разной размерности должно быть возбуждено исключение ValueError с текстом:

# Векторы должны иметь равную длину
# ---------------------------------------------------------------

from math import sqrt



class Vector:
                   
    def __init__(self, *args: "Vector") -> None:
        self.args = args
        

    @staticmethod
    def if_different_len(obj1: "Vector", obj2: "Vector"):
        if len(obj1) != len(obj2):
            raise ValueError('Векторы должны иметь равную длину')


    def __len__(self) -> int:
        return len(self.args)


    def __str__(self):       
        return ', '.join(str(i) for i in self.args)


    def __add__(self, other) -> "Vector":
        self.if_different_len(self, other)
        if isinstance(other, type(self)):    # type(self) или __class__        
            return Vector(tuple(self.args[i] + other.args[i] for i in range(len(self))))
        return NotImplemented


    def __sub__(self, other) -> "Vector":
        self.if_different_len(self, other)
        if isinstance(other, __class__):            
            return Vector(tuple(self.args[i] - other.args[i] for i in range(len(self))))
        return NotImplemented


    def __mul__(self, other) -> "Vector":
        self.if_different_len(self, other)
        if isinstance(other, __class__):    # type(self) или __class__          
            return Vector(sum(self.args[i] * other.args[i] for i in range(len(self))))
        return NotImplemented
            


    def norm(self) -> float:               
        return sqrt(sum(i**2 for i in self.args))
        


    def __eq__(self, other) -> bool:
        self.if_different_len(self, other)
        if isinstance(other, type(self)):    # type(self) или __class__  
            return self.args == other.args
        return NotImplemented

# ---------------------------------------------------------------
from operator import sub, mul
from math import sqrt
from functools import wraps

class Vector:
    def __init__(self, *args):
        self.arguments = args

    def __str__(self):
        return str(self.arguments)

    
    @staticmethod
    def _check_type(func):      # Декоратор что-бы не переписывать одно и тоже в каждый метод:
        @wraps(func)
        def wrapper(self, other):
            if isinstance(other, Vector):
                if len(self.arguments) != len(other.arguments):
                    raise ValueError('Векторы должны иметь равную длину')

                return func(self, other)
            return NotImplemented
        return wrapper

    @_check_type
    def __add__(self, other):
        return type(self)(*map(sum, zip(self.arguments, other.arguments)))

    @_check_type
    def __sub__(self, other):
        return type(self)(*map(lambda obj: sub(*obj), zip(self.arguments, other.arguments)))

    @_check_type
    def __mul__(self, other):
        return sum(map(lambda obj: mul(*obj), zip(self.arguments, other.arguments)))

    @_check_type
    def __eq__(self, other):
        return self.arguments == other.arguments

    def norm(self):
        return sqrt(sum(x ** 2 for x in self.arguments))
# ---------------------------------------------------------------



# Класс CaesarCipher
# 627
# Реализуйте класс CaesarCipher для шифровки и дешифровки текста с помощью шифра Цезаря. При создании экземпляра класса CaesarCipher должен указываться сдвиг, который будет использоваться при шифровке и дешифровке. За операцию шифрования должен отвечать метод encode(), за операцию дешифрования — decode():
# cipher = CaesarCipher(5)
# print(cipher.encode('Beegeek'))      # Gjjljjp
# print(cipher.decode('Gjjljjp'))      # Beegeek
# Обратите внимание, что при шифровке сдвиг должен происходить вправо, также заметьте, что регистр букв при шифровке и дешифровке должен сохраняться.
# Шифровке и дешифровке должны подвергаться только буквы латинского алфавита, все остальные символы, если они присутствуют, должны оставаться неизменными:
# print(cipher.encode('Биgeek123'))    # Биljjp123
# print(cipher.decode('Биljjp123'))    # Биgeek123
# Примечание 1. Гарантируется, что сдвигом является число из диапазона [1; 26].
# ---------------------------------------------------------------

    
# ---------------------------------------------------------------

# ---------------------------------------------------------------



# Классы ArithmeticProgression и GeometricProgression
# 637
# Реализуйте класс ArithmeticProgression для генерации членов арифметической прогрессии. При создании экземпляра класса ArithmeticProgression должны указываться первый член последовательности и разность прогрессии:
# progression = ArithmeticProgression(0, 1)
# for elem in progression:
#     if elem > 10:
#         break
#     print(elem, end=' ')    # 0 1 2 3 4 5 6 7 8 9 10
# Обратите внимание, что арифметическая прогрессия должна быть итерируемой, а также бесконечной.
# Аналогичным образом реализуйте класс GeometricProgression для генерации членов геометрической прогрессии. При создании экземпляра класса GeometricProgression должны указываться первый член последовательности и знаменатель прогрессии:
# progression = GeometricProgression(1, 2)
# for elem in progression:
#     if elem > 10:
#         break
#     print(elem, end=' ')    # 1 2 4 8
# Геометрическая прогрессия, как и арифметическая, должна быть итерируемой, а также бесконечной.
# ---------------------------------------------------------------
from abc import ABC, abstractmethod
from dataclasses import dataclass, field

@dataclass
class Progression(ABC):
    first_member: int
    step: int
    flag: bool = field(default=None, init=False)

    def __iter__(self): return self

    @abstractmethod
    def __next__(self):
        pass



class ArithmeticProgression(Progression):
    """
    класс для генерации членов арифметической прогрессии. 
    """
    
    def __next__(self):        
        result = self.first_member
        self.first_member += self.step
        return result
        


class GeometricProgression(Progression):
    """
    класс для генерации членов геометрической прогрессии
    """

    def __next__(self):        
        result = self.first_member
        self.first_member *= self.step
        return result
# ---------------------------------------------------------------
from abc import ABC, abstractmethod


class Progression(ABC):
    def __init__(self, start, step):
        self._current = start
        self._step = step

    def __iter__(self):
        return self

    @abstractmethod
    def __next__(self):
        pass


class ArithmeticProgression(Progression):
    def __next__(self):
        answer = self._current
        self._current += self._step
        return answer


class GeometricProgression(Progression):
    def __next__(self):
        answer = self._current
        self._current *= self._step
        return answer
# ---------------------------------------------------------------
from __future__ import annotations
from abc import ABC, abstractmethod
from operator import add, mul


class Progression(ABC):
    def __init__(self, first: int, step: int) -> None:
        self.first = first
        self.step = step

    def __iter__(self) -> Progression:  # from typing import Self (Python 3.11+)
        return self

    @abstractmethod
    def __next__(self, func: Callable[[int, int], int]) -> int:
        next = self.first
        self.first = func(self.first, self.step)
        return next


class ArithmeticProgression(Progression):
    def __next__(self) -> int:
        return super().__next__(add)

class GeometricProgression(Progression):
    def __next__(self) -> int:
        return super().__next__(mul)
# ---------------------------------------------------------------
import operator


class Progression:
    _func = None

    def __init__(self, start: int, step: int):
        self._current = start
        self._step = step

    def __iter__(self):
        return self

    def __next__(self):
        result = self._current
        self._current = self._func(self._current, self._step)
        return result


class ArithmeticProgression(Progression):
    _func = operator.add


class GeometricProgression(Progression):
    _func = operator.mul
# ---------------------------------------------------------------




# Классы Domain и DomainException
# 574
# Реализуйте класс исключений DomainException. Также реализуйте класс Domain для работы с доменами. Класс Domain должен поддерживать три способа создания своего экземпляра: напрямую через вызов класса, а также с помощью двух методов класса from_url() и from_email():
# domain1 = Domain('pygen.ru')                       # непосредственно на основе домена
# domain2 = Domain.from_url('https://pygen.ru')      # на основе url-адреса
# domain3 = Domain.from_email('support@pygen.ru')    # на основе адреса электронной почты
# При попытке создания экземпляра класса Domain на основе некорректных домена, url-адреса или адреса электронной почты должно быть возбуждено исключение DomainException с текстом:
# Недопустимый домен, url или email
# В качестве неформального строкового представления экземпляр класса Domain должен иметь собственный домен:
# print(str(domain1))                                # pygen.ru
# print(str(domain2))                                # pygen.ru
# print(str(domain3))                                # pygen.ru
# Примечание 1. Будем считать домен корректным, если он представляет собой последовательность из одной или более латинских букв, за которой следует точка, а затем снова одна или более латинских букв.
# Примечание 2. Будем считать url-адрес корректным, если он представляет собой строку http:// или https://, за которой следует корректный домен. 
# Примечание 3. Будем считать адрес электронной почты корректным, если он представляет собой последовательность из одной или более латинских букв, за которой следует собачка (@), а затем корректный домен.
# ---------------------------------------------------------------
import re    



class DomainException(Exception):
    pass




class Domain:

    __CORRECT_DOMAIN = r'[A-Za-z]+[.][A-Za-z]+'


    def __init__(self, string_whis_domain) -> None:        
        regex = rf'[A-Za-z]*({__class__.__CORRECT_DOMAIN})'   # шаблон домена   
        self.domain = __class__.is_valid_domain(string_whis_domain, regex)        
        
    def __str__(self): return str(self.domain)

    
    @classmethod
    def from_url(cls, string_whis_domain: str):
        regex = fr'https?://({cls.__CORRECT_DOMAIN})'   # шаблон url-адреса     
        name_domen = cls.is_valid_domain(string_whis_domain, regex)  
        return  cls(name_domen)

    @classmethod
    def from_email(cls,string_whis_domain):       
        regex = fr'[A-Za-z]+\@({cls.__CORRECT_DOMAIN})'   # шаблон email
        name_domen =cls.is_valid_domain(string_whis_domain, regex)  
        return  cls(name_domen)

    
    
    @staticmethod
    def is_valid_domain(string_whis_domain, regex):
        """проверка на корректность имён"""
            
        valid_match = re.fullmatch(regex, string_whis_domain)      # проверяем вся ли строка соответствует переданному шаблону
        search_match = re.search(rf'({__class__.__CORRECT_DOMAIN})', string_whis_domain)    # ищем вхождение домена
            
        if valid_match and search_match:
            value = str(search_match.group(1))            
            return value         
        raise DomainException('Недопустимый домен, url или email')  
                
# -----тесты 1-----------
domain1 = Domain('pygen.ru')                       # непосредственно на основе домена
domain2 = Domain.from_url('https://pygen.ru')      # на основе url-адреса
domain3 = Domain.from_email('support@pygen.ru')    # на основе адреса электронной почты

print(type(domain1))
print(type(domain2))
print(type(domain3))
# ------2----------------
domains = ['ip.ru', 'ao.org', 'npo.com', 'npo.com', 'zao.org', 'sibtred.info', 'ao.biz', 'npo.net', 'npo.net',
           'oao.net', 'zao.com', 'pahomov.org', 'bikova.ru', 'ooo.ru', 'transol.net', 'zao.com', 'rao.info', 'ooo.org',
           'krjukov.com', 'nikonova.com']

for d in domains:
    domain = Domain(d)
    print(domain)
# ------3----------
try:
    domain1 = Domain('12pygen..org')
except DomainException as e:
    print(e)

try:
    domain1 = Domain('https://pygen.ru///')
except DomainException as e:
    print(e)

try:
    domain1 = Domain('1support@pygen.ru')
except DomainException as e:
    print(e) 
# -----преп-----------------------------------------------------
import re


class DomainException(Exception):
    pass


class Domain:
    __CORRECT_DOMAIN = r'\w+\.\w+'
    __CORRECT_URL = fr'^https?://(?P<domain>{__CORRECT_DOMAIN})$'
    __CORRECT_EMAIL = fr'\w+@(?P<domain>{__CORRECT_DOMAIN})'

    def __init__(self, domain):
        if not re.fullmatch(self.__CORRECT_DOMAIN, domain):
            raise DomainException('Недопустимый домен, url или email')
        self.domain = domain

    def __str__(self):
        return self.domain

    @classmethod
    def from_url(cls, url):
        url = re.match(cls.__CORRECT_URL, url)
        if not url:
            raise DomainException('Недопустимый домен, url или email')
        return cls(url.group('domain'))

    @classmethod
    def from_email(cls, email):
        email = re.match(cls.__CORRECT_EMAIL, email)
        if not email:
            raise DomainException('Недопустимый домен, url или email')
        return cls(email.group('domain'))
# ---------------------------------------------------------------
import re

class DomainException(Exception):
    pass

class Domain:
    def __init__(self, domain):
        self.domain = self.check(domain)

    @staticmethod
    def check(text):
        try:
            return re.fullmatch(r'((http://|https://)|([A-z]+@))?(?P<dom>[A-z]+\.[A-z]+)', text).group('dom')
        except:
            raise DomainException('Недопустимый домен, url или email')

    def __str__(self):
        return str(self.domain)

    @classmethod
    def from_url(cls, url):
        return cls(url)

    @classmethod
    def from_email(cls, email):
        return cls(email)
# ---------самое короткое-------------------------------------------------
import re


class DomainException(Exception):
    pass


class Domain:
    def __init__(self, name):
        try:
            self._domain = re.fullmatch(r'^(https?://)?([a-z]+@)?([a-z]+\.[a-z]+)$', name).group(3)
        except AttributeError:
            raise DomainException('Недопустимый домен, url или email')

    def __str__(self):
        return self._domain

    from_url = from_email = lambda name: Domain(name)

# ------без регулярок ---------------------------------------------------------
class DomainException(Exception):
    pass

class Domain:
    def __init__(self, string):
        if not Domain.is_valid(string):
            raise DomainException('Недопустимый домен, url или email') 
        self.value = string

    def __str__(self):
        return self.value
    
    @classmethod
    def is_valid(cls, string):
        parts = string.partition('.')
        return parts[0].isalpha() and parts[2].isalpha()
    
    @classmethod
    def from_url(cls, string):
        parts = string.partition('://')
        if parts[0] in ('http', 'https'):
            return cls(parts[2])
        raise DomainException('Недопустимый домен, url или email')
    
    @classmethod
    def from_email(cls, string):
        parts = string.partition('@')
        if parts[0].isalpha():
            return cls(parts[2])
        raise DomainException('Недопустимый домен, url или email')





# Класс HighScoreTable
# 604
# Предположим, что у нас имеется некоторая игра. За каждую игровую сессию игрок получает определенное количество баллов в зависимости от своего результата. Вашей задачей является реализация класса HighScoreTable — таблицы рекордов, которую можно будет обновлять с учетом итоговых результатов игрока.
# Изначально таблица рекордов является пустой. Максимальное количество рекордов указывается при создании таблицы:
# high_score_table = HighScoreTable(3)
# Таблица должна позволять просматривать текущие рекорды и добавлять новые результаты:

# print(high_score_table.scores)    # []
# high_score_table.update(10)
# high_score_table.update(8)
# high_score_table.update(12)
# print(high_score_table.scores)    # [12, 10, 8]

# Текущие рекорды всегда должны располагаться в порядке убывания. Так как таблица содержит именно рекорды, то после заполнения таблицы добавляться должны только те результаты, которые лучше текущих:

# high_score_table.update(6)
# high_score_table.update(7)
# print(high_score_table.scores)    # [12, 10, 8]
# high_score_table.update(9)
# print(high_score_table.scores)    # [12, 10, 9]

# Таблица должна поддерживать сброс всех результатов:

# high_score_table.reset()
# print(high_score_table.scores)    # []
# ---------------------------------------------------------------
class HighScoreTable:
    """
    класс HighScoreTable — таблицы рекордов, которую можно будет обновлять с учетом итоговых результатов игрока
    """
    def __init__(self, amount: int) -> None:              
        self.scores = []
        self._amount = amount    

    
    def update(self, result: int) -> None:
        """добавлять новые результаты"""      
        self.scores.append(result)
        self.scores.sort(reverse=True)   

        if (len(self.scores) > self._amount):
            self.scores.pop()

    
    def reset(self) -> None:
        """сброс всех результатов"""
        self.scores.clear()




high_score_table = HighScoreTable(3)

print(high_score_table.scores)
high_score_table.update(10)
high_score_table.update(8)
high_score_table.update(12)
print(high_score_table.scores)

high_score_table.update(18)
high_score_table.update(11)
high_score_table.update(13)
print(high_score_table.scores)
# ---------------------------------------------------------------

# ---------------------------------------------------------------


# 
# 
# 
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# 
# 
# 
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# 
# 
# 
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# 
# 
# 
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# 
# 
# 
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# 
# 
# 
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# 
# 
# 
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------



# 
# 
# 
# ---------------------------------------------------------------

# ---------------------------------------------------------------

# ---------------------------------------------------------------














